<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小程序上传视频到七牛云的实践</title>
    <url>/2020/05/25/qiniuyun/</url>
    <content><![CDATA[<blockquote>
<p>好久没有更新推文了，这段时间也是在做一个小项目，一开始想的是人脸识别并上传视频到七牛云的，但是后来想想好像不用这个功能，但是我实现后才知道。所以就写一下上传的功能吧。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/03fb95a7-8bc3-4d74-9b4f-34d443662d14.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>大家都知道七牛云就是一个线上的云存储空间，可以上传一些图片、视频等多媒体资源，对于小型项目来说是很方便的。但是好像他的存储空间1个月就会过期，你的资源可能访问不了（充钱）。</p>
<p>偶然接触这个功能是因为在做小程序的过程中，录制的视频不能转码成base64格式的（真机调试模式），开发者工具调试是正常的，真机调试就会不正常。</p>
<p>我发现在工具调试下生成的是以http开头的文件，真机的时候就会生成wxfile的文件，一度怀疑是这个问题导致我不能转base64，后来多方求证之后发现，<code>根本不用关心什么开头</code>，预览是正常的。</p>
<p><strong>这个问题仅存在真机调试的模式下面【谨记】</strong></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们要先去七牛云注册一个开发者账号，相信大家都会。</p>
<p>接下来我们就可以上传我们的文件了。但是官方写的太难懂了，以至于我连文档都看得不太清楚。经过自己的一番折磨着没有搞清楚这个uptoken是怎么获取的，不像其他的三方工具一样简便，直接是他们生成的。</p>
<p>没办法，我找了几篇文章讲关于上传凭证的生成方式也没有搞明白。后来我就在一个github里边找到了小程序的SDK，但是也有不少的问题。</p>
<h3 id="找对文档"><a href="#找对文档" class="headerlink" title="找对文档"></a>找对文档</h3><p>我觉得这个文档隐藏的还是很不错的，找了半天没有找到。</p>
<p><a href="https://developer.qiniu.com/sdk#community-sdk" target="_blank" rel="noopener">小程序SDK</a></p>
<p>拿到小程序的SDK之后我们就可以在用的地方进行JS文件的引入，在上面的链接里面，找到Qiniu-wxapp-SDK之后点击安装，文件就会下载到我们的本地。</p>
<p>在我们的小程序页面，你要使用的这个页面进行进入即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> qiniuUploader = <span class="built_in">require</span>(<span class="string">"../../qiniuUploader.js"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>如果是一开始弄的时候，我相信很多人都会来到Qiniu-wxapp-SDK的<a href="https://github.com/gpake/qiniu-wxapp-sdk/blob/master/README.md" target="_blank" rel="noopener">github文档</a>那里寻找，但是那里也没有找到关于凭证的生成方式。</p>
<p>后来我在获取凭证的详情页面找到了，但是这个凭证为了安全是由后端返回的，前端只需要调用api/uptoken的形式就可以获取。所以，唯一的办法就是我们需要把这个获取凭证的接口放上服务器，让公网是可以访问的。</p>
<p><a href="https://developer.qiniu.com/kodo/sdk/1283/javascript" target="_blank" rel="noopener">运行实例</a></p>
<p>在上面这个运行实例下载之后，其实我们唯一要用到的就是server.js文件和一个配置文件config.json文件。</p>
<p><code>server.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> qiniu = <span class="built_in">require</span>(<span class="string">"qiniu"</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(express.static(__dirname + <span class="string">"/"</span>));</span><br><span class="line"><span class="keyword">var</span> multiparty = <span class="built_in">require</span>(<span class="string">"multiparty"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> config=<span class="built_in">JSON</span>.parse(fs.readFileSync(path.resolve(__dirname,<span class="string">"config.json"</span>)));</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>看一下这个文件的关键代码，里面用到了express、qiniu、multiparty这三个依赖，那么这样一来就很简单了，初始化一个package.json文件安装依赖即可。</p>
<p><code>config.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"AccessKey"</span>: <span class="string">"你的AccessKey"</span>,  </span><br><span class="line">    <span class="attr">"SecretKey"</span>: <span class="string">"你的SecretKey"</span>,</span><br><span class="line">    <span class="attr">"Bucket"</span>: <span class="string">"空间名称"</span>,</span><br><span class="line">    <span class="attr">"Port"</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">"UptokenUrl"</span>: <span class="string">"uptoken"</span>,</span><br><span class="line">    <span class="attr">"Domain"</span>: <span class="string">"你的域名"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件很简单，就是做一些你的七牛云空间的信息配置，为了能够上传资源到你指定的空间。</p>
<p><code>AccessKey/SecretKey</code>：在你的个人中心里面，进去密钥管理就可以看到了，但是不要泄露出去就好。把这两个信息填写到config.json里面去。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/7f413b1e-d886-4a7a-a534-9bd5f33c9def.png" alt="AccessKey/SecretKey"></p>
<p><code>Bucket</code>:就是你创建的空间名称，可以在对象存储的空间管理进行新建空间，这个名字就是Bucket。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/36493a11-67a3-4d56-a5cb-9b648fd0e894.png" alt="domain"></p>
<p>domain:你的临时测试域名</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/9ea2b6c5-3a3b-4e31-899c-8ce4eab0f04a.png" alt></p>
<h3 id="获取uptoken"><a href="#获取uptoken" class="headerlink" title="获取uptoken"></a>获取uptoken</h3><p>明确了uptoken是由后端生成的之后，我们就把上面的server.js文件部署上去。这个文件其实就是接口文件，用于提供uptoken。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/0ab4275a-3132-44ae-b7db-b2226231fe5c.png" alt="目录"></p>
<p>上传服务器之后记得安装依赖，然后用pm2进行启动。这样你就可以在关闭服务器终端的时候还可以正常访问接口。用node启动你关闭终端就没用了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/6cebef6d-1622-484e-8286-3d3620114694.png" alt="看一下是否启动成功"></p>
<p>接下来我们就开始我们的uptoken获取吧，在浏览器输入你的服务器IP：端口/api/uptoken</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/e762636e-c628-4caa-ae0f-d67507a5b625.png" alt="获取成功"></p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>接下来就是视频上传的时候，在小程序onload的时候就初始化函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> qiniuUploader = <span class="built_in">require</span>(<span class="string">"../../qiniuUploader.js"</span>);<span class="comment">//记得引入</span></span><br><span class="line"></span><br><span class="line">initQiniu() &#123;</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    region: <span class="string">'NCN'</span>, <span class="comment">// 华北区(看你空间的地区)</span></span><br><span class="line">    uptokenURL: <span class="string">'https://yourserver.com/api/uptoken'</span>,<span class="comment">//上面的获取uptoken链接</span></span><br><span class="line">    uploadURL:<span class="string">'https://up-z2.qbox.me'</span>,<span class="comment">//上传的地址</span></span><br><span class="line">    domain: <span class="string">'测试域名/'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  qiniuUploader.init(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于uploadURL的地址：其实运行实例的文件（demo01）是没有这一项的配置的，但是我运行就会说uploadURL没有配置，那我只好写上去了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'ECN'</span>: uploadURL = <span class="string">'https://up.qbox.me'</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'NCN'</span>: uploadURL = <span class="string">'https://up-z1.qbox.me'</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'SCN'</span>: uploadURL = <span class="string">'https://up-z2.qbox.me'</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'NA'</span>: uploadURL = <span class="string">'https://up-na0.qbox.me'</span>; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>看自己的地区来写。</p>
<hr>
<p>最后就是上传了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交给七牛上传</span></span><br><span class="line">qiniuUploader.upload(filePath, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);<span class="comment">//它会返回一个在线地址，打开浏览器就可以访问你的视频、音频/图片</span></span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'error: '</span> + <span class="built_in">JSON</span>.stringify(error));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的filePath就是你录制视频、音频/图片的地址，如果是手机的话是wxfile开头，电脑调试就是http开头，不过没关系，都可以上传到七牛云。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>经过一番的折腾，其实一开始我们的思路应该是比较多的，网上的文章也是很多。但是不幸的是都没有解决我的问题。</p>
<p>在这里我就想说一句话，假如你在开发微信小程序，<code>任何时候你都要以你预览的时候为准</code>。因为很多时候不是你的项目代码写得有问题，而是开发者工具的问题，一个是电脑的路径一个是手机的路径，它们是不一样的。</p>
<p>在我真机调试的时候，怎么也不能执行wx.getFileSystemManager()里面的函数。在真机调试的时候页面右方一直报警告和错误，然后自动恢复调试然后又错误，它确实也不是报错信息。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/6ff2a087-632b-4c13-9063-e1873472c1e5.gif" alt></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>我从找不到实习到拿大厂offer经历了什么？</title>
    <url>/2020/05/15/recent-sumary/</url>
    <content><![CDATA[<blockquote>
<p>不知道大家在学校的时候有没有去找过实习，如果你有过一定的实习经验，那么接下来说的事情你应该有所感悟。</p>
</blockquote>
<p><img src="https://imgkr.cn-bj.ufileos.com/0c92c049-ff7b-46d1-bd04-bac08a3110c6.png" alt></p>
<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>一般来说，习惯了大学的咸鱼生活之后你是不愿意去面对残酷的社会的，毕竟你认为自己还没有到出去找工作谋生的时候，当时我也是这么想的。每天睡到中午12点，睡醒就打开心爱的视频吃外卖…它不香吗？</p>
<p>没错，在经历了这样的生活过后，我居然觉得人生是那么一眼望不到头，<code>不是前途无限好而是前途无比迷茫，啥也看不到</code>。但是不得不承认的一点是，这样的生活很美好，没有任何的压力，没有任何的想法，毫不夸张的说你就是一具没有灵魂的肉体。所以，<code>我决心改变自己</code>！</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/33cffb34-a56d-4c99-8b55-e211e053c328.png" alt></p>
<h2 id="02-你经历过找实习的痛苦吗"><a href="#02-你经历过找实习的痛苦吗" class="headerlink" title="02 你经历过找实习的痛苦吗"></a>02 你经历过找实习的痛苦吗</h2><p>到了大三暑假，原本没有紧张的氛围一下子变得无比紧张，因为有同学找到大厂实习了。</p>
<p>对于别人找到实习的消息，我是一边的羡慕又嫉妒呀，想着自己本来是可以找到实习的。没错自己的入门是比很多人晚，我是<code>大三的时候</code>才开始真正学习一门技术，才开始真正的接触前端这个职业。虽然说很多人都没有方向，甚至不知道计算机的出路在哪的时候，我就开始了自己的想法，起码比他们有了一点经验，因为<code>我确定了自己的方向</code>。</p>
<p>那时候的自己基本上都是为了学习而学习，努力去达到一个入门的标准，跟着慕课上面写一些简单的demo级别的项目，想想那段往事真的是不堪入目呀。不过还好还好。</p>
<h3 id="开始写简历了"><a href="#开始写简历了" class="headerlink" title="开始写简历了"></a>开始写简历了</h3><p>之前的那些经历不是让我最慌的，最慌的是写简历。<br>众所周知，计算机的专业是没有维修电脑的。但是我后来才知道的是，计算机专业学的东西原来在<code>企业中是不适用</code>的。怎么说呢？因为在写简历的阶段，我也找了很多种怎么写简历的方法、简历内容编写等等，然后我发现，自己的大学到底学了啥？为什么自己学的东西都跟我将来工作的差别这么大？小朋友，你是否有很多问号</p>
<p>没事，<code>大学生的学习效率是很高的</code>，举例来说你即使一个学期没有听课，前一晚上的努力学习你也不会挂科。所以我们就拿出大学学习的效率，认真准备了简历上面的内容，你要考啥我就复习啥，问你怕不怕？</p>
<h3 id="开始投简历了"><a href="#开始投简历了" class="headerlink" title="开始投简历了"></a>开始投简历了</h3><p>如无意外，我们一定是准备好了再投递简历的，但是如无意外你是没有面试机会的。怎么说呢？大部分的同学都是在<code>准备面试的时候就直接投递简历了</code>，但那时自己却没有这种想法也没有这种胆量。想想自己是几斤几两还是知道的，况且自己没有面试过任何一家公司，想想那种空前的压力有多大。<br>经过同学给的建议是先<code>尝试一下那些小的公司试一下水</code>，不要一开始就找你想要进的公司。所以我就照做了，那时候自己的无知、年少和满腔热血，把小公司都去海投了一遍。令我非常惊讶的是：<code>竟然没有一家有面试机会</code>？</p>
<h3 id="开始自闭阶段了"><a href="#开始自闭阶段了" class="headerlink" title="开始自闭阶段了"></a>开始自闭阶段了</h3><p>想着自己的几个月的付出现在却没有回音，想想难免会觉得心酸，难过，伤心…</p>
<p>不过虽然自己有那么一段的时间是属于<code>自闭的状态</code>，不想和别人说关于工作的事情。但是自己每天都有一种紧张的心态，因为万一有一家打电话过来了呢？不过没有万一。</p>
<p>我从一开始就没有注意到自己的问题，遇事都会觉得是其他的原因。虽然我知道是我的原因，我就是不愿意承认。对于自己第一次认清自己狼狈的面貌是有点不愿意，毕竟没有喜欢认可自己的不足，也不喜欢承认自己的原因、缺点。经过多方的思想斗争，跟同学朋友聊了之后我就开始<code>慢慢接受自己的不足</code>了，决心从简历上面下手修改。</p>
<h3 id="开始自我怀疑了"><a href="#开始自我怀疑了" class="headerlink" title="开始自我怀疑了"></a>开始自我怀疑了</h3><p>果不其然，修改了简历之后，自己有了第一次的面试机会。那时候是师兄进行的内推的，投了简历之后想着找两天时间好好从头过一遍简历上面的内容，但是没想到不多3个小时就来了电话。我裂开了</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/8445e891-1ba1-4761-9515-60998dbfc31a.png" alt></p>
<p>这个面试题我至今还保留，是自己的第一次面试。想想那时候的自己是多么紧张，我接到电话的那一瞬间整个人都僵住了，甚至连自我介绍都没有准备，直接开面。</p>
<p>顺便说一下，上面的面试题基本上没有答出来，甚至自己连cookie与session的区别都没有搞清楚，我真的是优秀。如无意外，稳挂的面试没什么可说的。</p>
<p>但是自己变得<code>更加怀疑</code>了，难道网上说的前端面试题都是骗人的吗？怎么都没有出现哪些常规的面试题，这不是为难我胖虎吗？一度<code>怀疑自己不适合搞技术</code>，不适合面试。自己跟很多的小伙伴一样，过度关注前端的题库，忘记了计算机基础的内容，其实上面的计算机组成原理在大学都学过，但是谁又会认真记下来呢？</p>
<h2 id="03-开始小公司实习"><a href="#03-开始小公司实习" class="headerlink" title="03 开始小公司实习"></a>03 开始小公司实习</h2><p>说来惭愧，自己那时候除了面试上面的这一家公司之外自己就没有其他机会了。<br>但是幸运的是，同学介绍我去了一家公司（没有面试直接进去），公司很小只有十几人左右，是团队老师的一个学生创立的公司，我就去那里实习了3个月。还好是这一次的实习，让我的简历上面有东西可写，不然自己可以断定自己是没有机会去面试其他的大公司的。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/1cd1a3f4-e27b-4741-94ce-44a9f4ccdf86.png" alt></p>
<h3 id="人生第一份工作"><a href="#人生第一份工作" class="headerlink" title="人生第一份工作"></a>人生第一份工作</h3><p>所以这是真正意义上的第一份工作，第一份从事技术类型的工作，紧张又期待。</p>
<p>虽然自己也知道<code>社会工作与学校生活不同</code>，但是有很多事情你是必须要考虑的。比如<code>租房</code>、<code>上班</code>和其他事情。很多时候，就像在学校的时候自己是完全不用考虑住房的问题的，但是出去外面的时候你就不得不面对这个问题，开始接受社会的毒打了。</p>
<ul>
<li>租房</li>
<li>独立生活</li>
<li>准时上下班</li>
<li>没有课间休息</li>
<li>中午不能躺床上</li>
<li>饭堂没有学校便宜</li>
<li>工资刚好能维持生活</li>
</ul>
<p>上面的这些问题都是你必须考虑到的，除此之外还是有很多事情不能如愿的，当你经历过实习的时候你就会更加向往学校的咸鱼生活。不过想想，实习就是这样的，舒服是留给死人的。正如那句话说的，<code>死于25，葬于75</code>。</p>
<h3 id="第一次感受工作"><a href="#第一次感受工作" class="headerlink" title="第一次感受工作"></a>第一次感受工作</h3><p>自己在学校学的东西基本上是没有用到工作当中去，第一个原因是这个公司的技术栈是比较老的，还是用着2015年前的技术，前期基本上是看公司文档学习，看源代码等慢慢熟悉公司的业务。</p>
<p>那时候自己就想着，以后自己的人生就是这样了吗？想想还是有一些不愿意的，毕竟跟自己想象中的不一样，我开始有一点害怕了，<code>开始变得急躁与焦虑</code>，感觉生活开始对我下手了，毫无还手之力的我只好默默承受着这一切。</p>
<ul>
<li>上班一天比上课一天劳累</li>
<li>周末比上班还累</li>
<li>没有娱乐生活</li>
<li>没有朋友交谈</li>
</ul>
<p>这些都是我在实习中遇到的困难、上班当中的真实感受。所以经历了3个月左右的实习，自己选择了离开。那时候其实还挺矛盾的，公司培养你这么久你却要离开，但是仔细想想还是有自己想法，觉得自己有更大的机会，<code>感谢当初自己的选择</code>。</p>
<h3 id="第一次工作感悟"><a href="#第一次工作感悟" class="headerlink" title="第一次工作感悟"></a>第一次工作感悟</h3><p>工作都是为了公司服务，<code>能做东西才是最好的</code>。</p>
<p>在一开始的那段时间，显得尤为难熬。虽然看起来你整天都是无所事事，但是你却不知道要干嘛，没人会在你身边教你，因为别人比你还忙，自己只能靠着仅有的一点智商猜测这个功能到底是干嘛用的。这是真实的情况，那时候我和我一朋友就是在这种懵逼的状态下度过了一段的时间。佩服佩服。</p>
<ul>
<li>理论无用，动手才是王道</li>
<li>加班是必须的操作</li>
<li>真正能帮你的只有自己</li>
<li>要有自己思考，不要让别人喂你</li>
<li>要给自己信心坚持下去</li>
</ul>
<p>上面的一些是我在实习的时候总结出来的，<code>实习就是等于提前接触这个社会</code>，接触将来自己要面对的生活环境、工作环境等。我认为最后一点才是重要的，要给自己信心走下去，要<code>不断暗示自己可以</code>的，一个人要是内心垮掉了基本上就没有动力了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/49d75235-7fd3-4274-b991-e87da564fdd9.png" alt></p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>从实习到现在这么长的时间，经过不断的沉淀、开发业务、学习前端技术、阅读技术书籍等努力，如今自己也如愿拿到了大厂offer，<code>感谢一路上帮助过我的小伙伴</code>，也<code>感谢自己曾经不懈的努力</code>。最近几天自己没有去更新内容，一方面是毕业答辩与毕业论文的事情需要准备，一方面是自己没有怎么去学习新的内容，没有输入何来产出，说来实在愧疚。</p>
<p>不过自己也是想借着总结过去的经历来鞭策自己不断向前，记住自己以往坎坷的实习经历，想想也不算很糟糕的事情嘛。最近几个月以来自己也是一直在不断总结过去的技术、学习方法、学习经历等，不得不说，我也不相信自己能够坚持下来，也有这么多东西可以分享。接下来的日子也要<code>好好沉淀，心如止水</code>。</p>
<p>相信你们也可以的！</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/50466025-fd36-41a6-b42d-f98befe706c3.png" alt></p>
]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>总结</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>从前端小白入门谈前端技术转型</title>
    <url>/2020/05/15/front-talk/</url>
    <content><![CDATA[<blockquote>
<p>今天早上偶然看到了前端早早聊大会的第一期的视频，然后里面讲的都是关于前端从技术向管理转型的一些心得体会，其中讲述人都是在公司中担任一些架构师、Leader等层面的人员。主要就是分享一些在工作中遇到的难题与解决方案等，今天我看的是字节跳动的竹隐老师关于技术转型的看法，觉得是十足的干货，也想发表一些看法。</p>
</blockquote>
<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>虽然自己的经验是不足以谈关于技术管理这一块的内容。但是觉得自己以后也会走上这一条路的，所以提前了解一下也不是不行，而且我觉得老师讲的是非常的好，能够引起我的思考。</p>
<p>看了老师的讲解之后感觉自己的思考都有了一定的高度。很多之前没有想过、没有考虑过的内容提前接触，那是一件很不错的事情，至少会对你以后的方向有一定的知道作用。很多小伙伴都说前端太多东西了，当你学了基本的入门知识之外你就会开始迷茫，我之前也有过这种感觉。但是，当你到了一定的高度之后，你才真正知道什么是迷茫。</p>
<p>现在我们要做的就是打好基础，为以后的迷茫做准备！</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/b43bf700-ecfc-49b1-bec5-155ced6cf10c.png" alt></p>
<h2 id="02-成长路线"><a href="#02-成长路线" class="headerlink" title="02 成长路线"></a>02 成长路线</h2><p>我们知道任何事情都会有属于它的体系，就好像我们人生的成长路线一样，经过九年义务教育，初高中然后大学等，都会有一个成长的路线。</p>
<p>同理做技术也是一样的道理，技术人的成长也是从基础开始慢慢地不断积累经验、不断对某一个领域的探索，然后在某个领域你会取得一定的成就。我们都是普遍从本科大学生起步，从毕业那一刻开始我们就会开始我们技术成长路线（转行不算），一路打怪升级，迷茫困惑到柳暗花明都是一段经历。</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>核心竞争力</strong></p>
<p>首先第一点就是我们要认清自己，看一下自己的能力在哪个范围之间，然后从那里开始起步。有同学可能会问，我从一开始学起不行吗？我认为这是没有必要的，一是浪费时间，二是价值不大。</p>
<p>当你有一定的基础的时候不用从零基础学起，应该给自己一定的难度来挑战一下，跳出自己的舒适圈迎接更大的挑战，这样你才会不断进步。我们都要从技术与业务两方面进行锻炼自己，技术是我们的安身立命之本，是支持我们业务开发根本；而业务则是我们创造用户价值的地方，用户价值最后也会转变成商业价值，这一系列的过程谁也离不开谁，都是相辅相成的。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/ed27d0ce-bdfc-450e-9097-556a7b716347.png" alt></p>
<p>接下来就谈一下如何在这两个方面进行深耕，竹隐老师认为我们应该通过以下的几个方面：</p>
<p><code>技术</code></p>
<ul>
<li>技术产出</li>
<li>流程改进</li>
<li>总结分享</li>
<li>源码阅读</li>
</ul>
<p><code>业务</code></p>
<ul>
<li>业务理解</li>
<li>进度管理</li>
<li>需求高质量开发</li>
</ul>
<p>其实不管是毕业生是这样做，就算是工作了很多年的技术人也应该遵循这些点，大体的方向是不变的，变的只是我们不同公司对应不同的业务罢了，这个肯定是不同的。</p>
<p>我本人最同意的就是关于技术总结分享的环节，程序员是一群很热爱分享的群体，他们或者没有做一些很伟大的业务开发或者架构设计，但是对于一些有意思的知识点都会分享。热爱分享到什么程度呢？就算只有100字的文章也会发布出来，这就是我们说的“水文”。当前之前我也会发一些“水文”，但是后来我会觉得成知识体系的发布可能会更好，不管是对别人还是对自己。</p>
<p>所以当你已经可以在上面的几点有自己的<code>理解和沉淀</code>，那么自然你就会有属于自己的标签，有属于自己的<code>竞争力</code>，满足了技术本身最基本的需求。</p>
<p><strong>扩大自己的影响力</strong></p>
<p><code>影响力很重要</code>，有时候给你带来的机会也是很多的。为什么这么说呢？因为你的圈子就在这了，当你能够在圈子里面小有名气的时候自然就会有人来主动认识你，不管是技术探讨还是工作交流乃至职位推荐都有。那么如何做呢？</p>
<ul>
<li>写博客</li>
<li>多逛社区</li>
<li>多与人交流</li>
<li>多总结自己</li>
</ul>
<p>这也是自己当前做的事情，<code>把自己的想法分享出去</code>，正所谓你有一个想法我有一个想法，交换之后我们就有两个想法。其实很多时候<code>技术不是最重要的</code>，比如你开发一个非常厉害的软件或者项目，没有人使用和买单，那你的价值就不存在了。</p>
<p>写博客这个方法我觉得是最有用的，可以对自己总结，也可以给别人提供一个思路，这多好呢！唯一要的是你需要一点时间来写一下而已。除了这个也可以与人交流，不管是面试还是与朋友交流，你都会有不一样的认识，相互借鉴学习过程中遇到的困难，发现的新技术、新工具等。但是我们对于无用的社交就不要参与了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/bc7b26ef-69b0-4d9a-859a-4ea7f36381a1.png" alt></p>
<h3 id="未来抉择"><a href="#未来抉择" class="headerlink" title="未来抉择"></a>未来抉择</h3><p>当你在技术的方面有不错的沉淀的时候，你就会觉得一切都游刃有余，这时候其实你就会进入了一个舒适区了，而且紧接着而来的就是迷茫期。</p>
<p>其实这就是我们需要做出自己选择的时候了，是继续前进还是保持不动？是走管理路线还是继续在技术方向深耕？这一切的事情都要我们去选择。</p>
<p><strong>深耕技术</strong></p>
<p>其实这也是一条可选的路线。我记得国外有一人就只写CSS，他也可以获得丰厚的收入，因为他在CSS这个领域就是一个专家级别的任务，所以对技术追求到了一种极致之后，你也会看到别人看不到的东西，你也会有自己独特的见解。</p>
<p><code>专家级别的任务其实不是他懂得了多少</code>，而是在这个<code>领域钻研的有多深</code>。所以关于某项技术的研究，如果你要进行深耕那么你就要做一些别人没有接触过的东西，研究一些别人没有做过的东西，拓宽知识盲区。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/6eb61ae7-efe5-4ba5-964c-1de4deed7b69.png" alt></p>
<p><strong>业务管理</strong></p>
<p>或者你已经疲倦了写代码的技术活，已经不想再去接触这份工作了。那么其实你大可以往管理的方向去靠，就好像你不会技术，但是你懂的如何<code>找技术的同学来帮你进行业务开发</code>。我觉得这是很多技术人都有这样的追求，认为写了几年的代码，没有什么意思。</p>
<p>虽然你看到的是自己运筹帷幄、统领全局的自己，万一有一天你被别人替代了你的竞争力在哪里？这里其实没有那么夸张，你还是有你的价值，还是会有对业务管理的嗅觉在里面的。</p>
<p>一般管理层的人都会对自己的业务非常地了解和熟悉，你知道怎么设计一些东西，你知道未来的方向在哪里，你对自己的产品有预见性的看法。但是假如你去到了别的公司你就会什么都不知道，因为上面说了我们的不同公司业务是不大一样的。你需要一段时间来上手这一份工作，当然你可能会带来一些新的思考与想法，这也是不错的。</p>
<p>我想说的其实就是纯管理的路线也有它自己的缺点。比如你会花更少的时间甚至不花时间在技术上面，你的想法也有可能<code>跟不上时代的发展</code>；你可能在跳槽之后发现来到了一个全新的领域，对业务不熟悉而且你基本上也忘记了技术的开发，这时候难免会有一些被抛弃的感觉。</p>
<p><strong>技术管理</strong></p>
<p>技术管理其实就是把两者的关系结合起来，一方面你可以跟得上现在的技术发展，你会去关注一些比较前沿的技术，你会想着如何把它运用到自己的项目当中；一方面你对自己的业务还是比较熟悉的，你知道业务未来有怎么样的方向。</p>
<p>这是一种<code>两者兼顾的职位</code>，可能你会觉得自己没有这么多时间去做技术，不放心别人去做。其实这也是很多Leader的烦恼，这里其实你做到用人不疑，疑人不用就好。只有你的小伙伴进不了你才会进步，给他们多一点的机会，团队才会有进步。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/af519c57-f3a4-4c1a-a7b8-9492107c3635.png" alt></p>
<h3 id="转型成功"><a href="#转型成功" class="headerlink" title="转型成功"></a>转型成功</h3><p>虽说你是确定了自己的未来方向，但是你仍然需要一段<code>过渡期</code>来习惯你的身份、习惯你的工作。这一阶段其实会有很多干扰你的信息，你要学会如何去调整这些负面的、干扰的信息。</p>
<p><code>转型成功意味着你有更大的责任</code>，即使你的工作重心已经不再是代码层面的东西，但是你得会沟通，你会技术，你也懂业务，你看得到未来。这些东西其实是一个人的品质，看似很虚的东西，但是你不具备这样的品质与能力，你的转型也不是成功的。</p>
<p>虽说别人羡慕你的工作，但是你有时候也是力不从心，对于一些细节性的东西也无法准确把握。这些种种的不愉快也是只有你能够体会到，也就是我们说的心魔。竹隐老师说的一句话我很喜欢“<code>体力支撑你到P6，脑力支撑你到P7，心力支撑你到P8</code>”,这样是从侧面反映了技术其实不是最重要的。</p>
<p><strong>思维转变</strong></p>
<p>一个人的习惯是有长期性的，一旦形成了就很难去改变，但是也不是不行。技术转型也是一样的，一开始你会以技术的方向来思考问题，出现问题总会从技术的角度看问题，其实很多时候从非技术的眼光来解决是更为恰当的。</p>
<p>最好我们从两个方向来看到某一个问题，更加有利于寻求高效的解决方案。分析问题的出现，是哪一个环节在业务的哪个版块出现问题，我应该有哪几种解决方案，假如能够顺利解决最终的效果是怎么样的。通过这样的思考我们也许能够更加高效的解决问题。</p>
<p><strong>软能力的培养</strong></p>
<p>首先关于软能力，有一本书《软技能：代码之外的生存指南》写的很不错，大家也可以去看一下。</p>
<p>我认为不论你是一个技术人员亦或是非技术人员，你都应该<code>懂得沟通的技巧</code>，有效的沟通可以节约大量的成本，也使得工作顺利。比如你要与产品进行对接，与下面的开发人员进行对接，任务的分配等等。<code>沟通与管理的软技能是至关重要的</code>，这也是你从技术转型之后你要具备的素质，严格来说你应该在做技术的时候已经可以有这些素质。</p>
<p><strong>坚定方向</strong></p>
<p>成为了技术管理的角色之后我们肯定是没有很多时间进行代码的编写的，一方面我们要开各种各样的会议，一方面我们会不放心同事的开发等等。总之你会有很多烦恼，总觉得自己走错路了，你还是觉得技术比较好，纯粹开发心无杂念。</p>
<p>这里我们就要坚定自己的路线，做到拿得起放得下。<code>放下过去的一些想法，转变自己的思维</code>，通过在业务与技术之间找到平衡点，找到新的成就走下去。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/7e95b31e-4f4e-4de2-a710-5e386f4f31a0.png" alt></p>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><p>通过看一场讲座真的拓宽了自己的很多想法，关于技术转型我们以后都会遇到的，不管你是从事技术方向还是管理方向都要做出自己的选择。即使你现在还是工作一年半年，你也要了解一下将来的方向，了解一下以后自己的方向应该是怎么走，早点规划自己的职业方向。</p>
<p>好了，今天的分享与思考就到这里，有兴趣的小伙伴们可以去搜索一下前端早早聊大会，我觉得是很不错的！上面有很多关于管理方面的思考与实践、还有一下关于团队建设等。</p>
<p>素材来源：</p>
<ul>
<li><a href="https://www.yuque.com/zaotalk/posts/s1ppt" target="_blank" rel="noopener">前端早早聊大会第一期</a></li>
</ul>
]]></content>
      <categories>
        <category>技术管理</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>技术管理</tag>
        <tag>技术转型</tag>
      </tags>
  </entry>
  <entry>
    <title>如何结合Node和Puppeteer做网络爬虫</title>
    <url>/2020/05/04/puppeteer/</url>
    <content><![CDATA[<blockquote>
<p>相信大家都听说过爬虫，我们也听说过Python是可以很方便地爬取网络上的图片，但是奈何本人不会Python，就只有通过Node来实践一下了。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/03fb95a7-8bc3-4d74-9b4f-34d443662d14.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><h3 id="何谓爬虫"><a href="#何谓爬虫" class="headerlink" title="何谓爬虫"></a>何谓爬虫</h3><p>其实爬虫用很官方的语言来描述就是“自动化浏览网络程序”，我们不用手动去点击、去下载一些文章或者图片。大家或许用过抢票软件，其实就是不断地通过软件访问铁路官方的接口，达到抢票的效果。但是，这类抢票软件是违法的。</p>
<p>那么怎么判断爬虫是不是违法呢？关于爬虫是否非法其实没有很明确的说法，一直都是中立的态度。爬虫是一种技术，技术本身没有违法的。但是你使用这种技术去爬取不正当的信息、有版权的图片等用于商用，那么你就是违法了。其实我们只要在使用爬虫技术的时候不要去爬个人隐私信息，不要爬取有版权的图片，最重要的是信息不要用于商业化的行为，爬虫不得干扰网站的正常运行等。</p>
<p>说了这么多其实就是要大家谨慎使用这一项技术。</p>
<h3 id="怎么爬"><a href="#怎么爬" class="headerlink" title="怎么爬"></a>怎么爬</h3><p>我查了一下资料，使用Node做爬虫的话其实有很多的途径，很多人比较喜欢的就是使用cheerio以及request来爬取。但是我也发现了一个比较好用的工具就是puppeteer，这一项技术是谷歌官方提供的一款工具。<code>它其实就是把人来做的事情变成了调用接口来实现</code>。看了一下官方的文档，主要可以实现以下的功能：<a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">puppeteer官方文档</a></p>
<ul>
<li>生成页面的屏幕截图和PDF。</li>
<li>爬取SPA（单页应用程序）并生成预渲染的内容（即“ SSR”（服务器端渲染））。</li>
<li>自动执行表单提交，UI测试，键盘输入等。</li>
<li>创建最新的自动化测试环境。使用最新的JavaScript和浏览器功能，直接在最新版本的Chrome中运行测试。</li>
<li>捕获站点的时间线跟踪以帮助诊断性能问题。</li>
<li>测试Chrome扩展程序。</li>
</ul>
<p>同时也看了一些同学的评价，觉得这个东西是非常的amazing啊！虽然我还没有深入去了解全部的API，但是也算是懂得大概的流程。大家如果官方的文档看不懂的话可以去B站看一下基本的介绍，<a href="https://space.bilibili.com/306107070/channel/detail?cid=79090" target="_blank" rel="noopener">puppeteer系列教程</a>。</p>
<h2 id="02-安装过程"><a href="#02-安装过程" class="headerlink" title="02 安装过程"></a>02 安装过程</h2><h3 id="puppeteer安装"><a href="#puppeteer安装" class="headerlink" title="puppeteer安装"></a>puppeteer安装</h3><p>关于这个安装的事情真的是非常的头疼，搞了许久才安装成功。原因就是高高的围墙使得城内的人出不去。所以我们只有换另外一种方法来安装了。</p>
<p>我们直接npm安装的过程<code>默认是要下载浏览器的</code>，我就是在这里一直卡住然后报错，试了好几次都是这样。经过网友们的介绍我们是可以不用在安装puppeteer的时候下载浏览器的，我们可以<code>事后才去下载</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env PUPPETEER_SKIP_CHROMIUM_DOWNLOAD&#x3D;true npm i puppeteer</span><br></pre></td></tr></table></figure>

<p>我们这样就可以成功安装puppeteer了，接下来我们就要去手动安装浏览器了。那么我们要去哪里下载呢？<a href="https://npm.taobao.org/mirrors/chromium-browser-snapshots/Win_x64/" target="_blank" rel="noopener">我要手动下载</a></p>
<p>这里面非常多的版本号，看了网上的教程我们要选择合适的版本号（不知道随便下载一个可不可以），我们回到项目的根目录下面<code>node_modules/puppeteer/package.json</code>这个目录，查看一下我们的浏览器版本是多少。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/6334b651-dd9c-4a5b-bc3b-fe3ac83e4ef5.png" alt></p>
<p><img src="https://imgkr.cn-bj.ufileos.com/342bed6b-f1af-4a27-8ca9-6466290ee7bb.png" alt></p>
<p>我这里就是现实737027的版本号，我们就去手动下载这个浏览器就可以了。大家可以根据自己的版本进行下载。</p>
<h3 id="浏览器引用"><a href="#浏览器引用" class="headerlink" title="浏览器引用"></a>浏览器引用</h3><p>我们光安装了之后还不行，还要进行<code>浏览器的引入</code>。这个也是非常的头疼，看了好多的教程都不可以。可能是他们的系统不一样，在这里折腾很久都想放弃了。还好有<a href="https://blog.csdn.net/qq799028706/article/details/88602254" target="_blank" rel="noopener">这篇文章</a>解决了我的问题，我知道是路径有误但我不知道怎么写。</p>
<p>浏览器下载之后我们就解压放到根目录下面，与package.json同级。然后我们在根目录下新建一个index.js文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">"puppeteer"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">"request"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="comment">//配置路径，关键！</span></span><br><span class="line"><span class="keyword">const</span> pathToExtension = <span class="built_in">require</span>(<span class="string">"path"</span>).join(</span><br><span class="line">    __dirname,</span><br><span class="line">    <span class="string">"./chrome-win/chrome.exe"</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>最后我的项目目录：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/05e9a136-74cc-4bc2-adc4-c386bb77f0e2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-选择网站"><a href="#03-选择网站" class="headerlink" title="03 选择网站"></a>03 选择网站</h2><p>我们都设置好了之后我们就开始选取一个网站进行测试了，我这里就选择了<a href="http://pic.netbian.com/4kfengjing/" target="_blank" rel="noopener">这个</a>来爬取图片。</p>
<p>其实我们知道万物皆可爬，只要分析对了就好。前端最熟悉不过的F12走一波就好。看了一下大概结构是长这样的，准备好了之后开始撸码。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/ea8e77e6-aa62-49fe-97f8-32b43abc8393.png" alt></p>
<p>反手一写（CV）就出来这样的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">"puppeteer"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">"request"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">2</span>;<span class="comment">//页数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">netbian</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pathToExtension = <span class="built_in">require</span>(<span class="string">"path"</span>).join(</span><br><span class="line">    __dirname,</span><br><span class="line">    <span class="string">"./chrome-win/chrome.exe"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    executablePath: pathToExtension,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">`http://pic.netbian.com/4kfengjing/index_<span class="subst">$&#123;i&#125;</span>.html`</span>);<span class="comment">//为了方便从第二页开始</span></span><br><span class="line">  <span class="keyword">let</span> images = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">"ul&gt;li&gt;a&gt;img"</span>, (el) =&gt;<span class="comment">//图片节点，API可查看官方介绍</span></span><br><span class="line">    el.map(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">"http://pic.netbian.com"</span> + x.getAttribute(<span class="string">"src"</span>))<span class="comment">//获取图片的src地址</span></span><br><span class="line">  );</span><br><span class="line">  mkdirSync(<span class="string">`./images`</span>); <span class="comment">// 存放目录</span></span><br><span class="line">  <span class="keyword">for</span> (m <span class="keyword">of</span> images) &#123;</span><br><span class="line">    <span class="keyword">await</span> downloadImg(m, <span class="string">"./images/"</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="string">".jpg"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  netbian(++i);<span class="comment">//下一页，具体结束页可以自己限制</span></span><br><span class="line">  <span class="comment">// 关闭</span></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;</span><br><span class="line">netbian(i);<span class="comment">//这里执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mkdirSync</span>(<span class="params">dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(dirname)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mkdirSync(path.dirname(dirname))) &#123;</span><br><span class="line">      fs.mkdirSync(dirname);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载文件 保存图片</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">downloadImg</span>(<span class="params">src, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> writeStream = fs.createWriteStream(path);</span><br><span class="line">    <span class="keyword">let</span> readStream = <span class="keyword">await</span> request(src);</span><br><span class="line">    <span class="keyword">await</span> readStream.pipe(writeStream);</span><br><span class="line">    readStream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文件下载成功"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    readStream.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"错误信息:"</span> + err);</span><br><span class="line">    &#125;);</span><br><span class="line">    writeStream.on(<span class="string">"finish"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文件写入成功"</span>);</span><br><span class="line">      writeStream.end();</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="03-开始爬取"><a href="#03-开始爬取" class="headerlink" title="03 开始爬取"></a>03 开始爬取</h2><p>我们直接在根目录运行node index.js就可以了。执行之后我们发现多了一个images目录，里面就是我们的图片了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/45ac33e4-786b-435e-a6f3-2a9c97529b88.png" alt></p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>其实关于puppeteer的使用还有很多，这里我只是介绍了爬虫是怎么用的而已。正如我们操作浏览器一样，我们也可以使用对应的API来实现，本人也是刚开始，后面还要慢慢去探讨这一项技术。我们其实不能保证网站的结构不改变，其实改变了我们就跟着变就好。</p>
<p>项目代码：<a href="https://github.com/wqs2019/Node-puppeteer" target="_blank" rel="noopener">github仓库</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/ee148a1a-465e-41db-8e79-fbe672a8eaef.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>




]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>puppeteer</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>你知道如何使用Node.js做邮箱验证吗</title>
    <url>/2020/05/01/nodemailer/</url>
    <content><![CDATA[<blockquote>
<p>相信大家都知道登录操作都会有一个接收验证码的过程,我之前一直对这个非常感兴趣,经常问同学手机验证码是怎么搞的,但是现在我们不用手机也照样可以实现这个功能。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/03fb95a7-8bc3-4d74-9b4f-34d443662d14.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>其实对于手机验证码来说，一般都要收费的，免费的一般是比较少的，而且都会有数量的限制。既然我们不能使用手机验证码来发送，那么我们就以曲线救国的方式来实现这个功能吧。</p>
<p>其实很简单，我们只要安装一个第三方的npm 包就可以了，这个包可以实现邮件的发送功能。这个包就是nodemailer，下面我们就一起来测试一下到底怎么样。</p>
<h2 id="02-安装nodemailer"><a href="#02-安装nodemailer" class="headerlink" title="02 安装nodemailer"></a>02 安装nodemailer</h2><p>我们随便新建一个目录，然后在根目录下面初始化package.json文件（npm init），然后我们就直接安装nodemailer即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nodemailer --save</span><br></pre></td></tr></table></figure>

<p>然后我们再新建一个入口文件app.js，用于测试代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">"nodemailer"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">let</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">  <span class="comment">// host: 'smtp.ethereal.email',</span></span><br><span class="line">  service: <span class="string">"qq"</span>, <span class="comment">// 使用了内置传输发送邮件 查看支持列表：https://nodemailer.com/smtp/well-known/</span></span><br><span class="line">  <span class="comment">//   port: 465, // SMTP 端口</span></span><br><span class="line">  secureConnection: <span class="literal">true</span>, <span class="comment">// 使用了 SSL</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    user: <span class="string">"alanwu.hd@qq.com"</span>,</span><br><span class="line">    pass: <span class="string">"xxxxxxxxxxx"</span>, <span class="comment">//授权码，并非QQ密码</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> mailOptions = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'"alanwu" &lt;alanwu.hd@qq.com&gt;'</span>, <span class="comment">// 发送地址</span></span><br><span class="line">  to: <span class="string">"157687xxxxx@163.com"</span>, <span class="comment">// 接收列表（可多个）</span></span><br><span class="line">  subject: <span class="string">"Hello,this is alan from China!"</span>, <span class="comment">// 主题</span></span><br><span class="line">  <span class="comment">// 发送text或者html格式（任选一个）</span></span><br><span class="line">  text: <span class="string">'Hello world！'</span>, <span class="comment">// plain text body</span></span><br><span class="line">  <span class="comment">//html:  fs.createReadStream(path.resolve(__dirname,'index.html'))</span></span><br><span class="line">  html: <span class="string">'&lt;img src="cid:01"&gt;'</span>, </span><br><span class="line">  attachments: [                 <span class="comment">//添加附件（可多个）</span></span><br><span class="line">    &#123;</span><br><span class="line">      filename: <span class="string">"image"</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"2.jpg"</span>),</span><br><span class="line">      cid: <span class="string">"01"</span>,<span class="comment">//与上面的图片cid对应</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      filename: <span class="string">"a.txt"</span>,</span><br><span class="line">      content: <span class="string">"hello world!"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      filename: <span class="string">"b.txt"</span>,</span><br><span class="line">      path: <span class="string">"./text.txt"</span>,<span class="comment">//根目录新建即可</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件</span></span><br><span class="line">transporter.sendMail(mailOptions, (error, info) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(info);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们先来看一下service这个字段，如果写了这个就不用写host和端口。大家可以看一下官方的介绍，<a href="https://nodemailer.com/smtp/well-known/" target="_blank" rel="noopener">详情戳此</a>。它其实已经帮你封装好了，非常方便。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/0a28719d-4ef0-4e4a-93b0-7fc261f14fa7.png" alt="一部分服务"></p>
<h3 id="发送纯文本text"><a href="#发送纯文本text" class="headerlink" title="发送纯文本text"></a>发送纯文本text</h3><p>这个就比较简单了，我们直接在mailOptions 下面的text写上我们要发送的文本即可，其他的html和attachments都不用配置了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/29d5a5b2-140d-4298-917c-c784950ba9a3.png" alt></p>
<h3 id="HTML模板发送"><a href="#HTML模板发送" class="headerlink" title="HTML模板发送"></a>HTML模板发送</h3><p>有同学可能觉得这个text文本太low了，我们应该写一些比较华丽的网页发送。没问题，其实我们还可以自定义html网页的，我们不要使用text字段就好，改用html字段而且我们要进行html文件的引入。</p>
<p>我们在根目录新建index.html文件，用于发送此html文件给对方，这里我就随便拿了一个网页。我们要使用 <code>fs.createReadStream(path.resolve(__dirname,&#39;index.html&#39;))</code>的方式进行引入即可。重新运行我们就会接收到邮件了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/89cc7c40-5152-437a-90b6-8f6bfde5d621.png" alt></p>
<h3 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h3><p>除了网页之外我们还可以使用图片的形式发送，我们在html字段里不要发送html文件，写上<code>html: &#39;&lt;img src=&quot;cid:01&quot;&gt;&#39;</code>之后，我们在attachments里面也写上附件的地址，我这里就直接在根目录之下放置了一张图片，cid要对应上。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/bdb7a4ab-2c86-443e-ad6d-e0365d4e9604.png" alt="本人公众号，在线求关注！"></p>
<h3 id="添加附件"><a href="#添加附件" class="headerlink" title="添加附件"></a>添加附件</h3><p>这里我们就可以添加一些文件了，比如这里我添加了txt文件、docx文件、pdf文件、zip文件都可以。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/0eb958cb-e697-4008-af54-a856e25b736f.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-验证码功能"><a href="#03-验证码功能" class="headerlink" title="03 验证码功能"></a>03 验证码功能</h2><p>我们其实感兴趣只是验证码部分，别急这就安排一下到底是怎么回事。我们首先要想办法生成一个验证码，一般4-6位都是可以的，下面就介绍一种简单的方法来生成一个吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> code = <span class="built_in">Math</span>.random().toString().substr(<span class="number">2</span>, <span class="number">4</span>)<span class="comment">//从第二位开始截取，截取4位（当然也可以6位）</span></span><br></pre></td></tr></table></figure>
<p>我们就直接使用text这个字段进行发送就好了。code可以在一开始生成一下就好。这样其实我们就可以有一个验证的功能了，让用户输入的验证码与你生成对比的是否一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">text: <span class="string">`您的验证码是<span class="subst">$&#123;code&#125;</span>,验证码在10分钟内有效`</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/b9a958b9-303d-4961-94f7-b0c366c7d090.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="04-一些小问题"><a href="#04-一些小问题" class="headerlink" title="04 一些小问题"></a>04 一些小问题</h2><p>我在测试的时候其实有一些小问题，但是我也不知道是什么原因。</p>
<ul>
<li><code>Error: Message failed: 554 DT:SPM 163</code></li>
</ul>
<p>我去163的官网查了一下，得出的结论是:</p>
<p><strong>DT:SPM 发送的邮件内容包含了未被许可的信息，或被系统识别为垃圾邮件。请检查是否有用户发送病毒或者垃圾邮件</strong>。</p>
<p>这是我在发送图片的时候，就是我的二维码图片不行，但是我换一张普通的照片就可以，无解。</p>
<ul>
<li><code>发送给多名用户失败</code></li>
</ul>
<p>当我尝试在to字段那里写两个用户的时候，发现只有一个是成功的，另一个却被退回了，我也不知道是怎么回事。</p>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><p>好了，以上就是本文的全部内容，想想其实好像也没什么东西，之前觉得是非常牛的事情原来可以使用很简单的代码就可以实现了。</p>
<p>其实关于nodemailer还有很多属性没有说到，我只讲关于邮件发送的核心部分，其实这在我们的日常生活中也够用了，特别是做一些登录验证操作的时候有用有效。</p>
<p>文章代码：<a href="https://github.com/wqs2019/nodemailer-demo" target="_blank" rel="noopener">github地址</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/1734793f-87e7-4f71-9d0a-9b955b3a731a.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>




]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Nodemailer</tag>
      </tags>
  </entry>
  <entry>
    <title>闲来无事，扒一下Express框架的知识</title>
    <url>/2020/04/30/express/</url>
    <content><![CDATA[<blockquote>
<p>自从Node.js出现之后，相应的web框架就出现了，而且都是比较容易上手和搭建的，框架中都有一个很重要的概念“中间件”，今天就来扒一下其中的奥妙。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/03fb95a7-8bc3-4d74-9b4f-34d443662d14.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>还记得之前面试的时候，我说用过Node搭建了一个小型的后台框架，然后面试官就问了一下你用过什么常用的中间件吗？</p>
<p>我当时知道中间件就是一个类似插件一样，依次执行的东西。虽然我在项目当中也用到了类似body-parser、express.static()这些，奈何年少无知我不知道这就是中间件。现在想想要是再问我中间件原理就更不懂了。</p>
<p>现在的中间件是挺多的，可以满足我们很多的数据处理与请求，我们今天就来看一下中间件这个神奇的东西到底神在哪？</p>
<h2 id="02-认识Express"><a href="#02-认识Express" class="headerlink" title="02 认识Express"></a>02 认识Express</h2><p>得益于JavaScript的发展，使得Node诞生了，<code>能够在服务器端运行JS代码</code>，这无疑是令人激动的事情，Express其实就是一个<code>Node.js Web程序框架</code>，简单来说就是快速构建一个“后台”。我们用很简单的代码就可以搭建一个服务器，不用费劲心思来使用其他的语言来搭建，而且其他语言在什么也没干的情况下就出现极多的代码。</p>
<p>Node与其他传统的Web服务器的重大区别就是它是<code>单线程</code>的，它可以简化Web程序的编写，如果要实现多线程就启动多个Node实例即可。而且<code>Node是跨平台的，与平台是无关的</code>，我们可以在Windows或者Linux操作系统上都可运行。</p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>我们在使用Express编写应用程序的时候一般都会有固定的代码，有一定的目录结构。这中“常规”的代码就是我们所说的脚手架，让我们更方便地开发。我们随便建一个文件夹来使用Express。</p>
<ul>
<li><code>npm init</code></li>
</ul>
<p>使用这一行命令来<code>初始化一个package.json文件</code>，但是要注意的是package.json的name不能叫express，不然会在下一句命令会报错。</p>
<ul>
<li><code>npm install express --save</code></li>
</ul>
<p>安装express，成功之后你会在项目的根目录看到多了node_modules文件夹，这里就是第三方的应用包，我们的express也会安装在这里。</p>
<p>因为这个文件夹极大，甚至包含了成百上千的包，所以代码提交的时候我们肯定不会带上它的。所以我们在根目录下面就<code>创建一个.gitignore文件</code>，内容就是<code>node_modules</code>，用与忽略这个文件夹。</p>
<ul>
<li><code>新建入口文件 app.js</code></li>
</ul>
<p>在根目录新建一个入口文件，通常叫app.js或者index.js都可以。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.set(<span class="string">"port"</span>, process.env.PORT || <span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 定制 404 页面</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.type(<span class="string">"text/plain"</span>);</span><br><span class="line">  res.status(<span class="number">404</span>);</span><br><span class="line">  res.send(<span class="string">"404 - Not Found"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定制 500 页面</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  res.type(<span class="string">"text/plain"</span>);</span><br><span class="line">  res.status(<span class="number">500</span>);</span><br><span class="line">  res.send(<span class="string">"500 - Server Error"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(app.get(<span class="string">"port"</span>), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">"Express started on http://localhost:"</span> +</span><br><span class="line">      app.get(<span class="string">"port"</span>) +</span><br><span class="line">      <span class="string">"; press Ctrl-C to terminate."</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那其实这样你就创建了小型的服务器了，接下来就直接启动一下，node app.js就会发现它已经是监听了3000端口。但是我们发现他是没有东西的，因为我们没有配置路由，默认就是返回错误页404。</p>
<p>我们尝试配置一个的路由，主要要在404路由之前，不然也会出现404。</p>
<p>上面我们看到了404和500使用的是app.use而不是路由的形式，这是一种中间件的写法，我们可以理解为没有路由匹配的时候走的方向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.type(<span class="string">"text/plain"</span>);</span><br><span class="line">  res.send(<span class="string">"这是首页"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.type(<span class="string">"text/plain"</span>);</span><br><span class="line">  res.send(<span class="string">"这是关于页"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="静态文件引入"><a href="#静态文件引入" class="headerlink" title="静态文件引入"></a>静态文件引入</h3><p>我们开发中难免会有一些图片等资源的引入，express给我们提供了一种便于资源引入的方法，我们直接在app.js文件的路由开始之前就加入这一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));<span class="comment">//需要加入的代码</span></span><br></pre></td></tr></table></figure>

<p>意思就是这里的资源可以不经任何处理就直接发送给客户端，可以放置图片、CSS文件等。</p>
<h3 id="动态渲染模板"><a href="#动态渲染模板" class="headerlink" title="动态渲染模板"></a>动态渲染模板</h3><p>我们可以加载静态资源文件，但是我们要使用html模板进行内容的渲染就要加入模板引擎了，但是这种模板引擎的我用的比较少，我一般都会结合vue进行渲染的。但是今天我们就来探讨一下不用vue要怎么渲染出来。</p>
<p>首先我们要安装一下模板殷勤express-handlebars：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express-handlebars</span><br></pre></td></tr></table></figure>

<p>我们现在跟目录之下建立一个views文件夹，然后再建立一个index.html文件用于渲染。</p>
<p><code>index.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/express.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 100px;"</span>&gt;</span></span><br><span class="line">    &#123;&#123;#each list&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>昵称:&#123;&#123;this.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄:&#123;&#123;this.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>app.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">const</span> exphbs = <span class="built_in">require</span>(<span class="string">"express-handlebars"</span>);<span class="comment">//引入模板</span></span><br><span class="line">app.engine(<span class="comment">//设置模板</span></span><br><span class="line">  <span class="string">"html"</span>,</span><br><span class="line">  exphbs(&#123;</span><br><span class="line">    layoutsDir: <span class="string">"views"</span>,</span><br><span class="line">    defaultLayout: <span class="string">"layout"</span>,</span><br><span class="line">    extname: <span class="string">".html"</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后我们修改一下之前的请求根路径的路由，修改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">"index"</span>, &#123;</span><br><span class="line">    layout: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">"首页"</span>,</span><br><span class="line">    list: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"张三"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"李四"</span>,</span><br><span class="line">        age: <span class="number">15</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/d4e3418b-2d39-45c4-a4a1-a0d890d9fbf2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>以上改好之后重启运行，打开<code>localhost:3000</code>你就可以看到你的页面渲染出来了。如果你的网站是比较小型的，一般使用这样的轻量级框架就可以完成了，但是模板语法自己也要了解一下。</p>
<h2 id="03-中间件解析"><a href="#03-中间件解析" class="headerlink" title="03 中间件解析"></a>03 中间件解析</h2><p>其实中间件很好理解，想象一下有一个长的管道，中间可以加入很多东西，这些东西就是我们所说的中间件。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/edc42400-8017-479b-9d30-0960be15e4ea.png" alt></p>
<h3 id="中间件类型"><a href="#中间件类型" class="headerlink" title="中间件类型"></a>中间件类型</h3><p>express的中间件可以分成几种：</p>
<ul>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件</li>
</ul>
<p><strong>应用级中间件</strong></p>
<p>我们使用的<code>app.use(&#39;/&#39;,(req,res)={})</code>这种就是，直接挂载到app下面的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这个中间件是所有都执行的，没有挂载到具体的路径</span></span><br><span class="line">    next(); <span class="comment">// 控制权下一个中间件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.type(<span class="string">"text/plain"</span>);</span><br><span class="line">    res.send(<span class="string">"这是关于页"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>路由级中间件</strong></p>
<p>路由级中间件和上面应用级中间件类似，但是它绑定对象不是app而是为express.Router()对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/getValue'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  api.getValue(req, res, next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/setValue'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  api.setValue(req, res, next);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>错误处理中间件</strong></p>
<p>错误处理中间件有四个参数,定义错误处理中间件必须使用这四个参数。即使不需要next对象，也必须在参数中声明它，否者中间件会识别为一个常规中间件，不能处理错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定制 500 页面</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  res.type(<span class="string">"text/plain"</span>);</span><br><span class="line">  res.status(<span class="number">500</span>);</span><br><span class="line">  res.send(<span class="string">"500 - Server Error"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>内置中间件</strong></p>
<p>express.static是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/16272cdc-ef92-4bf9-b757-dec27a4744db.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  dotfiles: <span class="string">'ignore'</span>,</span><br><span class="line">  etag: <span class="literal">false</span>,</span><br><span class="line">  extensions: [<span class="string">'htm'</span>, <span class="string">'html'</span>],</span><br><span class="line">  index: <span class="literal">false</span>,</span><br><span class="line">  maxAge: <span class="string">'1d'</span>,</span><br><span class="line">  redirect: <span class="literal">false</span>,</span><br><span class="line">  setHeaders: <span class="function"><span class="keyword">function</span> (<span class="params">res, path, stat</span>) </span>&#123;</span><br><span class="line">    res.set(<span class="string">'x-timestamp'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>, options));</span><br></pre></td></tr></table></figure>

<p><strong>第三方中间件</strong></p>
<p>这个其实有很多，我们使用的body-parser这种就是属于第三方的中间件。这里常用的有：</p>
<ul>
<li>body-parser:用于处理body数据</li>
<li>cookie-session：处理session数据</li>
<li>cookie-parser：用来操作cookie</li>
</ul>
<p>其实我们很多的功能都可以通过第三方的中间件来完成，前端真的不简单，有很多大佬在为了前段的发展尽心尽力，我只会CV。</p>
<h3 id="中间件实现原理"><a href="#中间件实现原理" class="headerlink" title="中间件实现原理"></a>中间件实现原理</h3><p>好了，说了这么多，我们就来分析一些这个中间件是怎么实现的，如何才可以使得管道平稳运行。我们可以发现中间件都是有执行顺序的，前后的执行结果是不一样的。有点类似我们队列的样子。</p>
<p>接下来就参照这种思想来实现一下这中间件的核心代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">express</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = []; <span class="comment">// 待执行的函数数组</span></span><br><span class="line">    <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> task = funcs[i++];  <span class="comment">// 取出函数数组里的下一个函数</span></span><br><span class="line">            <span class="keyword">if</span> (!task) &#123;    <span class="comment">// 如果函数不存在,return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task(req, res, next);   <span class="comment">// 否则,执行下一个函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">    app.use = <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</span><br><span class="line">        funcs.push(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> app;    <span class="comment">// 返回实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是核心代码了，精髓都在这里，接下来我们就写一些自己的中间件，来测试一下是否可行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareA</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'中间件1开始...'</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'中间件1结束...'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareB</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'中间件2开始...'</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'中间件2结束...'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareC</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'中间件3开始...'</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'中间件3结束...'</span>);</span><br><span class="line">&#125;</span><br><span class="line">app.use(middlewareA);</span><br><span class="line">app.use(middlewareB);</span><br><span class="line">app.use(middlewareC);</span><br><span class="line">http.createServer(app).listen(<span class="string">'3000'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listening 3000....'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行这一段js代码的时候，控制台就出现了中间件的执行过程。它有一种类似于先进后出的“栈结构”。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/ac8a68b1-3640-4e0a-949b-5f72c5ddec51.png" alt></p>
<h2 id="04、小结"><a href="#04、小结" class="headerlink" title="04、小结"></a>04、小结</h2><p>以上就是本文的所有内容了，主要介绍了Web框架Express的使用方法，以及使用模板引擎进行数据渲染的具体操作。我们还重点了解了Express的中间件实现原理与过程，了解其中的思想。大家也可以去了解一下常见的中间件，试着去使用它们，你会发现开发竟是如此简单。</p>
<p>我们也知道除了Express框架之外还有Koa框架，它也是由Express的原班人员打造出来的，我认为只要是用的舒服就好，没有必要说哪个好哪个不好。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/6ff2a087-632b-4c13-9063-e1873472c1e5.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>参考文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/okaychen/p/8057204.html#_label1" target="_blank" rel="noopener">Express中间件，看这篇文章就够了(#^.^#)</a></li>
<li><a href="https://item.jd.com/11644104.html" target="_blank" rel="noopener">Node与Express开发</a></li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Express</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发的一些细节，你有注意吗？</title>
    <url>/2020/04/27/miniappDetails/</url>
    <content><![CDATA[<blockquote>
<p>最近的弄的小程序差不多有点东西了，就来写一些关于小程序的感悟吧</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/03fb95a7-8bc3-4d74-9b4f-34d443662d14.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>一般来说，我认为小程序是一个没有什么技术含量的东西，特别是现在有了组件库，而且小程序生态不断完善的情况下，只要对着文档慢慢写就好，就是时间的问题。然后这里也不是教大家怎么去写程序之类的，而是本人在经历过后的一些小建议。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/c50c008a-c38f-4033-be1f-5a0a2e7cda0e.png" alt></p>
<h2 id="02-技术选型"><a href="#02-技术选型" class="headerlink" title="02 技术选型"></a>02 技术选型</h2><p>其实我觉得技术选型是非常重要的，直接关系到你后来的工作复杂度。怎么说呢？因为小程序的开发就是一个注重业务逻辑的过程，它与算法研究类的研发工作不同。小程序的质量高不高，用户体验好不好完全取决于你的页面设计，页面的交互。</p>
<p>所以我觉得在选型的过程中有几个特别值得注意的：</p>
<ul>
<li>组件库支持</li>
<li>框架生态</li>
<li>框架语法</li>
</ul>
<p>基本上就是这些，首先来说一下第一个关于组件库的支持。</p>
<h3 id="组件库支持"><a href="#组件库支持" class="headerlink" title="组件库支持"></a>组件库支持</h3><p>现在的<code>组件库</code>特别多，基本上是可以满足我们日常开发的需要，之前我写了一篇关于《<a href="https://juejin.im/post/5e9f02ff6fb9a03c95800c8d" target="_blank" rel="noopener">前端人应该掌握的工具</a>》里面有写到，大家感兴趣的可以去看一下。</p>
<p>可以说组件就是整个程序的重要部分，因为假如你<code>自己写的话肯定会花费大量的时间</code>，即使你已经写出来了可能也就是自己能用，兼容性也会有问题。所以关于组件的开发就<code>不推荐自己造轮子</code>了，我们还没有这样的时间和精力。</p>
<p>但是我们也不能随便去选择一个组件库，我们必须要<code>根据小程序的页面设计</code>，详细列出里面所有的元素到底是采用何种方法/组件实现的，你<code>选择的组件库是否所有都满足</code>。还有一个重要的是，组件库的<code>社区反馈</code>如何，有没有很多不可避免的BUG在里面。</p>
<p>这一点自己也深有体会，因为组件的兼容性问题，自己往往会花费几天时间来做<code>兼容和适配</code>。现在我是选择了<code>mpvue+vant</code>的形式来写的。设计图上面的navbar是自定义而且是固定顶部的，一开始也没有怎么注意，觉得没有问题。但是，在我切换不同的机型的时候问题就出来了，各种对不齐的情况接踵而来，特别是苹果系列的机型（刘海屏）。</p>
<p>起初我想过自己去适配一下，但是发现头发一直掉，应该在提醒我不能这么搞了。后面就在github找到了一个可以适配的navbar组件，解决了我的问题。也从侧面说明不能自己造轮子。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/7f90f565-435f-4c69-a228-80257ac51e21.png" alt></p>
<h3 id="框架生态"><a href="#框架生态" class="headerlink" title="框架生态"></a>框架生态</h3><p>因为最终还是要编译成官方的小程序格式，难免会有一些问题。所以我们选择一个小程序框架的时候也要考虑到这个问题，看<code>它与官方的区别</code>在哪，有哪一些是不支持的，看一下<code>社区对它的评价如何</code>。</p>
<p>基本上我们<code>选择一些用户反馈比较积极</code>的就好，<code>不要选一些新兴的框架</code>，因为往往也是坑比较多，而且你有时候发邮件问他们几个世纪都不回你的。如何选择一个比较好的框架呢？可以看文章的最后github仓库，里面有很多关于小程序的资料，也有一些框架的排名和组件库选择。</p>
<h3 id="框架语法"><a href="#框架语法" class="headerlink" title="框架语法"></a>框架语法</h3><p>语法部分还不是最主要的，因为<code>前端的语法</code>都一样，那我说这个的目的其实是说小程序的开发语法与官方的语法有<code>哪些不兼容</code>的，要注意一下，一般文档都会给出来的。</p>
<p>目前小程序的开发都可以使用vue语法来编写，可以说是非常方便了，但是如果你不熟悉<code>小程序的生命周期</code>与<code>vue的生命周期就</code>可能会有一些问题。我遇到的问题就是怎么合理使用生命周期函数。有时候你的程序可能会报一些奇怪的错误，<code>比如提示图片加载失败，然后图片又显示正常</code>。其实这就是页面渲染的时候还没有识别到图片的原因，是后面加载的，这就是先后的问题。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/4f335a2e-aea6-494d-967e-d15aff1b39fb.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-开发步骤"><a href="#03-开发步骤" class="headerlink" title="03 开发步骤"></a>03 开发步骤</h2><p>前期就是一些架构设计以及技术选型的内容，前期的选择尤为重要，技术选型好，后面你会节省很多时间和工作量。</p>
<h3 id="代码结构设计"><a href="#代码结构设计" class="headerlink" title="代码结构设计"></a>代码结构设计</h3><p>开发步骤也要设计，你要规划一些目录结构，比如存放<code>组件的</code>、<code>图片的</code>、<code>工具类函数的</code>、<code>页面类</code>的等。虽然说我们的初始化项目都会有相应的目前结构，但是你也要在它的基础上进行稍微的改造。让我们的目前更加清晰。</p>
<p>一般来说我们就从我提到的<code>组件</code>、<code>图片</code>、<code>工具</code>、<code>页面</code>几个步骤出发。页面部分我们基本上不用怎么改，因为项目初始化都帮你设计好了。组件部分我们就新建一个组件文件夹，用于存放我们的自定义组件，方便后期的复用。值得注意的是，我们一定要<code>写好组件</code>，让我们的<code>复用效率更高</code>，可以通过<code>传参的形式来控制组件的形态</code>。</p>
<p>关于图片的存储我的建议就是可以<code>从功能上来划分</code>，比如tabbar的图片，navbar的图片，其他的图片也是按照自己的功能来进行划分，这样就显得<code>逻辑结构清晰</code>，后续的<code>维护</code>更加方便容易。</p>
<h3 id="项目的配置"><a href="#项目的配置" class="headerlink" title="项目的配置"></a>项目的配置</h3><p>这一方面的话看你的<code>具体业务需求</code>怎么样，一般来说我们经常都会调用<code>第三方库函数/接口</code>，如定位等。现在我做的这一个就用到了腾讯地图的第三方接口，这里就不再详细展开。</p>
<p>我做的时候会出现域名不合法的情况，你需要在<code>小程序后台进行域名的配置</code>，报错信息都告诉你怎么配置了，把那个域名加上去就好。又或者你的后台请求接口有错误的话一般就是你的接口<code>域名不是https协议</code>，这就有点麻烦了，调试阶段可以在开发者工具的右上角详情部分，<code>勾上不检验</code>就好。</p>
<p>但是如果你要上线的话就需要有https的服务器放置你的接口了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/7b8e9147-9ee2-4f1b-b473-155285245f80.png" alt></p>
<h2 id="04、小结"><a href="#04、小结" class="headerlink" title="04、小结"></a>04、小结</h2><p>好了，以上就是就本次项目的相关总结，但是项目本身还是没有完善的，我也是在早期的设计上面下了一些功夫，主要还是让自己在后面的开发过程中少一些BUG和错误，方便自己后期的维护。</p>
<p>其实业务类的小程序更要主要组件的开发和设计，因为很多页面都会公用一个组件，假如你是复制粘贴那也未尝不可，只是维护比较难而已。我们做每一个产品，在必不得已的情况下才会使用一些技巧性的东西，一般来说都会做成一个可伸缩、可维护的产品，也是对自己的要求。</p>
<p>小程序仓库：<a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">https://github.com/justjavac/awesome-wechat-weapp</a></p>
<p><img src="https://imgkr.cn-bj.ufileos.com/6ff2a087-632b-4c13-9063-e1873472c1e5.gif" alt></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>前端人应该知道的网站和工具</title>
    <url>/2020/04/21/recomandWebsite/</url>
    <content><![CDATA[<blockquote>
<p>很早就想写一篇文章关于前端人的工具库了，因为我发现其实有了工具，才是成为工具人的基础。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/21/recomandWebsite/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>最近有很多初学者在后台留言说：“我是一个小白，怎么才可以快速入门前端呀？”。关于这个问题其实不太好回答，因为这个问题就好像说我是一个穷光蛋如何快速致富一样的道理。但是也不是没有办法回答你这个问题，毕竟掌握一门知识点还是有它的路径的，不能说路径一样，但起码可以参考。</p>
<p>接下来我就以一个初学者走过但已不是初学者的角度来给大家介绍前端人的工具库到底有哪些，如何快速帮你梳理知识点，快速入门（精通靠自己）。</p>
<h2 id="02-基础入门"><a href="#02-基础入门" class="headerlink" title="02 基础入门"></a>02 基础入门</h2><p>说了基础入门，其实真的是很基础的，我一开始也是这样过来的。无非就是从最简单的html/css开始搞起来，那时候什么都要自己敲，哪有现在组件库这么方便呀！只能说现在的大家太幸福了，所谓前人种树，后人乘凉。但是自己也别忘记树是怎么种的就好。</p>
<ul>
<li><a href="https://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程</a> </li>
</ul>
<p>大家应该都知道这个网站，简直就是<code>初学者的福音</code>，里面什么都有，但是都很基础。大家可千万不要以为基础就不用心去学，就好像大学学的科目，带有基础二字的书本往往是最难的。可以说前端的小伙伴要是把上面关于前端的过一遍，你就入门了。时间就大概一两周就可以了，而且也是没有什么难度的，假如你是科班出身那就更容易入门了。</p>
<ul>
<li><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></li>
</ul>
<p>这个其实和菜鸟教程差不多，也是基础的标签等知识点，我觉得看菜鸟教程就好了，大家也可以了解一下。</p>
<ul>
<li><a href="https://www.imooc.com/" target="_blank" rel="noopener">慕课网</a></li>
</ul>
<p>这个真的就是我的<code>启蒙网站</code>，虽然现在已经不常用了，但是一直都在我的收藏夹第一名。不为什么就是为了一种情怀。这个网站还是我没有上大学之前一位师兄推荐的，那时候主要是学习c++的课程，后来就跑去学前端了（因为简单）</p>
<p>上面很多都是收费的课程，但是也有不错的免费课，不想看书或者教程的同学可以选择去看慕课网。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></li>
</ul>
<p>这个也是比较基础的文档，内容的话比前两个稍有深度，知识讲解也是比较到位的，平时查阅的时候可以作为自己的文档，网站的布局我觉得是不错的，知识分类页非常有条理。</p>
<h2 id="03-进阶锻炼"><a href="#03-进阶锻炼" class="headerlink" title="03 进阶锻炼"></a>03 进阶锻炼</h2><p>当你基础入门之后呢，你就应该搞一些比较好玩的技术来玩一下，比如vue和react这个前端比较火的技术，可以说是<code>前端必学的技术</code>，因为没有掌握或者会用它们，你基本上找不到工作。</p>
<ul>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue.js</a></li>
</ul>
<p>这是一个<code>非常容易上手</code>的前端框架，前提是你已经经过了基础入门的锻炼。而且它的周边以及生态都非常完善，也有很多支持的组件库，后边会介绍。所以<code>强烈推荐</code>大家去学习这个框架，能够做一写简单的效果之类的，找到前端的乐趣。</p>
<ul>
<li><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">Vue CLI</a></li>
</ul>
<p>还有介绍一下Vue的脚手架工具，能够让你快速生成一个Hello World项目，然后进行<code>快速的开发</code>，专注于业务。平时用的也是比较多的。</p>
<ul>
<li><a href="https://react.docschina.org/" target="_blank" rel="noopener">React</a></li>
</ul>
<p>因为我对react的技术栈不是很熟悉，我只停留在文档上面，但是也做过简单的demo，知道引用组件、业务拆分等的思想，个人觉得其实和vue都是差不多的，也是组件化的思想，大家也要去学习一下。</p>
<blockquote>
<p>因为我没有接触过Angular，所以我就不多说这个，但是不排除也有公司使用angular技术，大家有时间也要多去了解一下吧。<a href="https://angular.cn/" target="_blank" rel="noopener">我要了解</a></p>
</blockquote>
<h2 id="04-精美组件库"><a href="#04-精美组件库" class="headerlink" title="04 精美组件库"></a>04 精美组件库</h2><p>好啦，到了我最想介绍的一部分了，其实这个也是更方便我们前端的日常业务需要。说白了就是解放了我们前端的开发，不用写复杂的css或者html，<code>开箱即用</code>。在这里也非常感谢前端社区做出的巨大贡献。</p>
<ul>
<li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">Element-ui</a></li>
</ul>
<p>本人非常喜欢这个组件库,因为里面的一些功能都基本上能够满足我的开发需要,而且也是非常容易上手操作,直接CDN引入或者npm安装，任君选择。最重要的是能够配合Vue.js进行项目开发。</p>
<ul>
<li><a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a></li>
</ul>
<p>这是由蚂蚁金服出品的前端组件库，也是非常好用的，说再多还不如大家自己去体验一下，它也是支持前端框架使用，而且现在4.0版本也已经发布了。</p>
<ul>
<li><a href="https://www.bootcss.com/" target="_blank" rel="noopener">Bootstrap</a></li>
</ul>
<p>这是我最早使用的前端组件库，那时候我发现的时候觉得世界一下子开阔了许多，因为我从基础入门之后就接触这个了，是一位前端的小姐姐推荐的。虽然现在基本上已经不用了，但是还是那句话，情怀所在，也推荐一下。</p>
<ul>
<li><a href="https://ice.work/" target="_blank" rel="noopener">飞冰</a></li>
</ul>
<p>好像这个UI组件库也是挺多人推荐的，是阿里开发的前端组件库，我没有用过，大家可以去看看。</p>
<ul>
<li><a href="https://didi.github.io/cube-ui/#/zh-CN" target="_blank" rel="noopener">Cube UI</a></li>
</ul>
<p>这是一个由滴滴公司开发的前端组件库，也是支持Vue.js语法的，本人也没有使用过，大家也可以了解一下。</p>
<h2 id="05-小程序开发"><a href="#05-小程序开发" class="headerlink" title="05 小程序开发"></a>05 小程序开发</h2><p>最近也是做小程序开发相关的工作，其实小程序开发现在已经方便很多了，因为有了很多小程序框架，接下来就介绍一下。</p>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">官方开发</a></li>
</ul>
<p>这个就不用过多介绍了，毕竟是老大哥，而且官方也有原生支持的<a href="https://developers.weixin.qq.com/miniprogram/dev/extended/weui/" target="_blank" rel="noopener">WeUI组件库</a>，也是非常方便的。</p>
<ul>
<li><a href="https://uniapp.dcloud.io/" target="_blank" rel="noopener">uni-app</a></li>
</ul>
<p>这是近几年来发展比较好的小程序框架，不仅可以开发小程序，实现多端的开发，还可以编译成APP，想想都让人心动。更重要的是它也支持vue语法，简直不能太爽。</p>
<ul>
<li><a href="https://ext.dcloud.net.cn/" target="_blank" rel="noopener">uni-app插件市场</a></li>
</ul>
<p>说起uni-app不得不提一下它的插件市场，就像我们平时菜市场买菜一样方便，直接拿过来就用，而且还免费。但是也要看清楚是否有一些兼容性问题等。大家下载插件有问题不要喷，因为大家都是为了社区贡献，我们更应该鼓励作者。</p>
<ul>
<li><a href="https://www.uviewui.com/" target="_blank" rel="noopener">uView</a></li>
</ul>
<p>这是一个掘金小伙伴的评论，我才发现了这个网站，看了一下觉得非常不错，它的官网介绍称这是uniapp生态最优秀的UI框架，全面的组件和便捷的工具会让您信手拈来，如鱼得水。我现在还没开始使用，大家可以去试一下，应该是不错的。</p>
<ul>
<li><a href="https://taro.jd.com/" target="_blank" rel="noopener">Taro</a></li>
</ul>
<p>这是一个由京东开发的小程序框架，它的介绍是<code>一处代码，多出运行</code>，我在很久之前就使用过一次，忘了什么感觉。大家也可以去官网了解一下，说不定不也会爱上这个框架呢！</p>
<ul>
<li><a href="http://mpvue.com/" target="_blank" rel="noopener">mpvue</a></li>
</ul>
<p>这是一个由美团开发的一个小程序框架，也是支持vue.js的语法，而且它也支持小程序的生命周期，也就是说vue的生命周期和小程序的都适用。</p>
<p>说了这么多，给大家推荐一下我觉得非常不错的小程序资料汇总，每次开发小程序都会看一下到底用什么好，别人总结的非常好！<a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">微信小程序开发资源汇总</a></p>
<ul>
<li><a href="https://youzan.github.io/vant-weapp/#/intro" target="_blank" rel="noopener">vant-weapp</a></li>
</ul>
<p>最近使用mpvue开发小程序也是使用了这个组件库进行开发，不得不说这是一个非常好的组件库，里面的组件很丰富，能够满足我们的业务开发需要。</p>
<ul>
<li><a href="https://www.iviewui.com/" target="_blank" rel="noopener">View UI</a></li>
</ul>
<p>这也是一套基于Vue.js的高质量UI组件库。不得不说现在的组件库实在太丰富，简直是我们前端人的福音呀，现在前端也是越来越注重开发体验的职务，有了组件让用户体验瞬间变得极为友好。</p>
<blockquote>
<p>好了，就介绍这么多吧，大家也不一定每个都用的上，后面如果有其他的好用的就再更新！</p>
</blockquote>
<h2 id="06-好用工具"><a href="#06-好用工具" class="headerlink" title="06 好用工具"></a>06 好用工具</h2><p>说到工具，这里就介绍一下前端人必用的前端工具，大家一定要好好收藏起来。</p>
<ul>
<li><a href="https://www.postman.com/" target="_blank" rel="noopener">postman</a></li>
</ul>
<p>这是一款接口调试工具，因为前后端经常有进行<code>交互</code>的操作，使用这个工具可以非常方便地调试，也知道问题出在哪里，它支持多种请求方法进行调试，也可以进行传值等各种操作。</p>
<ul>
<li><a href="https://download-chromium.appspot.com/" target="_blank" rel="noopener">谷歌浏览器</a></li>
</ul>
<p>谷歌浏览器在市场上的占有率是非常高的，因为它不仅有良好的浏览体验，更重要的是它有很不错的调试功能，我这里介绍的是<code>chromium</code>浏览器，都是一样的，点击就可以下载了。</p>
<ul>
<li><a href="https://convertingcolors.com/" target="_blank" rel="noopener">颜色转换</a></li>
</ul>
<p>这是一款颜色转换的工具，非常方便你的颜色取值。之前我都是一直使用这一款，但是最近我发现QQ的截图功能也可以吸取颜色，直接ctrl+c就可以获取16进制的颜色了，简直不要太爽。</p>
<ul>
<li><a href="https://www.navicat.com.cn/products/navicat-premium" target="_blank" rel="noopener">navicat</a></li>
</ul>
<p>navicat是一款数据库管理的软件，可以方便查看数据库中的各种表数据等等，但是这是一个收费的软件，大家看情况需要吧。或者你可以找一些方法来使用，大家知道就好。</p>
<ul>
<li><a href="https://www.webpagetest.org/" target="_blank" rel="noopener">WEBPAGETEST</a></li>
</ul>
<p>这是一个网站的测试工具，可以看到你请求一个网站的时间都花在哪个细节上面了，可以用来优化你的网站。不过我也不常用，只是偶然发现而已。</p>
<h2 id="07-讨论社区"><a href="#07-讨论社区" class="headerlink" title="07 讨论社区"></a>07 讨论社区</h2><ul>
<li><a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a></li>
</ul>
<p>首先推荐的就是掘金了，我觉得这里的文章质量都很高，大家的活跃度也非常不错，很喜欢这个社区。大家也可以看一下掘金小册，也很不错。</p>
<ul>
<li><a href="https://segmentfault.com/" target="_blank" rel="noopener">思否</a></li>
</ul>
<p>思否也是一个不错的讨论社区，我也有很多的困难都在上面找到解决方法。</p>
<ul>
<li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a></li>
</ul>
<p>这个就比较厉害了，上面有全世界的开发者，也是一个活跃的讨论社区，有着众多的牛人帮你解答问题。但是唯一的缺点就是需要你的英文水平比较高，但是你也可以右键，翻译完事。</p>
<ul>
<li><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a></li>
</ul>
<p>牛客网在我找工作的这段时间给我的帮助不少，特别是内推方面，上面也有很多公司会发布一些内推的信息，也有很多学长学姐给你推荐，大家一定要收藏这个网站。</p>
<p>另外还有一些像<a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a>、<a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a>、<a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>这种就比较大众化了，内容质量个人觉得还可以。不过大家也可以去逛一下，你也可以找到不错的解决方案。</p>
<h2 id="08-个人优秀博客"><a href="#08-个人优秀博客" class="headerlink" title="08 个人优秀博客"></a>08 个人优秀博客</h2><p>优秀博客其实也有很多个，这里我就推荐几个我认为是比较好的。</p>
<ul>
<li><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a></li>
</ul>
<p>阮老师的博客也是让我受益匪浅，从中也学到很多有用的知识点和人生道理，上面也记载着阮老师的日志心得等，非常值得大家去看看。</p>
<ul>
<li><a href="https://jspang.com/" target="_blank" rel="noopener">技术胖</a></li>
</ul>
<p>业界良心的博主，发布了很多的免费视频，我看了react那一套觉得讲的非常清楚，肯定帮助很多人入门前端。</p>
<ul>
<li><a href="http://blog.alanwu.site/" target="_blank" rel="noopener">我的博客</a></li>
</ul>
<p>最后不要脸地推荐一下自己的博客，虽然自己才刚开始起步，但是写博客也是对自己的一个成长记录，也是对自己的一份鞭策吧。我也很希望和大家一起在前端这个圈子里共同进步，也希望大家可以提出建议。我也开通了自己的公众号《<code>前端小时</code>》，也是对自己的成长记录，希望大家关注支持一下哈哈。</p>
<p>博客也不是自己纯手工搭建的，也是使用了开源博客系统HEXO进行搭建的。</p>
<h2 id="09-其他好用网站"><a href="#09-其他好用网站" class="headerlink" title="09 其他好用网站"></a>09 其他好用网站</h2><ul>
<li><a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a></li>
</ul>
<p>这个一个CDN的网站，可以轻松引入各种CDN，包括vue.js、Element-ui这些。</p>
<ul>
<li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">字体图标</a></li>
</ul>
<p>每次开发使用的图标我都会在上面查找一下，基本上都可以找到自己想要的图标，也可以轻松下载你想要的尺。</p>
<ul>
<li><a href="http://www.fonts.net.cn/" target="_blank" rel="noopener">字体类型</a></li>
</ul>
<p>用过一次，上面有各种类型的字体可供大家下载，直接引入就可以使用了。不是很常用，除非一些很特殊的情况下才用。</p>
<ul>
<li><a href="https://flutterchina.club/" target="_blank" rel="noopener">Flutter</a></li>
</ul>
<p>一个很火的移动端开发框架，可以跨平台进行开发，也就是说安卓和IOS都可以使用同一套代码进行编译。我用过一次，觉得非常不错，而且入门也是比较简单的，基本上都是和前端差不多，但是需要上手时间。</p>
<ul>
<li><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">轮播图</a></li>
</ul>
<p>一个轮播图的功能，上面提供了各种轮播图的样式以及功能等等，而且也可以在vue.js中配合使用，但是用的也不多，因为组件库中也有类似的功能。</p>
<h2 id="10-小结"><a href="#10-小结" class="headerlink" title="10 小结"></a>10 小结</h2><p>好了，今天的文章就分享到这里，本人收藏用的网站和工具都推荐给大家了，资料整理不易，希望大家能够点赞关注一下，大家如果有好用的工具都可以在文章下方进行留言，我会更新到文章上面。</p>
<p>希望大家能够好好利用这些网站，提高自己的业务能力，觉得文章不错也可以关注一下我的公众号！文章都同步发送！感谢大家！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/21/recomandWebsite/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>工具推荐</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端网站</tag>
        <tag>工具推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决安卓/IOS获取蓝牙ID不一致问题</title>
    <url>/2020/04/20/BLE/</url>
    <content><![CDATA[<blockquote>
<p>不知道大家对低能蓝牙的技术应用了解的怎么样，其实这是一个比较广的应用，比如可以应用于一些信标、家庭娱乐或者医疗方面都有应用。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/20/BLE/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>因为小程序官方是支持接入低能蓝牙（BLE）的，所以在一个项目中也尝试使用如何接入蓝牙，我们从微信的官方网站就可以清楚知道如何使用，但是其中也是有很多坑的。本着学习的心态，自己也手把手带你摸坑，一起处理一些<code>平台兼容性的问题</code>以及一些<code>逻辑判断</code>问题。</p>
<h2 id="02-问题抛出"><a href="#02-问题抛出" class="headerlink" title="02 问题抛出"></a>02 问题抛出</h2><p>因为蓝牙在IOS客户端<code>6.5.6</code>版本开始支持，安卓<code>6.5.7</code>开始支持，所以一开始我们就应该判断版本问题，以免后面的功能不能使用。</p>
<p>我们从文档上面看到这样一段话：</p>
<blockquote>
<p>由于系统限制，Android 上获取到的 deviceId 为设备 MAC 地址，iOS 上则为设备 uuid。因此 deviceId 不能硬编码到代码中。</p>
</blockquote>
<p>看到这里我就想着，完犊子了，因为我们的手机平台有安卓和苹果，唯一标识蓝牙的就是deviceId，但是苹果搜索出来就不是这个了，而是uuid的一串字符串。因为苹果官方认为透露deviceId（MAC地址）会有安全问题，索性直接屏蔽了。</p>
<h2 id="03-使用方法"><a href="#03-使用方法" class="headerlink" title="03 使用方法"></a>03 使用方法</h2><p>为了保证本文的完整性，我就大概介绍一下怎么使用在小程序接入低能蓝牙，大家也可以去官网看一下。</p>
<ul>
<li>初始化蓝牙模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">openBluetoothAdapter() &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (wx.openBluetoothAdapter) &#123;</span><br><span class="line">      wx.openBluetoothAdapter(&#123;</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title: <span class="string">"正在获取蓝牙列表"</span>,</span><br><span class="line">            icon: <span class="string">"loading"</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">          that.getBluetoothAdapterState();</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          wx.showModal(&#123;</span><br><span class="line">            title: <span class="string">"提示"</span>,</span><br><span class="line">            content: <span class="string">"请先打开蓝牙"</span>,</span><br><span class="line">            showCancel: <span class="literal">false</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">          that.stopBluetoothDevicesDiscovery();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>获取本机蓝牙适配器状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line"> wx.getBluetoothAdapterState(&#123;</span><br><span class="line">   success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">     that.startBluetoothDevicesDiscovery();</span><br><span class="line">   &#125;,</span><br><span class="line">   fail(err) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(err);</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>开始搜寻附近的蓝牙外围设备</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">startBluetoothDevicesDiscovery() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"获取蓝牙设备列表"</span>);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    that.data.devices = [];</span><br><span class="line">    wx.startBluetoothDevicesDiscovery(&#123;</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        that.getBluetoothDevices();</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>获取在蓝牙模块生效期间所有已发现的蓝牙设备</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getBluetoothDevices() &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    wx.getBluetoothDevices(&#123;</span><br><span class="line">      services: [],</span><br><span class="line">      allowDuplicatesKey: <span class="literal">false</span>,</span><br><span class="line">      interval: <span class="number">0</span>,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        wx.hideToast();</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res, <span class="string">"获取蓝牙设备列表失败====="</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>经过上面的一通操作之后我们就可以获取到蓝牙列表了，你可以查看你的低能蓝牙是否可以获取到。看到这里你就可以发现<code>安卓与苹果的搜索结果是不一样</code>的。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/fb4308d5-de80-48b7-ba7f-cd3399ff1953.png" alt="苹果获取的蓝牙"></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/01c1c9be-3a26-4bcd-8200-ac2423f9c575.png" alt="安卓获取的蓝牙" title>
                </div>
                <div class="image-caption">安卓获取的蓝牙</div>
            </figure>


<h2 id="04-解决途径"><a href="#04-解决途径" class="headerlink" title="04 解决途径"></a>04 解决途径</h2><p><strong>版本问题</strong></p>
<p>首先就是版本的问题，我们要判断写一个版本的判断函数用来判别用户的版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">versionCompare</span>(<span class="params">ver1, ver2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> version1pre = <span class="built_in">parseFloat</span>(ver1)</span><br><span class="line">    <span class="keyword">var</span> version2pre = <span class="built_in">parseFloat</span>(ver2)</span><br><span class="line">    <span class="keyword">var</span> version1next = <span class="built_in">parseInt</span>(ver1.replace(version1pre + <span class="string">"."</span>, <span class="string">""</span>))</span><br><span class="line">    <span class="keyword">var</span> version2next = <span class="built_in">parseInt</span>(ver2.replace(version2pre + <span class="string">"."</span>, <span class="string">""</span>))</span><br><span class="line">    <span class="keyword">if</span> (version1pre &gt; version2pre)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (version1pre &lt; version2pre)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (version1next &gt; version2next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用微信的官方接口来获取手机版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wx.getSystemInfo(&#123;</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="keyword">let</span> currVersion = res.system.split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (res.platform == <span class="string">'android'</span> &amp;&amp; util.versionCompare(<span class="string">'6.5.7'</span>, currVersion)) &#123;</span><br><span class="line">          wx.showModal(&#123;</span><br><span class="line">            title: <span class="string">'提示'</span>,</span><br><span class="line">            content: <span class="string">'当前android版本过低，暂不支持'</span>,</span><br><span class="line">            showCancel: <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.platform == <span class="string">'ios'</span> &amp;&amp; util.versionCompare(<span class="string">'6.5.6'</span>, currVersion)) &#123;</span><br><span class="line">          wx.showModal(&#123;</span><br><span class="line">            title: <span class="string">'提示'</span>,</span><br><span class="line">            content: <span class="string">'当前ios版本过低，暂不支持'</span>,</span><br><span class="line">            showCancel: <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>跨平台方案</strong></p>
<p>我们必须<code>保证设备的标识唯一</code>，两种平台获取的数据是一样的，那么我们既然不能联系苹果叫他开放，我们就采用一个<code>折中</code>的方法。</p>
<p>我一开始网上查找了很多资料，其中有说道蓝牙的<code>advertisData</code>当中是含有MAC地址的数据包，你只要解析一下就可以获取了，但是我按照他的方法操作一番发现安卓的deviceId和我获取的是不一样的值。所以就放弃这个方法了。</p>
<p>这时我就想着既然苹果可以通过这个字段获取到一个唯一值，那么安卓同样也可以呀。所以安卓端我也同样使用这个方法获取，不出所料果然可以。</p>
<p>我把这个方法称之为<code>适配器方法</code>，因为和设计模式的适配器模式思想一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueId</span>(<span class="params">bf</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> buffer = bf.slice(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> mac = <span class="built_in">Array</span>.prototype.map.call(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer), x =&gt; (<span class="string">'00'</span> + x.toString(<span class="number">16</span>)).slice(<span class="number">-2</span>)).join(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> mac.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单介绍一下，这是一个处理buffer的函数，因为我们展开advertisData字段看到是buffer类型的，只要我们把它当作参数传进去就可以获取到16进制的值，我就把这个值当作蓝牙的唯一标识。例如<code>F3C85DF5EFFB</code>的这种标识。</p>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><p>期间也用过尝试很多种的方式来解决这个顽固的问题，但是都没有成功。心里就只有一个想法就是如何把这两者通过中间方法获取都是一样的值。</p>
<p>这个项目我觉得最大的坑就是这个了，曾经研究了好多天的时间都不曾解决，一开始我也不知道有这个限制，我还问过淘宝的蓝牙生产商能不能在蓝牙上面多加一个广播字段与deviceId一样，加入可以的话就直接获取了，也没有这么多事情了。奈何不行。</p>
<p>所以希望大家做这一块的话可以留意一下这个问题，但是我还发现有一些蓝牙的广播字段没有这个advertisData这个字段，那么我的方法也就不管用了，我还在想着怎么解决这个问题，后面有进展再更新吧。</p>
<p><img src="/2020/04/20/BLE/2.gif" alt=" "></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>BLE</tag>
        <tag>蓝牙技术</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>你还在使用原生开发小程序吗</title>
    <url>/2020/04/18/mpvue/</url>
    <content><![CDATA[<blockquote>
<p>最近帮别人在做一个小程序,因为官方的支持不够好,组件库也不够多,所以就没有使用官方的操作。网上查找了一番，觉得mpvue还不错（之前也没玩过），索性拿来用吧！</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/18/mpvue/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>小程序的做法也是比较简单的，假如你是老手的话基本上开箱即用，但是奈何自己技术不够，那就手把手教你踩坑吧。</p>
<p>之前也做过几个小程序，我用过<code>官方的</code>、<code>uni-app</code>开发，效果还行。然后现在是想尝试一下<code>mpvue</code>，生态还可以，组件库也多。拿到设计图的时候觉得还可以，但是一看好像还是有点东西的。</p>
<h2 id="02-自定义tabbar"><a href="#02-自定义tabbar" class="headerlink" title="02 自定义tabbar"></a>02 自定义tabbar</h2><p>我看到了页面是有一个自定义tabbar的，自己之前没有做做过这种，都是直接在app.json文件里面配置的，简单高效不带坑。虽然说官方支持<code>自定义tabbar</code>的功能，但是我和官方的意思就不是同一个频道的。这是我拿到的<code>原型图</code>：</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/04476daa-209b-4a1c-a21b-686ad3a103fe.png" alt="原型图"></p>
<p>一开始好像是有点蒙，但是谷歌了一下其实还有救。思想就是把原生的tabbar隐藏，然后把你自定义的tabbar放上去即可。</p>
<ul>
<li>在app.json配置tabbar，因为后面要跳转（不配置报错）</li>
<li>新建一个mytabbar.vue文件，写自己的tabbar</li>
<li>在app.vue的onShow的时候隐藏原生的tabbar,<code>wx.hideTabBar();</code></li>
</ul>
<p>这样其实就好了，但是需要tabbar的页面都要引入自己的组件，talk is cheap，接下来就开始实现自己的组件吧。</p>
<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p><strong>模板部分</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"tabBar-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"tabBar-box"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"tabBar-nav"</span> <span class="attr">v-if</span>=<span class="string">"navList.length &gt; 0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-for</span>=<span class="string">"(item, index) in navList"</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">click</span>=<span class="string">"selectNavItem(index,item.pagePath)"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"item-images"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:src</span>=<span class="string">"selectNavIndex === index ? item.selectedIconPath : item.iconPath"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">alt</span>=<span class="string">"iconPath"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:class</span>=<span class="string">"selectNavIndex === index ? 'item-text item-text-active' : 'item-text' "</span></span></span><br><span class="line"><span class="tag">          &gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">"needButton"</span> <span class="attr">style</span>=<span class="string">"flex: 2"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"submit-box"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">              <span class="attr">v-if</span>=<span class="string">"btnText==='抽大礼'"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:disabled</span>=<span class="string">"!handButton"</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">"bindNavigateTo('../game/main')"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:class</span>=<span class="string">"handButton ? 'submit-box-btn submit-box-btn-active' : 'submit-box-btn' "</span></span></span><br><span class="line"><span class="tag">            &gt;</span>&#123;&#123; btnText &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>逻辑部分</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">"selectNavIndex"</span>, <span class="string">"needButton"</span>, <span class="string">"handButton"</span>, <span class="string">"btnText"</span>],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      navList: [</span><br><span class="line">        &#123;</span><br><span class="line">          pagePath: <span class="string">"../index/main"</span>,</span><br><span class="line">          iconPath: <span class="string">"../../static/tabs/home.png"</span>,</span><br><span class="line">          selectedIconPath: <span class="string">"../../static/tabs/home-active.png"</span>,</span><br><span class="line">          text: <span class="string">"首页"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          pagePath: <span class="string">"../share/main"</span>,</span><br><span class="line">          iconPath: <span class="string">"../../static/tabs/home.png"</span>,</span><br><span class="line">          selectedIconPath: <span class="string">"../../static/tabs/home-active.png"</span>,</span><br><span class="line">          text: <span class="string">"分享"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          pagePath: <span class="string">"../center/main"</span>,</span><br><span class="line">          iconPath: <span class="string">"../../static/tabs/home.png"</span>,</span><br><span class="line">          selectedIconPath: <span class="string">"../../static/tabs/home-active.png"</span>,</span><br><span class="line">          text: <span class="string">"我的"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    selectNavItem(index, pagePath) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="keyword">this</span>.selectNavIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.bindViewTap(pagePath);</span><br><span class="line">    &#125;,</span><br><span class="line">    bindNavigateTo(url) &#123;<span class="comment">//不是tabbar的页面跳转方式</span></span><br><span class="line">      wx.navigateTo(&#123;</span><br><span class="line">        url</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    bindViewTap(url) &#123;<span class="comment">//tabbar页面的跳转方式</span></span><br><span class="line">      wx.switchTab(&#123;</span><br><span class="line">        url</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>样式部分</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.tabBar-box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10</span>rpx <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#eb8c2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tabBar-nav</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.24s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-text-active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fec754</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-images</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.24s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.submit-box-btn</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">80</span>rpx;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50</span>rpx;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#404040</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.submit-box-btn-active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fca542</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fca542</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>使用方式也很简单，直接把它引入进来，然后注册一下就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mytabbar <span class="keyword">from</span> <span class="string">"@/components/mytabbar"</span>;</span><br><span class="line"></span><br><span class="line">components: &#123;</span><br><span class="line">    mytabbar</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>在你的页面里面放上组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mytabbar</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:needButton</span>=<span class="string">"needButton"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">:btnText</span>=<span class="string">"btnText"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:handButton</span>=<span class="string">"handButton"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:selectNavIndex</span>=<span class="string">"selectNavIndex"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">mytabbar</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>needButton:是否需要一个button，就像我这里就需要了</li>
<li>btnText：button里面的文字显示，因为可能另一个页面显示不一样</li>
<li>handButton：点击button的逻辑</li>
<li>selectNavIndex：需要高亮的下标，每个页面的高亮不一样</li>
</ul>
<p><img src="https://imgkr.cn-bj.ufileos.com/66f1a5dc-90e1-4aa9-bfd2-f6b7215b3056.png" alt="最后实现"></p>
<h2 id="03-组合使用Vant"><a href="#03-组合使用Vant" class="headerlink" title="03 组合使用Vant"></a>03 组合使用Vant</h2><p>自己造轮子很麻烦，就用别人的组件库好了。看了一下Vant还不错，而且别人也尝试过使用vant+mpvue的开发模式，坑还是自己踩一边的好。</p>
<p>首先我遇到的第一个问题就是如何引入组件库，虽然官方的做法是直接安装，但是我安装之后发现老是找不到路径，没办法只好放弃。我现在采用的是<code>直接引入本地的</code>方式进行，虽然每一次编译都要一点时间，但是还好。以后上线的时候把没用的组件删除就好，保留你需要使用的组件（按需引入）</p>
<p>下载整个仓库之后把里面的<code>dist文件夹</code>下面的所有文件复制到你的项目，<code>static/vant</code>当中，以后使用就从这里引入好了，使用的时候还是在app.json里面配置(<code>与pages同级</code>)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"usingComponents": &#123;</span><br><span class="line">    "van-button": "/static/vant/button/index",</span><br><span class="line">    "van-tab": "/static/vant/tab/index",</span><br><span class="line">    "van-tabs": "/static/vant/tabs/index",</span><br><span class="line">    "van-nav-bar": "/static/vant/nav-bar/index",</span><br><span class="line">    "van-icon": "/static/vant/icon/index",</span><br><span class="line">    "van-row": "/static/vant/row/index",</span><br><span class="line">    "van-col": "/static/vant/col/index",</span><br><span class="line">    "van-dialog": "/static/vant/dialog/index",</span><br><span class="line">    "van-field": "/static/vant/field/index",</span><br><span class="line">    "van-area": "/static/vant/area/index",</span><br><span class="line">    "van-popup": "/static/vant/popup/index",</span><br><span class="line">    "van-picker": "/static/vant/picker/index"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>这样其实就可以了，写页面的时候直接按照它的文档写就好了。</p>
<h2 id="04-遇到的小坑"><a href="#04-遇到的小坑" class="headerlink" title="04 遇到的小坑"></a>04 遇到的小坑</h2><p><strong>自定义NavBar</strong></p>
<p>因为UI图上面的导航有自定义的样式，没办法只好使用vant的<code>van-nav-bar</code>，但是我使用slot的时候发现左边的图标点击不了。</p>
<p>文档上面是使用<code>bind:click-left</code>的方式，但是没用，其实正确的写法应该是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-nav-bar</span> <span class="attr">title</span>=<span class="string">"我的"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">van-icon</span> <span class="attr">name</span>=<span class="string">"wap-home"</span> <span class="attr">slot</span>=<span class="string">"left"</span> @<span class="attr">click</span>=<span class="string">"toHome"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-nav-bar</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>图片背景</strong></p>
<p>使用图片背景的时候，发现报错说不可以引用本地的图片，使用base64或者网络图片。但是我使用网络图片发现报了403错误，没有权限。索性就使用了base64的方式。虽然不太接受这种方式，因为转出来的字符串很长。</p>
<p><strong>获取定位</strong></p>
<p>首页需要有一个获取定位的功能。但是看了一下小程序的官方文档只能获取到经纬度。这里我就使用了第三方的接口，去腾讯位置服务平台注册一下，可以使用经纬度逆向解析地址的功能。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/6be46cf5-4cdf-47a7-a575-34bcb446ba25.png" alt></p>
<p>然后里面有一个逆地址解析的功能，使用经纬度作为参数就可以获取了。但是开始你要去app.json配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在app.json中配置权限</span></span><br><span class="line"><span class="string">"permission"</span>: &#123;</span><br><span class="line">    <span class="string">"scope.userLocation"</span>: &#123;</span><br><span class="line">      <span class="string">"desc"</span>: <span class="string">"您的位置信息将用于搜索银行信息,以帮助您填写正确的支行信息"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/0c65e9b8-5cde-43ca-8694-8559c40174c8.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>实例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wx.getLocation(&#123;</span><br><span class="line">      type: <span class="string">"wgs84"</span>, <span class="comment">// 默认为 wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标</span></span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"定位成功"</span>,res);</span><br><span class="line">        <span class="keyword">var</span> locationString = res.latitude + <span class="string">","</span> + res.longitude;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">          url: <span class="string">"http://apis.map.qq.com/ws/geocoder/v1/?l&amp;get_poi=1"</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            key: <span class="string">"xxxxx-xxxxx-xxxxx-xxxx-xxxxx-xxxxx"</span>,<span class="comment">//你自己的key,页面上有</span></span><br><span class="line">            location: locationString</span><br><span class="line">          &#125;,</span><br><span class="line">          method: <span class="string">"GET"</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"请求成功"</span>,res);<span class="comment">//这里就可以获取你的地址了</span></span><br><span class="line">          &#125;,</span><br><span class="line">          fail: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"请求失败"</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"请求完成"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"定位失败"</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"定位完成"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>但是你会发现也有一些小问题，比如一开始说你的合法域名问题。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/a19b7e1e-b053-45b1-8c96-517408a792e1.png" alt><br>然后你就可以去你的项目配置那里勾上<code>不检验合法域名</code>。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/7a16cb6b-b678-495f-a625-e5ef1b58d1c3.png" alt><br>然后重新试一下，发现还是不行。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/a07d938c-c7d8-4201-82b8-f9d5247a1091.png" alt="请求源未授权"></p>
<p>这里其实就要你去微信小程序的后台加入请求源了，因为我现在是测试号没有后台弄不了。注意的是：</p>
<ul>
<li>微信小程序使用的时候，WebServiceAPI 域名白名单<code>不能配置</code>，否则会报错</li>
<li>request合法域名<code>要配置</code></li>
</ul>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><p>一顿操作下来发现自己还是可以接受，但是应该说还有很多坑没有亲自踩，都是在前人的路上走，谷歌一搜mpvue的，为什么一堆都是踩坑记录？？？</p>
<p>其实还好，mpvue对vue的语法支持还不错，因为现在自己对vue的语法比较熟悉，写起来是没有毛病的，但是主要是一些细节上可能会难以把控。</p>
<p>特此记录一下，也是对自己的记录。发现其实学会了vue真的是很好，不仅可以开发web界面还可以把小程序也一起搞了。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000015027980" target="_blank" rel="noopener">mpvue 小程序如何自定义tabBar，不使用navigateTo跳转，模拟redirectTo跳转</a></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/18/mpvue/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue过滤器的原理解析</title>
    <url>/2020/04/15/vueFilter/</url>
    <content><![CDATA[<blockquote>
<p>又来学习源码系列，今天就看一下vue中的过滤器具体是怎么实现的，我觉得这是一个不常用但是很重要的知识点，开冲！</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/15/vueFilter/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理。我们看一下官方的定义：</p>
<blockquote>
<p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以在一个组件的选项中定义本地的过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'capitalize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数。过滤器可以串联：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。</p>
<p>过滤器是 JavaScript 函数，因此可以接收参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&#39;arg1&#39;, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。</p>
<h2 id="02-过滤器原理"><a href="#02-过滤器原理" class="headerlink" title="02 过滤器原理"></a>02 过滤器原理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的过滤器经过一顿操作之后就会变成：<code>_s(_f(&quot;capitalize&quot;)(message))</code>。</p>
<ul>
<li>_f：该函数其实就是resolveFilter的别名，作用是从<code>_this.$options.filter</code>找到过滤器并返回</li>
<li>_s：该函数就是toString函数的别名，作用是拿到过滤之后的结果并传递给toString()函数，结果会保存到VNode中的text属性，返回结果直接渲染视图</li>
</ul>
<h3 id="串联过滤器"><a href="#串联过滤器" class="headerlink" title="串联过滤器"></a>串联过滤器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的串联过滤器经过一顿操作之后就会变成：</p>
<p><code>_s(_f(&quot;filterB&quot;)(_f(&quot;filterA&quot;)(message)))</code></p>
<p>这里的意思就是message作为第一个参数传进filterA当中，然后经过filterA的处理结果就传进filterB当中。<code>即filterA过滤器的结果就是filterB过滤器的输入</code>。</p>
<h3 id="过滤器参数接收"><a href="#过滤器参数接收" class="headerlink" title="过滤器参数接收"></a>过滤器参数接收</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB(&quot;param&quot;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>以上的过滤器的编译结果就是：</p>
<p><code>_s(_f(&quot;filterB&quot;)(_f(&quot;filterA&quot;)(message),&quot;param&quot;))</code></p>
<p>这里有一点注意的是：这个param参数是filterB的第二个参数，它的第一个参数是经过filterA处理的结果。</p>
<h3 id="f函数的原理"><a href="#f函数的原理" class="headerlink" title="_f函数的原理"></a>_f函数的原理</h3><p>_f函数其实就是寻找过滤器的，如果找到过滤器就返回过滤器，找不到就返回与参数相同的值。它的代码其实很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;identity, resolveAssets&#125; <span class="keyword">from</span> <span class="string">'core/util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveFilter</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> resolveAssets(<span class="keyword">this</span>.$options, <span class="string">'filters'</span>, id, <span class="literal">true</span>) || identity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点来看一下resolveAssets到底做了什么事情。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsset</span> (<span class="params">options, type, id, warnMissing</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span>(id) !== <span class="string">'string'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> assets = options[type]</span><br><span class="line">  <span class="keyword">if</span>(hasOwn(assets, id)) <span class="keyword">return</span> assets[id]</span><br><span class="line">  <span class="keyword">const</span> camelizedId = camelize(id)</span><br><span class="line">  <span class="keyword">if</span>(hasOwn(assets, camelizedId)) <span class="keyword">return</span> assets[camelizedId]</span><br><span class="line">  <span class="keyword">const</span> PascalCaseId = capitlize(camelizedId)</span><br><span class="line">  <span class="keyword">if</span>(hasOwn(assets, PascalCaseId)) <span class="keyword">return</span> assets[PascalCaseId]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//检查原型链</span></span><br><span class="line">  <span class="keyword">const</span> res assets[id] || assets[camelizedId] || PascalCaseId</span><br><span class="line">  <span class="keyword">if</span>(process.env.NODE_ENV!==<span class="string">'production'</span>&amp;&amp; warnMissing&amp;&amp;!res)&#123;</span><br><span class="line">    warn(<span class="string">'Fail to resolve'</span> + type.slice(<span class="number">0</span>,<span class="number">-1</span>)+<span class="string">':'</span>+id, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实它的寻找过程也很简单，主要是做了以下的操作（id是过滤器id）：</p>
<ul>
<li>判断过滤器id是否为字符串，不是则终止</li>
<li>用assets存储过滤器</li>
<li>hasOwn函数检查assets自身是否存在id属性，存在则返回</li>
<li>hasOwn函数检查assets自身是否存在<code>驼峰化后的</code>id属性，存在则返回</li>
<li>hasOwn函数检查assets自身是否存在将<code>首字母大写后的</code>id属性，存在则返回</li>
<li>如果还是没有，就是去原型链找，找不到就会打印警告</li>
</ul>
<h3 id="过滤器解析原理"><a href="#过滤器解析原理" class="headerlink" title="过滤器解析原理"></a>过滤器解析原理</h3><p>我们想一下，解析器是怎么解析过滤器的语法？其实在vue内部专门有这么一个函数用来解析过滤器语法：<code>parseFilters</code></p>
<p>它的原理就是解析过滤器列表，然后<code>循环过滤器列表</code>并<code>拼接字符串</code>。</p>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><p>其实过滤器的作用有很多，相信大家对时间的格式化也有很多的处理方法，其中一个就是可以利用过滤器来<code>格式化时间</code>。而且我们知道，过滤器它是可以<code>支持链式的操作</code>，很方便地对变量进行多步处理，然后返回你想要的结果。</p>
<p>过滤器的原理其实很简单，无非就是<code>在编译阶段就把过滤器编译成函数进行调用</code>，串联的过滤器就是<code>嵌套调用</code>。关于编译成函数的时候就是利用vue的内部函数<code>parseFilters</code>，解析过滤器列表并进行<code>拼接字符串</code>。</p>
<p>参考文章：</p>
<ul>
<li>深入浅出vue.js </li>
</ul>
<p><img src="/2020/04/15/vueFilter/2.gif" alt=" "></p>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>过滤器</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Webpack中Loader与Plugin的实践</title>
    <url>/2020/04/12/loader-plugin/</url>
    <content><![CDATA[<blockquote>
<p>最近看一下webpack相关的内容，谈一下如何编写loader和plugin</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/12/loader-plugin/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>相信大家对webpack也有一定的了解，其实深入浅出webpack这本书也看了很多遍，每一次看都会有一些细节之前没有注意到，我觉得其实可以把它当成是一本工具书来看，之前我也是只看配置都有点让你看不过来，更别说其他的了。</p>
<p>所以今天我就说一下如何编写一个loader与plugin，以及它们之间有什么却别等。</p>
<h2 id="02-Loader"><a href="#02-Loader" class="headerlink" title="02 Loader"></a>02 Loader</h2><p>Loader其实就是一个转换器，把你输入的内容翻译一遍，本质上是没有什么变化的，就像中文翻译成英文一样。我们其实在不知不觉当中也使用了很多的Loader，但是我们没有过多关注而已。常用的Loader有以下几类：</p>
<h3 id="常见Loader"><a href="#常见Loader" class="headerlink" title="常见Loader"></a>常见Loader</h3><p><strong>语言转换类</strong></p>
<ul>
<li><code>babel-loader</code>:把ES6转成ES5</li>
<li><code>ts-loader</code>:把TypeScript转成JavaScript</li>
<li><code>sass-loader</code>:把scss/sass转成css</li>
<li><code>less-loader</code>:把less代码转成css</li>
<li><code>css-loader</code>:加载css，文件导入等</li>
</ul>
<p><strong>文件加载类</strong></p>
<ul>
<li><code>raw-loader</code>:把文本文件加载到代码中</li>
<li><code>file-loader</code>:将文件输出到一个文件夹中，使用相对路径引用输出文件</li>
<li><code>source-map-loader</code>:加载额外的SourceMap文件，方便断点调试</li>
<li><code>node-loader</code>:加载Node.js原生模块的.node文件</li>
<li><code>json-loader</code>:加载json文件</li>
</ul>
<p><strong>其他loader</strong></p>
<ul>
<li><code>vue-loader</code>:加载.vue文件</li>
<li><code>ui-component-loader</code>:按需加载组件库</li>
<li><code>i18n-loader</code>:加载多语言版本</li>
<li><code>ignore-loader</code>:忽略部分文件</li>
</ul>
<h3 id="Loader配置"><a href="#Loader配置" class="headerlink" title="Loader配置"></a>Loader配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.scss/</span>,</span><br><span class="line">        use:[</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            minimize:<span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'sass-loader'</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码意思就是对.scss文件的转换过程，test的配置就是对某一类文件进行转换，use是使用的loader(转换器),它是一个数组，遵循从右往左的使用。先sass-loader再css-loader再style-loader。</p>
<h3 id="加载本地Loaderre"><a href="#加载本地Loaderre" class="headerlink" title="加载本地Loaderre"></a>加载本地Loaderre</h3><p>我们默认的loader都是从npm上面下载的，但是假如我们要使用自己本地写的loader怎么办呢？我们在webpack里面有这样一个配置<code>resolveLoader</code>,它的意思就是说我们使用哪里的loader来加载文件，可以配置多个地方：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolveLoader:&#123;</span><br><span class="line">    modules:[<span class="string">'node_modules'</span>,<span class="string">'yourPath'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思就是说我们可以自定义loader的路径，默认就是从node_modules里面找，但是假如你的自定义loader放在本地，可以把你的路径写在yourPath里面(相对路径)。匹配规则就是从左向右查找。</p>
<h3 id="Loader编写"><a href="#Loader编写" class="headerlink" title="Loader编写"></a>Loader编写</h3><p>说了这么多，我们自己来写一个简单的loader吧，虽然是一个没有意义的loader，但是也让大家有一个简单的印象，原来写一个loader是很简单的。</p>
<ul>
<li>新建一个目录，如myLoader</li>
<li>进入目录初始化package.json文件，安装webpack <code>npm init -y</code>,<code>npm i -D webpack webpack-cli</code></li>
<li>根目录下新建文件夹src，然后创建入口文件index.js —— <code>src/index.js</code></li>
<li>根目录下新建文件夹loaders，然后新建自定义myLoader.js—— <code>loaders/myloader.js</code></li>
<li>根目录下新建webpack配置文件<code>webpack.config.js</code></li>
<li>在package.json配置webpack打包build命令</li>
</ul>
<p><img src="https://imgkr.cn-bj.ufileos.com/92e62dae-6015-4b0d-b745-3c37016f54b5.png" alt="代码目录"></p>
<p><code>package.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"myLoader"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'世界上最好的语言是PHP!'</span>)</span><br></pre></td></tr></table></figure>

<p><code>myLoader.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">const</span> result = source.replace(<span class="string">'PHP'</span>, options.name);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"development"</span>, </span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: path.resolve(__dirname, <span class="string">"./loaders/myLoader.js"</span>),</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">"JavaScript"</span>,<span class="comment">//这里就是你要替换的值</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>好了，到此为止我们已经成功地写了一个loader，接下来我们就测试一下是否真的work！运行<code>npm run build</code>之后会输出一个dist文件夹，里面有一个main.js文件，盘它。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/0a44c4bd-b668-4744-81be-641676575ef4.png" alt="运行/dist/main.js文件" title>
                </div>
                <div class="image-caption">运行/dist/main.js文件</div>
            </figure>


<h2 id="03-Plugin"><a href="#03-Plugin" class="headerlink" title="03 Plugin"></a>03 Plugin</h2><p>相对于Loader来说，其实plugin的机制更加灵活，它可以在webpack的运行过程中改变输出结果。简单来说就是为输出添砖加瓦。</p>
<h3 id="常见Plugin"><a href="#常见Plugin" class="headerlink" title="常见Plugin"></a>常见Plugin</h3><ul>
<li><code>extract-text-webpack-plugin</code>:把JS中的css代码提到单独文件中</li>
<li><code>webpack-parallel-uglify-plugin</code>:多进程代码压缩</li>
<li><code>html-webpack-plugin</code>:简化HTML文件创建</li>
<li><code>dll-plugin</code>:提高webpack构建速度</li>
<li><code>ignore-plugin</code>：忽略部分文件</li>
</ul>
<h3 id="Plugin的工作原理"><a href="#Plugin的工作原理" class="headerlink" title="Plugin的工作原理"></a>Plugin的工作原理</h3><p>我们先来看一下简单的插件是怎么编写出来的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  apply(complier)&#123;</span><br><span class="line">    complier.plugin(<span class="string">'compilation'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = myPlugin;</span><br></pre></td></tr></table></figure>

<p><strong>工作流程</strong>：</p>
<ul>
<li>webpack启动，执行new myPlugin(options)，初始化插件并获取实例</li>
<li>初始化complier对象，调用myPlugin.apply(complier)给插件传入complier对象</li>
<li>插件实例获取complier，通过complier.plugin监听webpack广播的事件，通过complier对象操作webpack</li>
</ul>
<h3 id="Plugin编写"><a href="#Plugin编写" class="headerlink" title="Plugin编写"></a>Plugin编写</h3><p>俗话说，<code>talk is cheap,show me the code</code></p>
<p>还是沿用上面的代码结构,在根目录下面建一个myPlugins文件夹，里面建一个myPlugin.js文件，我们就自定义一个plugin：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(doneCallback, failCallback) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doneCallback = doneCallback;</span><br><span class="line">        <span class="keyword">this</span>.failCallback = failCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.done.tap(<span class="string">'myPlugin'</span>, (stats) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.doneCallback(stats);</span><br><span class="line">        &#125;);</span><br><span class="line">        compiler.hooks.failed.tap(<span class="string">'myPlugin'</span>, (err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.failCallback(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = myPlugin;</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>webpack.config.js</code>文件里面先<code>引入插件</code>，然后<code>配置插件</code>即可。</p>
<p>还是先打包一下，你会发现在打包过程中，webpack会广播默认的事件，这里我就监听了webpack的<code>done事件</code>(webpack构建成功，即将退出)和<code>fail事件</code>(webpack构建失败，即将退出)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPlugin = <span class="built_in">require</span>(<span class="string">"./plugins/myPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> myPlugin(</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="comment">//throw new Error('Error!')</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功监听到结束事件，可以执行你想要的函数！"</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">      &#125;</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行之后发现是可以监听的，这里我把两种情况都试一下。首先正常构建，然后手动抛出错误，结果如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/bb906ef1-501e-4de4-a076-6065b0f18d6d.png" alt="成功构建" title>
                </div>
                <div class="image-caption">成功构建</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/1afc4540-f45a-4fcf-9e0f-524755483d17.png" alt="失败构建" title>
                </div>
                <div class="image-caption">失败构建</div>
            </figure>


<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>今天没事就折腾一下看似简单的东西，比如想看一下一些经典loader和plugin的源代码，自信的我还想看一下webpack的源代码，发现看不懂，就此打住了。</p>
<p>不过其实plugin和loader的区别也是面试常问的，也会问你知道怎么写loader和plugin的问题，虽然自己实现的很简单甚至有点幼稚，自己感觉还好。</p>
<p>相信大家读了之后应该有自己的理解，以后遇到这个问题也会有自己的想法，大家实践一下就知道其中的奥秘了。</p>
<p>参考文章：深入浅出Webpack</p>
<p><img src="/2020/04/12/loader-plugin/2.gif" alt></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loader</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>学习两个多月后的一些学习感悟</title>
    <url>/2020/04/11/studySummarize/</url>
    <content><![CDATA[<blockquote>
<p>经过两个多月的学习与总结，我悟出了一些道理。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/11/studySummarize/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>很多人都有终身学习的概念，我也一直都是认同的，毕竟只有学习才会让自己适应社会，适应工作与生活。今天我就来谈一下<code>学习</code>这个比较虚、也比较广的范围，也是对自己坚持两个多月以来的感悟吧。</p>
<p>因为今年疫情的原因，自己也和大多数人一样在家里，响应政府的号召，不出门。但是想着不出门，也不能和好友相聚等，那剩下的只有什么呢？没有，剩下的只是学习。不管你是从事什么行业，学习是一件永远不过时的活动，也是一件让你觉得自己没有浪费时间的事情（有没有收获先不说）。</p>
<p>所以今年春节到现在，基本上每天都在学习和总结，从这两个多月的积累和实践下，从几个方面谈一下自己理解与感悟吧：</p>
<ul>
<li>我是否要早起和学习计划？</li>
<li>我效率不高应该投入更多时间？</li>
<li>我应该有充足的娱乐时间吗？</li>
<li>学习时间总想睡觉？睡觉总想着学习？</li>
</ul>
<h2 id="02-我是否要早起和学习计划？"><a href="#02-我是否要早起和学习计划？" class="headerlink" title="02 我是否要早起和学习计划？"></a>02 我是否要早起和学习计划？</h2><p><strong>关于早起</strong></p>
<p>大家应该对鸡汤文要早起的思想洗脑了，认为<code>早起不是一种形式，而是一种习惯</code>。当然我看过的所有鸡汤文中都详细说了早起有什么好处，早起就该让每个人拥有而且一定会感激自己的早起等等，不可否认，早起可以让人完成很多的工作，在没人打扰，安静的时候效率很高。</p>
<p>但是也不能一概而论，因为早起的前提是<code>要和身体打好交道</code>，你的身体是否允许你早起。专家都建议你要睡7小时左右，那些都是专业的数据，不可能凭空捏造。那么我们为什么不相信他们的话呢？</p>
<p>总体来说，我们应该<code>少喝一些剧毒鸡汤</code>，说什么睡4~5个小时也不见自己有什么异样等，那是时间问题。要是你长期这样，违反了生理的规律，肯定是对自己有害的。</p>
<p>有些同学可能受鸡汤文影响，我就亲身经历过，看了一场讲座或者听了一个牛人的分享会，第二天就很早起床。如无意外你肯定很困，效率低下且坚持不过三天。这就是所说的三分钟热度，那是外力来推动你早起，但是<code>真正做到自觉，还是要内力来推动你</code>。</p>
<p>所以关于早起，我们应该有以下几点：</p>
<ul>
<li>保证睡眠时间早起，让身体充分休息</li>
<li>慢慢提前起床时间，不可突然提前</li>
<li>早起是一个习惯，不是一种形式</li>
</ul>
<p><strong>学习计划</strong></p>
<p>学习是一定要有具体的计划的，为什么呢？假如你没有学习计划，即使你学了很多，投入了很多的时间，你也不知道学了什么，<code>没有计划，就像没有方向一样</code>，看到什么就学什么。很多初学者都会犯这样的错误，听说哪个框架很火就去学哪一个。</p>
<p>有了学习计划，你就把学习这一个很虚的内容可视化，看到自己的进步和成长，带不走的是书本，但是带的走是知识。</p>
<p>我觉得当你学习到了一个程度之后你就会对学习感到厌倦，会有一种不想学习的感觉。你也会有一种什么都会，但什么也不会的感觉的。学习计划的作用就是让你<code>记录自己的学习路线</code>，卡在那个地方你都做到心里有数。总结一下：</p>
<ul>
<li>计划是必须的，会让你有清晰的路线</li>
<li>计划可以让你的学习可视化</li>
<li>计划会让你的学习过程更加顺利</li>
</ul>
<h2 id="03-我效率不高应该投入更多时间？"><a href="#03-我效率不高应该投入更多时间？" class="headerlink" title="03 我效率不高应该投入更多时间？"></a>03 我效率不高应该投入更多时间？</h2><p>学习的过程中必定是艰苦的，很多时候自己都是单枪匹马地战斗，没人有带你学习，唯有自己撸起袖子干。但是在这个过程你总会浪费很多时间，甚至有时候还会怀疑人生，为什么我的付出没有回报？</p>
<p>时间是平等的，你没有收获不代表你是一个效率低下的人，可能是没有掌握自己学习方法的人。之前我就写过一篇《番茄工作法》的文章，介绍了一种相对效率高的的学习方法，可以适合大部分人使用。</p>
<p><strong>学习问题</strong></p>
<p>但是也有小伙伴会说，我制订了计划，也有自己的学习方法，但是效率也不行呀？其实这也是分很多种情况，比如你的学习环境问题、你的学习心态或者情绪问题等，<code>学习=环境+时间+心态+资料</code>。如果你满足这些条件，你应该会有一个良好的学习效果。</p>
<p>假如你有一个知识点弄了许久没有明白，不是时间问题就是智力问题。很多时候都是前者，花多一点时间可以解决99%的问题。就如看书一般，看一遍不懂那就多看几遍，前人深邃的思想哪是你一下子就能领会。</p>
<p><strong>时间投入</strong></p>
<p>时间投入也不是越多越好，大脑就像身体一样，总要休息的。之前的《番茄工作法》也提到，学习25分钟就让自己的大脑休息5分钟，5分钟不是浪费时间，而是为了你更加专注，提高效率。</p>
<p>当你学习<code>没有心情</code>、<code>烦躁</code>、<code>焦虑</code>的时候，是大脑要提醒你换一种方式用脑，应该转移自己的学习内容，或者停止学习，泡上一壶茶发呆一下都可以。时刻记住  <code>我们是人，不是机器，不可连轴转</code>。</p>
<blockquote>
<p><code>沉没成本:</code><br>学习需要时间，而且是大量的时间，这里面就有沉没成本在里面。所谓时间成本就是你学习了一天毫无收获，那就浪费了一天的时间。举个简单的例子，你在车站等公交车，期间很多的小车经过问你是否要搭乘，但是你拒绝了。最后等了一个小时车也没来，你选择了坐小车。沉没成本就是一小时，已经付出且不可收回的成本。</p>
</blockquote>
<p>我们来小结一下，关于效率不高是否要加大时间的投入，主要有三点：</p>
<ul>
<li>效率不高，应该适当休息而不可强制自己学习</li>
<li>学习烦躁，转换自己的学习内容或者停止学习</li>
<li>学会学习，评估自己的学习会带来的沉没成本</li>
</ul>
<h2 id="04-我应该有充足的娱乐时间吗？"><a href="#04-我应该有充足的娱乐时间吗？" class="headerlink" title="04 我应该有充足的娱乐时间吗？"></a>04 我应该有充足的娱乐时间吗？</h2><p>这个问题是肯定的的，<code>生活不止是只有学习和工作，而且还有娱乐，才是生活的意义</code>。但是很多人就宁愿把时间投入到学习当中，也不愿意拿来娱乐。不可否认你可以收获更多，但是你也会相应失去其它的收获。比如为了学习放弃与家人相处，放弃参加讲座，放弃观看演出等。</p>
<p>为什么有人把生活变成了诗和远方呢？因为他们有钱。虽然这是真实的状态，但是作为90后青年也要学会享受生活，别人可以的我们也应该可以，别人可以出国旅游，我可以在中国旅游。别人经济到位豪华游，我们经济不到位就穷游，同样也可以看到诗和远方。</p>
<p>所以关于是否有充足的娱乐时间这个问题上，我们应该要有的。为什么会有奖励这种事情呢？因为你学习了付出了，就有相应对自己的奖励。这样你的大脑才会继续为你工作，继续为你运转。小结一下就是：</p>
<ul>
<li>给自己娱乐的时间，让自己得到精神奖励</li>
<li>除了拥有学习，还要拥有生活</li>
</ul>
<h2 id="05-学习时间总想睡觉？睡觉总想着学习？"><a href="#05-学习时间总想睡觉？睡觉总想着学习？" class="headerlink" title="05 学习时间总想睡觉？睡觉总想着学习？"></a>05 学习时间总想睡觉？睡觉总想着学习？</h2><p>有没有这样的情况，当你认真起床学习的时候，发现自己的脑子在睡觉，但是当你更衣准备睡觉的时候，脑子却叫你起床学习。</p>
<p><code>我：夜深了，要睡觉了哦
脑子：睡什么睡，起来嗨！
我：...</code></p>
<p>脑子就是有这么神奇，但是也是少数的时候，一般情况下可能是你突然冒出一个想法，让你忍不住要实验一下，或者你想到了一个解决困扰你很久的方法。我就是某天晚上想到了一个很厉害的想法，然后凌晨两点也睡不着，总想着把它实践一下。</p>
<p>不过只要你的学习路线是正确的，时间安排上没有问题，我们是不会出现这种情况的。之前有人就提到我们要是反复许久都睡不着怎么办，是不是应该起来学习？个人看法应该放空你的脑子，不想就好，转移自己的注意力等让自己冷静下来。实在不行，那就起来吧。</p>
<h2 id="06-小结"><a href="#06-小结" class="headerlink" title="06 小结"></a>06 小结</h2><p>以上的想法都是最近遇到的，其实想想也没什么了不起的，有时候只是自己不想去想而已。以前总觉得开始做一件事情很难，但是当你把目标进行多步拆解，你会发现你完成的不是一项工程，你只是在搬砖，<code>最后不知不觉成了一项工程而已</code>。</p>
<p>通过自己学习感悟，也总结了许多问题，之前也不知道番茄工作法的作用，也不知道学校效率与时间的投入问题，还不是总结出来，有自己的思维和想法。</p>
<p>之前我也写过一篇《我为什么不建议大家太专注于学习》的文章，里面除了学习更多要关注的是输出与总结，现在想想，我们应该加上<code>生活与娱乐</code>。接下来的时间我也会经常更新文章，但应该不会每天都产出，留给自己总结的时间，之前的文章都是很久之前总结没有发表的一些想法而已，那时候也没有开通公众号这个平台。</p>
<p>最后还是感谢大家的关注！让我知道学习的路上不是单枪匹马，还有一群心怀大志的你们。</p>
<p><img src="/2020/04/11/studySummarize/2.gif" alt></p>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
        <tag>学习总结</tag>
        <tag>学习感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Redis的一些基础知识</title>
    <url>/2020/04/11/redis/</url>
    <content><![CDATA[<blockquote>
<p>Redis的知识其实已经是后端要掌握的技术，但是之前笔者使用过Redis做一些缓存，主要是存储用户的登录信息seesion，我觉得这个东西其实是很有用的，所以今天就深入一点看一下具体的用法。</p>
</blockquote>
<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>目前自己能想到的Redis的作用很局限，毕竟自己也没有用过其他的高级特性，其实不仅可以用于缓存，还可以用于做一些排行榜/计数、session共享、消息队列以及发布订阅等。</p>
<p>Redis的应用场景非常广泛，虽然Redis是一个key-value的内存数据库，但在实际场景中，简单key-value就非常有用，如面对数据高并发的读写、海量数据的读写等这些其实都是网站的简单但是非常重要的功能，我觉得还是有必要了解一些关于redis的事情和相关知识点。</p>
<h2 id="02-redis数据类型"><a href="#02-redis数据类型" class="headerlink" title="02 redis数据类型"></a>02 redis数据类型</h2><p>redis是一种支持Key-Value等多种数据结构的存储系统，可用于多种业务场景。提供字符串、哈希、列表、队列、集合结构直接存取。</p>
<p><strong>数据类型</strong></p>
<ul>
<li>string(字符串)</li>
<li>list(列表)</li>
<li>hash(散列)</li>
<li>set(集合)</li>
<li>zset(有序集合)</li>
</ul>
<p><code>string</code></p>
<p>Redis所有的数据结构都是以唯一的key字符串作为名称，通过key来获取相应数据。Redis 的字符串是动态字符串，是可以修改的字符串，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。常见命令：</p>
<ul>
<li>set:设置一个键值对，如 set name alan</li>
<li>get:获取键值，如get name</li>
<li>exists:是否存在键名，如exists name</li>
<li>del:删除键名，如del name</li>
<li>expire:设置过期时间，如expire name 5，5s后过期</li>
</ul>
<p><code>list</code></p>
<p>list是一个列表，它可以提供常见的栈和队列的形式，不同的是你操作的方法。当元素操作之后便会弹出且会自动删除，内存就会被回收，常用与异步队列的使用。常见命令：</p>
<ul>
<li>rpush:从右边进入，如rpush subject Chinese Math English</li>
<li>llen:查看长度，如llen subject</li>
<li>lpop:左边弹出，如lpop subject,就会弹出Chinese</li>
<li>rpop:右边弹出，如rpop subject,就会弹出English</li>
</ul>
<p><code>hash</code></p>
<p>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。常见命令：</p>
<ul>
<li>hset:用于为哈希表中的字段赋值，如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作，如果字段已经存在于哈希表中，旧值将被覆盖，如hset myhash field1 “foo”</li>
<li>hget:用于返回哈希表中指定字段的值，如hget myhash field1</li>
<li>hexists:用于查看哈希表的指定字段是否存在，如hexists myhash field1</li>
<li>hdel:用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略，如hdel myhash field1</li>
<li>hgetall:用于返回哈希表中，所有的字段和值,返回值里，紧跟每个字段名之后是字段的值</li>
</ul>
<p><code>set</code></p>
<p> set是String类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<ul>
<li><p>sadd:将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略</p>
</li>
<li><p>sinter:返回给定所有给定集合的交集</p>
</li>
<li><p>sunion:返回给定集合的并集</p>
</li>
<li><p>smembers:返回集合中的所有的成员</p>
</li>
<li><p>sdiff:返回给定集合之间的差集，差集的结果来自前面的KEY ,而不是后面的KEY</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key1 &#x3D; &#123;a,b,c,d&#125;</span><br><span class="line">key2 &#x3D; &#123;c&#125;</span><br><span class="line">key3 &#x3D; &#123;a,c,e&#125;</span><br><span class="line">SDIFF key1 key2 key3 &#x3D; &#123;b,d&#125;</span><br></pre></td></tr></table></figure>

<p><code>zset</code></p>
<p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。常见方法：</p>
</li>
<li><p>zadd:用于将一个或多个成员元素及其分数值加入到有序集当中</p>
</li>
<li><p>zrange:返回有序集中，指定区间内的成员，其中成员的位置按分数值递增(从小到大)来排序</p>
</li>
<li><p>zrevrange:返回有序集中，指定区间内的成员，其中成员的位置按分数值递减(从大到小)来排列</p>
</li>
<li><p>zcard:用于计算集合中元素的数量</p>
</li>
<li><p>zrem:用于移除有序集中的一个或多个成员，不存在的成员将被忽略</p>
</li>
</ul>
<h2 id="03-发布订阅模式"><a href="#03-发布订阅模式" class="headerlink" title="03 发布订阅模式"></a>03 发布订阅模式</h2><p><strong>安装及启动redis</strong></p>
<p>安装redis的步骤很简单，去官网安装，直接下一步即可。安装完成之后我们进到redis的目录，启动redis服务就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/be9f4cd4-a6f5-4e94-93ee-fb33a633fb03.png" alt="redis服务已经启动且监听6379端口" title>
                </div>
                <div class="image-caption">redis服务已经启动且监听6379端口</div>
            </figure>

<p><strong>开启redis客户端</strong></p>
<p>我们在该目录下再起两个窗口，一个用来发布消息，一个用来订阅消息。输入<code>redis-cli.exe -h 127.0.0.1 -p 6379</code>就可以进入redis客户端了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/b9f77123-b3bc-4fa3-8d42-f7e815b59f20.gif" alt="左边进行订阅，右边进行发布" title>
                </div>
                <div class="image-caption">左边进行订阅，右边进行发布</div>
            </figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>关于redis的基础知识其实还有很多，这里就不多介绍了。大家平时可以去官网或者菜鸟看一下。最近心生倦意，行文比较匆忙，当品茶一杯以清静心灵，就此落笔。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的Nginx服务器的一些知识</title>
    <url>/2020/04/09/nginx/</url>
    <content><![CDATA[<blockquote>
<p>Nginx服务器是一款高性能的服务器，之前部署网站就使用了它进行反向代理，这次就好好总结Nginx相关的特性与使用。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/09/nginx/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>Nginx服务器是Web服务器，也就是我们平时用来提供Web服务的。我们之前可能听过Apache、Tomcat、IIS等的服务器，其实Nginx和它们都是一样的，都可以通过HTTP为浏览器等客户端提供各种服务。</p>
<p>Nginx服务器是一个跨平台的服务器，可以运行在Window和Linux以及Mac OS等操作系统，它的特点就是可以处理大规模的并发连接。接下来就具体介绍一下。</p>
<h2 id="02-正向代理与反向代理"><a href="#02-正向代理与反向代理" class="headerlink" title="02 正向代理与反向代理"></a>02 正向代理与反向代理</h2><ul>
<li>正向代理，<code>代理客户端</code>，服务端不知道实际发起请求的客户端；</li>
<li>反向代理，<code>代理服务端</code>，客户端不知道实际提供服务的服务端；</li>
</ul>
<p>比如我们访问google.com的时候，是通过正向代理的方式，<code>谷歌服务器是不知道是哪个用户对它进行访问</code>，这就是正向代理；但是假如谷歌服务器压力大，承受不了这么多人访问，用户的请求就会分发到不同的谷歌服务器，<code>用户不知道自己请求的具体是哪一台服务器</code>，这就是反向代理。</p>
<p><strong>正向代理</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/614c2cdf-58ec-41cd-96e5-c758848bca10.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<p><strong>反向代理</strong></p>
<p><img src="https://imgkr.cn-bj.ufileos.com/00240d45-5d32-49e9-982b-0acbe9d8f14d.png" alt></p>
<h2 id="03-Nginx"><a href="#03-Nginx" class="headerlink" title="03 Nginx"></a>03 Nginx</h2><p><strong>Nginx特点</strong></p>
<ul>
<li>响应快</li>
<li>扩展性强</li>
<li>可靠性高</li>
<li>内存消耗少</li>
<li>支持高并发</li>
<li>热部署</li>
<li>免费开源</li>
</ul>
<p><strong>Nginx的使用</strong></p>
<p>我们要为了能够方便地使用Nginx，一般我们都会将它安装在Linux系统上面。所以我们现在服务器上面安装Nginx，只需一行代码就搞定。默认情况之下，nginx会安装在 /etc/nginx目录之下，其中nginx.conf是它的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install  nginx</span><br></pre></td></tr></table></figure>
<p>我们有必要了解一下nginx相关的命令，我们经常会使用，比如启动停止、查看状态等。</p>
<ul>
<li>启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>停止</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>重启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>


<p><strong>Nginx进程</strong></p>
<p>Nginx服务器一般都是使用一个master主进程管理多个worker进程的，而worker进程一般与服务器CPU的核数相等。</p>
<p>master进程是不提供服务的，真正提供服务的是worker进程，worker进程之间通过进程间通信机制实现通信，如负载均衡等。假如worker某进程出错，其余进程将不受影响继续提供服务，master进程也会启动一个新的进程。</p>
<hr>
<p><strong>nginx.conf</strong></p>
<p>nginx的默认配置文件一共有以下几块，分别配置不同的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user nginx;  <span class="comment">#配置用户或者组，默认为nginx。</span></span><br><span class="line">worker_processes 2;  <span class="comment">#允许生成的进程数，默认为1</span></span><br><span class="line">pid /nginx/pid/nginx.pid;   <span class="comment">#指定nginx进程运行文件存放地址</span></span><br><span class="line">error_log <span class="built_in">log</span>/error.log debug;  <span class="comment">#制定日志路径，级别。级别可为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    multi_accept on;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    use epoll;      <span class="comment">#事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    worker_connections  1024;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    default_type  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    log_format myFormat <span class="string">'$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    access_log <span class="built_in">log</span>/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    sendfile on;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    sendfile_max_chunk 100k;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    keepalive_timeout 65;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    upstream mysvr &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333 backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        listen       80;   <span class="comment">#监听端口</span></span><br><span class="line">        server_name  127.0.0.1;   <span class="comment">#监听地址       </span></span><br><span class="line">        location  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           proxy_pass  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           deny 127.0.0.1;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           allow 172.18.5.54; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>全局块</code>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>
<li><code>events块</code>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li><code>http块</code>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li><code>server块</code>：配置虚拟主机的相关参数，一个http中可以有多个server。</li>
<li><code>location块</code>：配置请求的路由，以及各种页面的处理情况。</li>
</ul>
<hr>
<p><strong>反向代理</strong></p>
<p>反向代理用于接收网络上的请求，然后将请求转发到目标服务器，然后目标服务器返回给代理服务器，最后返回给用户。此方法延长了请求时间，但是降低了目标服务器的压力。</p>
<p>反向代理的基本配置：</p>
<ul>
<li><p><code>proxy_pass</code>:将请求代理到当前的服务器，可以是主机名/IP地址+端口形式</p>
</li>
<li><p><code>proxy_methods</code>:表示转发时的协议方法名，如get/post等</p>
</li>
<li><p><code>proxy_hide_header</code>:指定目标服务器返回给代理服务器的响应中，代理决定哪些头不转发给客户端,值为响应头</p>
</li>
<li><p><code>proxy_pass_header</code>:与上面相反，表示哪些头允许转发给客户端</p>
</li>
<li><p><code>proxy_pass_request_body</code>:是否向目标服务器发送HTTP包实体部分，值为on/off</p>
</li>
<li><p><code>proxy_pass_request_headers</code>:是否向目标服务器发送HTTP头，值为on/off</p>
</li>
<li><p><code>proxy_redirect</code>：如目标服务器返回301/302重定向，那么就会重设location或者refresh字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_redirect http:&#x2F;&#x2F;localhost:8000&#x2F;two&#x2F;</span><br><span class="line">      http:&#x2F;&#x2F;frontend;</span><br></pre></td></tr></table></figure>
<p>如果请求<code>http://localhost:8000/two/uri/</code>在返回重定向的情况下，实际上转发给客户端的就是<code>http://frontend/uri</code>,值为off则将使location或者refresh字段维持不变</p>
</li>
<li><p><code>proxy_next_upstream</code>：表示目标服务器转发请求发生错误，换一台目标服务器处理这个请求</p>
</li>
</ul>
<hr>
<p><strong>负载均衡</strong></p>
<p>实现负载均衡最关键的模块就是upstream模块，服务器就写在里面的server字段，对应着不同的服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream <span class="built_in">test</span> &#123;</span><br><span class="line">        server xx.xxx.xxx.xx   weight:5;</span><br><span class="line">        server xx.xx.xx.xx   max_fails=3 fail_timeout=30s;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://<span class="built_in">test</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的意思就是当你请求根路径的时候就会代理到upstream里面的两个服务器，以此来实现负载均衡的功能。</p>
<p><strong>server</strong>配置选项：</p>
<ul>
<li><code>weight</code>:向这台服务器转发的权重，默认是1</li>
<li><code>max_fails</code>:与fail_timeout配合使用，如果在fail_timeout时间内的转发次数超过max_fails的数量，代表该服务器不可用。max_fails默认是1，设为0则不检查次数</li>
<li><code>dowm</code>:服务器下线，只会在ip_hash配置项时才有用</li>
<li><code>backup</code>:表示该服务器只是备份的，当其他的服务器失效之后才转发给它,有ip_hash配置项时无效</li>
</ul>
<p><strong>upstream</strong>配置选项：</p>
<ul>
<li><code>ip_hash</code>:解决同一用户在不同的服务器中缓存相同的信息，与weight不可同时使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream <span class="built_in">test</span> &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server xx1.xxx.xxx.xx;</span><br><span class="line">        server xx2.xx.xx.xx;</span><br><span class="line">        server xx3.xx.xx.xx;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://<span class="built_in">test</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>通过对Nginx服务器的一些理解，会让我们知道一些网络上的知识，如正向代理与反向代理的区别、负载均衡的实现等。</p>
<p>大家也可以尝试着使用nginx服务器进行一些配置，上面只是一些简单的配置模块，如果想要详情的理解去官网看一下。对于前端来说，懂基本的就可以，不用像运维那样精通所有的配置，当然学有余力最好不过了，奈何自己学习能力有限，以后再详解其中的一二。</p>
<p><img src="/2020/04/09/nginx/2.gif" alt></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>总结ES6中Set和Map数据结构的区别</title>
    <url>/2020/04/08/setAndMap/</url>
    <content><![CDATA[<blockquote>
<p>面试官：你说一下ES6中的数据结构set和map吧！除了这个你还知道WeakSet和WeakMap吗？</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/08/setAndMap/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>我们刚开始学习ES6的时候肯定会对这两种数据结构感到奇怪，甚至想着这两种数据结构有什么用呀？难道我们平时的栈和队列不够用吗？</p>
<p>处于一开始没法理解的我们肯定是先背为敬。当我们逐渐接触的多了，想着数组去重的简便写法的时候这个Set又重新出现在我们的面前。原来这个Set是一个集合，高中我们就学过，集合具有唯一性的特点，这才明白了Set的用意。而Map表面上是地图的意思，地图本就有一一对应的特点，就如我们的字典一样，就是字典的数据结构。</p>
<h2 id="02-Set"><a href="#02-Set" class="headerlink" title="02 Set"></a>02 Set</h2><p>Set数据结构是一个类似于数组，但是与数组不同的是它具有唯一性，里面的元素都是不重复的，而且他本身也是一个构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SetArr = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>].forEach(<span class="function"><span class="params">item</span>=&gt;</span>SetArr.add(item));</span><br><span class="line"><span class="built_in">console</span>.log(SetArr);</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line"><span class="number">1</span>: <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: <span class="number">3</span></span><br><span class="line">size: <span class="number">3</span></span><br><span class="line">__proto__: <span class="built_in">Set</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，打印出来的SetArr就变成了唯一的元素了，而且它也具有长度且还有原型，出于好奇我们就打开原型看一下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/1b0f852d-9afa-496f-8044-898d27846620.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>不出我们所料，它具有一系列的方法，比如我们刚刚使用的add方法都在里面。我们具体来解释一下每个属性和方法：</p>
<p><strong>实例属性</strong></p>
<ul>
<li>constructor：构造函数，就是Set函数</li>
<li>size：返回的是set实例的长度</li>
</ul>
<p><strong>实例方法</strong></p>
<ul>
<li>add(value):往Set里面添加值，返回Set本身</li>
<li>delete(value)：删除某个值，返回布尔值判断是否成功</li>
<li>has(value):判断是否含有value值，返回布尔值</li>
<li>clear():清除Set里面的所有值，无返回值</li>
</ul>
<p><strong>遍历方法</strong></p>
<p>Set数据结构也提供了4个遍历方法，可用于遍历里面的成员</p>
<ul>
<li>forEach():使用回调函数遍历元素</li>
<li>entries():返回键值对的遍历器,用于遍历[键名，键值]组成的数组</li>
<li>values():返回键值遍历器,用于遍历所有键值</li>
<li>keys():返回键名遍历器,用于遍历所有键名</li>
</ul>
<p>看一下我们好像找不出他们的却别，接下来举一个小例子，大家就会明白的。由于Set结构是只有键值的结构，所有keys方法与values方法返回一致。</p>
<p><code>forEach</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(item+<span class="number">1</span>)&#125;)</span><br><span class="line"><span class="comment">//2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<p><code>entries</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s.entries())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) [<span class="string">"a"</span>, <span class="string">"a"</span>]</span><br><span class="line">(<span class="number">2</span>) [<span class="string">"b"</span>, <span class="string">"b"</span>]</span><br><span class="line">(<span class="number">2</span>) [<span class="string">"c"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure>

<p><code>values</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s.values())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p><code>keys</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s.keys())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p><strong>使用Set结构实现交并差</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Sect([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">item</span>=&gt;</span>b.has(item)));</span><br><span class="line"><span class="comment">//并</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="keyword">new</span> <span class="built_in">Set</span>([...a],[...b])</span><br><span class="line"><span class="comment">//差</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">item</span>=&gt;</span>！b.has(item)));</span><br></pre></td></tr></table></figure>

<h2 id="03-WeakSet"><a href="#03-WeakSet" class="headerlink" title="03 WeakSet"></a>03 WeakSet</h2><p>从字面上的意思看来，它是一个弱的Set结构，具体的弱体现在WeakSet的成员只能是对象，还有一个就是WeakSet的对象都是弱引用，即<code>垃圾回收机制不考虑WeakSet对该对象的引用</code>。也就是说WeakSet里面的引用都不计入垃圾回收机制。</p>
<p>除了定义不同之外，WeakSet<code>没有size属性</code>，也<code>不可以进行遍历操作</code>，因为它随时会消失，成员不适合引用。如果垃圾回收机制运行过后，成员个数可能不一样。</p>
<p><strong>方法</strong><br>由于它不可以进行遍历操作，所以遍历的方法都没有了，只有实例方法。</p>
<ul>
<li>add():向WeakSet添加新成员</li>
<li>delete():删除WeakSet的成员</li>
<li>has():判断WeakSet是否含有某个元素</li>
</ul>
<h2 id="04-Map"><a href="#04-Map" class="headerlink" title="04 Map"></a>04 Map</h2><p>上面我们讲到的Set结构是没有键的只有值，而Map结构是键值的组合，这里就解决了我们以往只能使用字符串作为键的限制。也就是说我们可以使用各种的数据类型（或者对象）作为键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'alan'</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;;</span><br><span class="line">map.set(obj,<span class="string">'这是一些描述'</span>);</span><br><span class="line">map.get(obj);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br></pre></td></tr></table></figure>
<p>我们同样也可以打印一下map里面到底有什么内容，除了与Set一样的方法之外，我们可以看到多了get和set方法。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/383ffce0-fe1a-4fb5-9896-7b2f45d6e7aa.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>属性</strong></p>
<ul>
<li>constructor：Map构造函数</li>
<li>size：Map元素长度</li>
</ul>
<p><strong>实例方法</strong></p>
<ul>
<li>set(key, value):设置key所对应的value值</li>
<li>get(key):获取key所对应的value值，若无则undefined</li>
<li>has(key)：是否含有某个键</li>
<li>delete(key):删除某个键，如删除失败返回false</li>
<li>clear():清除所有成员</li>
</ul>
<p><strong>遍历方法</strong></p>
<ul>
<li>forEach():使用回调函数遍历成员</li>
<li>entries():返回所有成员遍历器</li>
<li>keys():返回键名遍历器</li>
<li>values():返回键值遍历器</li>
</ul>
<p><code>entries</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>,<span class="string">'alan'</span>],[<span class="string">'age'</span>,<span class="string">'20'</span>]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> person.entries())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/7a22019c-3a0e-4fdf-9980-04f7e394b6c1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><code>keys</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>,<span class="string">'alan'</span>],[<span class="string">'age'</span>,<span class="string">'20'</span>]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> person.keys())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br></pre></td></tr></table></figure>

<p><code>values</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>,<span class="string">'alan'</span>],[<span class="string">'age'</span>,<span class="string">'20'</span>]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> person.keys())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alan</span></span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p><code>与其他数据结构转换</code></p>
<ul>
<li>Map转数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>,<span class="string">'alan'</span>],[<span class="string">'age'</span>,<span class="string">'20'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(...person)</span><br><span class="line"><span class="comment">//[['name','alan'],['age','20']]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组转Map</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="string">'name'</span>,<span class="string">'alan'</span>],[<span class="string">'age'</span>,<span class="string">'20'</span>]];</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(arr);</span><br><span class="line"><span class="comment">//Map(2) &#123;"name" =&gt; "alan", "age" =&gt; "20"&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Map转对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>,<span class="string">'alan'</span>],[<span class="string">'age'</span>,<span class="string">'20'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">map</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">    obj[key]=value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line">swap(person);</span><br><span class="line"><span class="comment">//&#123;name: "alan", age: "20"&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象转Map</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person =&#123;<span class="string">'name'</span>:<span class="string">'alan'</span>,<span class="string">'age'</span>:<span class="string">'20'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;</span><br><span class="line">    map.set(key,obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line">swap(person);</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://imgkr.cn-bj.ufileos.com/5204fd4d-e664-4aa7-9d4e-a89a3dbe1a54.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="05-WeakMap"><a href="#05-WeakMap" class="headerlink" title="05 WeakMap"></a>05 WeakMap</h2><p>WeakMap与Map一样可以生成键值对的集合，但是也有不同的地方，主要是有以下的两点：</p>
<ul>
<li>WeakMap只接受对象作为键名（不包括null）</li>
<li>键名所指向的对象不计入垃圾回收机制</li>
</ul>
<p>与WeakSet相似，WeakMap也是没有遍历的操作，也没有size属性，没有办法列出所有键名（由于垃圾回收机制的运行），也不能清空。</p>
<p><strong>实例方法</strong></p>
<ul>
<li>get()</li>
<li>set()</li>
<li>has()</li>
<li>delete()</li>
</ul>
<h2 id="06-小结"><a href="#06-小结" class="headerlink" title="06 小结"></a>06 小结</h2><p>通过这一次的总结，大家应该对这几种数据结构有了大概的认识，也知道他们之间的不同。之前我们学习的时候往往会忽略WeakSet和WeakMap的理解，也不知道它们与垃圾回收机制的关系。正是以你为弱引用的关系，使得这两个数据的结构可以用于避免内存泄露的情况。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/08/setAndMap/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>数据结构</tag>
        <tag>Set</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用番茄工作法学习与工作</title>
    <url>/2020/04/06/studyMethods/</url>
    <content><![CDATA[<blockquote>
<p>很多小伙伴都说自己明明花费了大量时间，却总是没有完成自己任务，试一下番茄工作法吧！</p>
</blockquote>
<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>做技术的时间总是那样宝贵，而且每天完成的事情都必须要要有一定的质量保证。除了在工作中的时间安排妥当，每天完成工作上的任务安排，还需要<code>自己充电，坚持学习</code>。</p>
<p>其实到这里大家应该觉得有点奇怪了，我每天除了完成公司安排的工作，根本没有什么时间学习了，那可怎么办呢？其实我们不排除是因为公司的加班那问题，但我觉得时间的安排上面自己也要做出一点改变。</p>
<p>自己最近也是在想着，很多人觉得自己满满一天的学习时间，为何自己的进度没有提上来，甚至有点效率低下。甚至自己连娱乐的时间都被自己认为是浪费时间，应该把更多的时间放在学习上面，这样真的好吗？</p>
<h2 id="02-改变思维"><a href="#02-改变思维" class="headerlink" title="02 改变思维"></a>02 改变思维</h2><p>其实我们想一下，不是我们时间安排少了，而是时间的安排不对，你自己是不是从起床一直学到中午？是不是把娱乐的时间都交给了学习？</p>
<p>假如自己是这样的，不妨试一下接下来我介绍的番茄工作法，可能一开始没有很大的效果，但是请坚持一周左右，你就会有不一样的感想。</p>
<h4 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h4><p>其实这是一个在很早之前就发明的，但是由于它的核心太过于简单而导致很多人都不屑，也不相信其中的奥秘。</p>
<p><strong>基本思路</strong><br>规划一天之内要完成的事情，把一天的时间进行分块，每一块的时长为25分钟。在25分钟之内必须是心无旁骛地专心在一件事情上面，不能被别人打扰。</p>
<p><strong>工作流程</strong><br>把一天的时间分成多个25分钟，然后完成第一个25分钟之后就休息5分钟，这就是一个“番茄钟”。当你完成4个番茄钟之后，你就休息15分钟。</p>
<h4 id="如何实践"><a href="#如何实践" class="headerlink" title="如何实践"></a>如何实践</h4><p>正如一开始我说的那样，其实当你刚开始的时候，你会觉得效果微乎甚微以至于你觉得没有价值。那么你该如何做呢？</p>
<ul>
<li>先开始行动，习惯番茄工作法</li>
<li>不关注完成多少番茄钟</li>
</ul>
<p>当你尝试去运用这种方法，那么你就从小的任务开始做起，然后当你习惯之后便可以根据自己任务安排每天要完成多少个番茄钟。</p>
<p>番茄工作法可以让你记录每一天的任务，记录自己完成任务的数量，让你更加专注事情，让你的努力可以看得到。</p>
<h2 id="03-改变心态"><a href="#03-改变心态" class="headerlink" title="03 改变心态"></a>03 改变心态</h2><p>其实番茄工作法的另一个作用就是可以改变你的心态，心态对于学习和工作及其重要，当你心情焦虑与烦躁，你还会专注学习吗？</p>
<h4 id="为何自己焦虑"><a href="#为何自己焦虑" class="headerlink" title="为何自己焦虑"></a>为何自己焦虑</h4><p>明明自己已经安排了大部分时间来学习，为什么自己还会为了学习而焦虑？其实很简单，你看不到自己的任务完成情况，也就是没有量化自己的任务，虽然时间投入很多，但是你不知道花在具体的哪个地方上面。</p>
<p>你会有一个问题一直困扰着你，总为自己<code>没有完成更多的事情而感到内疚</code>，就好像自己永远与娱乐这种放松活动无缘，以至于自己坐下来玩游戏、看视频都无法享受，认为是罪恶的。一般你就会出现这些情况：</p>
<ul>
<li>不敢娱乐</li>
<li>自我怀疑</li>
<li>恶性循环</li>
</ul>
<h4 id="如何改变"><a href="#如何改变" class="headerlink" title="如何改变"></a>如何改变</h4><p>尝试把自己的时间进行分块，然后尝试把你的任务进行分块，通过番茄工作法，在专注的时间完成你的一小部分任务，然后如此循环往复，让你的任务完成量看得到。</p>
<ul>
<li>专注25分钟，休息5分钟</li>
<li>设定一天的番茄钟</li>
<li>习惯番茄工作法</li>
</ul>
<p>其实这只是一些建议，最主要的目的就是让你<code>受惠于番茄工作法</code>。因为你除了完成工作上的或者学习上的任务之外，还能让自己有更多的其他时间，用来做自己的事情，游戏/电影/活动等。</p>
<p>当你习惯过后你会觉得自己的工作生活观改善极大，可以让你在有限的时间做更多的事情，并且最重要的是不会让你的享受时间感到内疚。举个例子，你完成了当天的番茄钟（提前计划好），然后还剩下时间你可以做更多的工作，或者你用来娱乐（打游戏/看电影）都不会感到内疚，甚至会有一点自豪。</p>
<p>番茄工作法能让你成长更多：</p>
<ul>
<li>提高工作/学习效率</li>
<li>改变自己的心态</li>
<li>让自己更加专心</li>
</ul>
<p><strong>好消息</strong></p>
<p>让你能够保持关注，度过充实的一天，完成比平时多的任务量</p>
<p><strong>坏消息</strong></p>
<p>你需要一段的时间才可以适应，并且你要做到多个番茄钟的专注时间是非常困难的，可能与自己的预想不一样</p>
<h2 id="04-无法专注？"><a href="#04-无法专注？" class="headerlink" title="04 无法专注？"></a>04 无法专注？</h2><p>很多上班族都会说，自己的办公室从来没有一个专注的环境，一会别人会过来打断你的思考，一会别人问你事情……</p>
<p>假如你一直在这种环境工作，那你应该是不如意的，是时候与别人沟通一下，告诉他们你的工作时间和专注时间，要是不着急的话尽量让你完成一个番茄钟之后再做安排。</p>
<p>其实我们大家都知道，在一个可以专注的时间下进行学习，你会有更高的效率，这也是为什么别人工作的时候更喜欢一个人的空间，因为那样可以让自己的全身心投入。</p>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><p>其实番茄工作法的原理就是为了让大脑有足够的休息时间，在自己在一个轻松的环境之下进行工作或者学习。</p>
<h4 id="适合人群"><a href="#适合人群" class="headerlink" title="适合人群"></a>适合人群</h4><p>很多人可能就说了，我一个程序员天天加班，需求一个接着一个，哪有什么时间专注25分钟。其实这也不能否认你的想法，虽然无法保证所有的时间都是准确细分，但是起码你能够在非工作时间，学习充电时间运用，假如你还是在校学生或者不加班的，那么这种方法非常适合你们。</p>
<h4 id="设定周目标"><a href="#设定周目标" class="headerlink" title="设定周目标"></a>设定周目标</h4><p>可能有人认为自己一天的时间完成不了什么有价值的任务，一天工作时间8小时，理论上可以完成16个番茄钟，但是实际上是很吃力的。</p>
<p>那么尝试把自己的时间放长，以一周的时间为分块，看一下自己到底可以完成多少个番茄钟。假如自己可以完成目标了，那么下一次你就可以尝试把一周的番茄钟进行增多，以此激励自己完成更多的任务，提高自己的学习效率。</p>
<ul>
<li>完成目标：持续改进</li>
<li>超出目标：享受生活</li>
<li>低于目标：调整时间</li>
</ul>
<p>一开始试着使用番茄工作法，不在乎自己完成多少个目标，只求自己能够适应这种工作法。通过对自己的不断探索，对自己的不断了解，你就可以知道自己到底适合怎么样的工作量，制定独一无二的时间表即可。</p>
<p>那么以后你就有理由来玩游戏、煲剧等娱乐行为，做到完成任务且享受生活，岂不美哉！</p>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
        <tag>番茄工作法</tag>
        <tag>时间安排</tag>
      </tags>
  </entry>
  <entry>
    <title>Web网站性能系统总结与分析</title>
    <url>/2020/04/05/webAnalyze/</url>
    <content><![CDATA[<h2 id="浅谈传输层协议的优化方案"><a href="#浅谈传输层协议的优化方案" class="headerlink" title="浅谈传输层协议的优化方案"></a>浅谈传输层协议的优化方案</h2><blockquote>
<p>近年来web性能优化越来越重要，用户体验很大程度与高性能相关</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/05/webAnalyze/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>现在的前端开发已不再局限于页面的编写，我们现在已经进入了一个性能优化的阶段。很多现象都明确表明，只有你的网站速度够快，性能最优，用户的转化率就会越高，用户的忠诚度也会越高。所以为了解决网站性能优化的瓶颈，我们需要从头开始进行性能的分析。今天我们来聊一下如何进行web方面的性能分析，因为最近也在阅读关于web性能方面的知识，特此发文总结一下。</p>
<h2 id="02-网络的概述"><a href="#02-网络的概述" class="headerlink" title="02 网络的概述"></a>02 网络的概述</h2><hr>
<h3 id="延迟与带宽"><a href="#延迟与带宽" class="headerlink" title="延迟与带宽"></a>延迟与带宽</h3><h6 id="延迟时间组成"><a href="#延迟时间组成" class="headerlink" title="延迟时间组成"></a>延迟时间组成</h6><ul>
<li>延迟指的就是从发送源到接收源经历的时间</li>
<li>带宽指的就是逻辑或物理路径最大的吞吐量</li>
</ul>
<p>从发送源开始到接收源，中间可能经过很多的基站或者运营商等，那么延迟到底由哪些部分组成呢？从客户端到服务端之间历经的过程会涉及到以下的延迟：</p>
<ul>
<li>传播延迟：从发送端到接收端的时间，是传播距离与速度的关系</li>
<li>传输延迟：传输的信息转移到链路中需要的时间，是消息长度与链路速率的关系</li>
<li>处理延迟：处理分组首部、检查位错误以及确定分组目标所需的时间</li>
<li>排队延迟：到来的分组排队等待的时间</li>
</ul>
<p>之前我们介绍过CDN的原理，就是让用户从最近的服务器加载内容，大幅度降低传播分组的时间，在距离与时间的选择当中，我们选择缩短距离的方式来减少加载时间。</p>
<p>其实我们应该明白，造成用户加载时间过慢的原因不是带宽的问题，而是延迟的问题。比如从中国请求美国的网站，中间花的时间不是横跨大洋或者大陆产生的，而是你当前接收的地址（一般是家或者办公室）与最近的服务运营商之间的连接，中间可能会经过多个路由器，路由器进行网络数据的分发，最终才会与运营商连接起来。</p>
<p>在linux平台上可以使用traceroute 命令最终信息的传输过程，计算每一跳所需要的时间，window就通过tracert命令。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/05/webAnalyze/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h6 id="高带宽与低延迟"><a href="#高带宽与低延迟" class="headerlink" title="高带宽与低延迟"></a>高带宽与低延迟</h6><p>由于人们对视频的需求增长迅速，所以我们提高传输的带宽是非常有必要的，比如部署更多的光纤、拥塞路由之间改善链路、或者使用光纤波分复用（WDN）等技术来让现有的硬件设备传输更多的数据。</p>
<p>WDN:波分复用(WDM)是将两种或多种不同波长的光载波信号(携带各种信息)在发送端经复用器(亦称合波器)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器(亦称分波器或称去复用器)将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。这种在同一根光纤中同时传输两个或众多不同波长光信号的技术,称为波分复用</p>
<p>除了提高带宽，我们也可以利用减少延迟的方式改善，可以让光信号传输的速率更接近光速，如采用折射率更低的材料、速度更快的路由器或者中继器。上面我们就提到过其实信息分组的传输中，延迟是最难以解决的。</p>
<h3 id="TCP的具体构成"><a href="#TCP的具体构成" class="headerlink" title="TCP的具体构成"></a>TCP的具体构成</h3><h6 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h6><p>我们这两种协议并不陌生，IP协议（因特网协议），负责联网主机之间的路由选择与寻址；TCP协议（传输控制协议），负责不可靠的传输信道之上提供可靠的抽象层。对于信息传输的过程中发生的事情，如丢包、拥塞控制等隐藏，所以在优化的时候我们可能会有一些挑战。</p>
<h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><p>在客户端与服务器进行应用数据交换之前进行操作。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/05/webAnalyze/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>在三次握手阶段其实是比较耗费性能的，因此我们想要优化网络也可以从这一方面下手，任何两段数据想要通过TCP传输，那么握手就是必不可少的阶段。谷歌的开发人员研究出一种TCP Fast Open的技术，通过客户端连接时附加一个Cookie（一个TCP选项，此Cookie通常采用一种分组密码，私钥由服务器根据客户端的IP地址保存）来验证是否之前就连接过，如果成功则可以在服务器收到第三个包之前就发送数据。</p>
<h6 id="拥塞控制及预防"><a href="#拥塞控制及预防" class="headerlink" title="拥塞控制及预防"></a>拥塞控制及预防</h6><ul>
<li>流量控制</li>
</ul>
<p>流量控制是一种预防发送端向服务端发送过多数据的一种机制。如果超过了接收端的接收量，可能会造成负载重而处理不过来的情况。每一方都要向对方告知自己的接收窗口，确保能够开辟一个数据缓冲区接收对方的信息。</p>
<ul>
<li>慢启动</li>
</ul>
<p>慢启动出现的原因其实就是连接刚建立的双发都不知道网络中可用的带宽是多少，必须要有一个估算的机制，而且这个机制还要随着网络传输的带宽而进行动态变化。我们不可能一上来就完全利用连接的最大带宽，都需要慢慢地传输数据信息以防止网络拥堵。</p>
<ul>
<li>拥塞预防</li>
</ul>
<h6 id="队首阻塞"><a href="#队首阻塞" class="headerlink" title="队首阻塞"></a>队首阻塞</h6><p>我们都知道TCP有顺序交付的特点，从一开始的确认应答机制到滑动窗口的机制，前者是只有确认前一个包才可以进行下一个包的发送，后者是允许你发送一定数量的包到接收端，但假如有一个包接收端一直收不到，那就必须停止后面包的发送，重发丢失的包。</p>
<h6 id="TCP优化建议"><a href="#TCP优化建议" class="headerlink" title="TCP优化建议"></a>TCP优化建议</h6><p>要对TCP进行优化，必须要最大限度地利用底层协议的原理，其原理性的东西无非就是以下的几点：</p>
<ul>
<li>三次握手就是一次往返时间</li>
<li>慢启动在每个连接中都应用</li>
<li>流量控制和拥塞控制会影响到所有连接的吞吐量</li>
<li>吞吐量由当前拥塞窗口大小控制</li>
</ul>
<p><strong>服务器调优</strong></p>
<ul>
<li>增大TCP的初始化拥塞窗口</li>
<li>慢启动重启</li>
<li>窗口缩放</li>
<li>TCP快速打开</li>
</ul>
<p>通过进行服务器的最优调整，把主机的操作系统升级到最新版本，可以确保每个TCP连接都具有较低的延迟和较高的吞吐量。</p>
<p><strong>应用程序行为调优</strong></p>
<ul>
<li>数据能不发就不发</li>
<li>使用CDN让传输距离变短</li>
<li>复用TCP连接</li>
</ul>
<p>请求的影响因素就是减少请求与压缩体积，通过减少一些不必要的数据传输和减少传输距离，能够使应用程序的行为最优。</p>
<p><code>小结</code></p>
<ul>
<li>升级服务器内核版本</li>
<li>拥塞窗口大小为10</li>
<li>禁用空闲后的慢启动</li>
<li>确保启动窗口缩放</li>
<li>减少传输冗余数据</li>
<li>压缩传输的数据</li>
<li>服务器放到离用户最近的地方（CDN）</li>
<li>重用TCP连接</li>
</ul>
<h3 id="UDP的优化"><a href="#UDP的优化" class="headerlink" title="UDP的优化"></a>UDP的优化</h3><p>由于UDP是一种简单的协议，它的高效性正是因为它忽略了很多TCP的特性，但是由于这样的高效性，可能也会造成麻烦。举个例子来说，当你看视频的时候假如没有经过拥塞处理，可能会占用大量的带宽，导致一些正常的TCP连接无法发送正常的数据，如网页也可能无法打开。另一种情况也有可能造成视频一直卡顿，无法加载。</p>
<p>所以我们针对这种情况必须进行有效的处理，根据RFC的文档，主要有几种优化方案。</p>
<ul>
<li>控制传输速度</li>
<li>对所有的流量进行拥塞控制</li>
<li>使用与TCP相近的带宽</li>
<li>处理数据包丢失、重复和重排</li>
</ul>
<p>以上的优化必须是应用程序做出的优化。</p>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>上面我们讨论了如何进行对传输层两个协议的优化，以及中间的细节性东西，可能还有很多没有讲到，但是把主要的几个点都大概说了一下，也对其中的几个点有所了解。</p>
<p>前端与网络的关系大家都知道，理解TCP的核心机制已经是web优化的必修课，我们在项目中一般不会深入到链路物理层面进行优化，但是应用层的优化我们还是可以做的。</p>
<p><img src="/2020/04/05/webAnalyze/2.gif" alt=" "></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能分析</tag>
        <tag>网站性能</tag>
        <tag>高性能</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>我们应该如何编写高质量的前端代码</title>
    <url>/2020/04/04/howToMakeHightLevelCode/</url>
    <content><![CDATA[<h2 id="我们应该如何编写高质量的前端代码"><a href="#我们应该如何编写高质量的前端代码" class="headerlink" title="我们应该如何编写高质量的前端代码"></a>我们应该如何编写高质量的前端代码</h2><blockquote>
<p>编写高质量代码是每一个程序员必备的技能之一，可以有效地进行项目的维护以及项目的合作开发</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/04/howToMakeHightLevelCode/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>这要从很久的事情开始说起，前端最初的发展就像一团浑浊的云团，什么都往一块写，然后东拼西凑，最后竟然能运行。其实每个人前端人都会对页面的混杂感到头疼，谁不想好好优化一下呢？但是奈何那会没有成型的工具，更没有现在高质量的组件库，从此解放了我们的代码编写，真正做到了开箱即用，它不香吗？</p>
<p>从最初发展到现在，代码无非就是进行了高度的解耦，让每一个部分都负责自己的内容，把结构、样式与行为分离，使得代码的职能非常清晰，看什么都舒服。所以后来很多前端都要求把自家的网站进行重构，毕竟谁也不想接手上一代遗留下来的产品，自己重新写一套都比他们的要舒服。</p>
<h2 id="02-代码维护难点"><a href="#02-代码维护难点" class="headerlink" title="02 代码维护难点"></a>02 代码维护难点</h2><hr>
<p>为什么说前端的代码难以维护呢？其实主要是出于以下的三点：</p>
<h5 id="浏览器层面"><a href="#浏览器层面" class="headerlink" title="浏览器层面"></a>浏览器层面</h5><p>浏览器是我们前端人经常打交道的工具，其实是浏览器孕育了前端这个大家庭，也是我们生存的根本。假如用户不需要看东西，不需要进行交互，或者我们就不需要存在了。不知道大家是否了解过全息投影？等到那项技术普及的时候，我们又是做着什么样的工作呢？</p>
<p>虽然现在浏览器的兼容性越来越好，主流的浏览器一般都会兼容很多css属性，最起码常用的、多人使用的你是一定要支持的，像flex布局这种神仙属性。当我们习惯于使用某一个浏览器（如谷歌）之后，再尝试使用360浏览器，你会发现自己根部看不下去。就像你习惯于使用谷歌搜索，但是要你使用百度一样的道理。</p>
<p>所以前端浏览器之间的兼容是我们必须要跨过的一道坎，即使现在的兼容性越来越好，但是用户群体也有很多使用IE或者360浏览器的，我们也不能忽略他们的使用。可是有一句话说，兼容IE就是浪费生命，自己细品一下。</p>
<h5 id="技术层面"><a href="#技术层面" class="headerlink" title="技术层面"></a>技术层面</h5><p>由于每一家的公司使用的技术都不太一样，事实上很多公司都会有自己内部的框架，我们要使用他们内部的框架与现有的技术框架结合在一起，那也是一件很头疼的事情。即使你是一位刚跳槽进来的员工，也是要学习他们内部的技术框架你才可以进行项目的开发。</p>
<p>很多公司创立阶段的时候可能vue、react等神仙框架还没出来，就是jQuery的天下，我们的项目底层也不是一朝一夕就能改变的，所以很多公司即使知道了新技术的出现，也不会去使用，也是处于探索阶段。假设公司需要使用一种新技术进行代码的重构，也可能因为员工对新技术的理解还不够深刻，写出的代码也会存在一定的设计漏洞。所以理解不深，就很容易写出难以维护的代码，给我们的团队造成阅读困难，最终也会变成一个难以维护的项目。</p>
<h5 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h5><p>团队合作才是真正的难题，不像我们自己编写的项目，想怎么写都行，不怕有看不懂的时候。当我们提交代码的时候也是不用经过其他成员的同意，直接push到master分支。这些都是我们个人开发的时候做法，到了公司层面或者项目的层面，那你就直接收拾东西吧。</p>
<p>大型的项目一般开发人员是比较多的，每一个人都会负责不同的模块和不同的功能，每一个人都会有自己独立的分支，代码合并到主分支的时候还得经过审核，这是一个完善、系统的开发流程。所以项目越复杂，团队合作的要求就会越高。一般我们都会有一种代码开发规则，大家都应该相互遵守，不然我们就会污染正常的代码，导致项目难以维护。所谓团队合作的最大困难不是技术，是人。</p>
<p>小结：</p>
<p>除了我们要项目的代码进行解耦，把结构、样式与行为进行分离之外，我们还应该重视简洁、可复用以及结构化的特点。当你能够做到这些的时候，你的项目就会显得专业，代码的可维护性以及可扩展性就会越高，开发人员添加新的功能或者模块就会显得比较轻松。</p>
<h2 id="03-高质量结构代码"><a href="#03-高质量结构代码" class="headerlink" title="03 高质量结构代码"></a>03 高质量结构代码</h2><hr>
<h5 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h5><p>HTML5出来之后，添加了很多新的标签和属性，而语义化这个概念就出现在前端人的眼中。之前我们编写结构代码的时候一般会选择使用div与类名/ID名的方式来命名一个模块，所谓DIV+CSS开发模式就是这样由来。那么这种方式可否可行呢？当然是可行的，而且别人用的很舒服，就是cv操作多了点。</p>
<p>当然缺点是有的，比如最主要的就是结构不清晰，无论是编写导航还是模块、亦或是底部，全程div。这样结构就不清晰了，如果没有加以类名或者ID名，根本不知道你写的代码是属于哪一个模块。而且还有一点就是对搜索引擎不友好，不能准确识别你的网站结构和信息。</p>
<p>那么如何看你的代码是否语义化呢？很简单，把所有的样式都去掉，看你的页面结构是否显示正常，一般语义化的标签都会有默认的样式。如果显示还可以，结构有序就是语义化比较好了，反之你就重新写一下吧。</p>
<h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>模块化其实就是跟在语义化之后的，如果你的语义化做的比较好，那么相应的模块化就比较好了。我认为模块化的重点应该关注你的标签选择是否合理，比如文字就使用p/span标签，标题应该使用H1-6标签等。不能所有的文字都是用div这个万能的标签元素，能用p的就不要去用div，因为p本身是针对文字的，有一定的基础样式。</p>
<p>小结：</p>
<p>不过现在我们似乎不会关注这些东西了，因为有了高颜值组件库的出现，需要什么直接cv过来使用。但是我们注意的是，并不是说这样你就逃避学习的理由，因为无论是多高大上的组件都是由最基本的样式和结构组成的，学会背后的造轮子思想才是最重要的。当组件不能满足业务上的需求的时候，就需要你进行css代码的编写了。</p>
<h2 id="04-高质量样式代码"><a href="#04-高质量样式代码" class="headerlink" title="04 高质量样式代码"></a>04 高质量样式代码</h2><hr>
<h5 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h5><p>一般面试或多或少都会问一下你关于css盒子模型的理解，如果没有准备的小伙伴可能会把内容搞混了。这里再重复一遍：</p>
<ul>
<li>IE：元素的宽度由width+border+padding组成</li>
<li>标准：元素的宽度就是width，本身包括了padding+border</li>
</ul>
<h5 id="样式组织"><a href="#样式组织" class="headerlink" title="样式组织"></a>样式组织</h5><p>关于我们页面的样式如何编写，也是我们要考虑的一个问题，我们关于样式的编写没有对错只有好坏。页面写出来，能够满足自己的期望那就是对的样式，是否合理又是另一方面的事情了。</p>
<p>所以这里可以参考一下样式的结构组织：reset.css+common.css+view.css</p>
<p>首先第一个是基本的样式标准，专注于底层的样式。这里的reset是指我们把浏览器默认的基本样式都重置一下，尽量满足所有的浏览器样式看起来是一致的。还记得我们之前说过通配符*吗？那是一个及其暴力的样式重置，但也是很危险的一个操作符。危险是因为需要遍历页面所有的元素节点，给他加上样式。这里我们就推荐使用网上的reset.css即可，都有很多供你选择，假如你懒得找且项目支持npm安装，直接npm i reset-css即可，简单快速方便。</p>
<p>common.css是指一些组件相关的样式，比如我们们如果在vue里面写代码的话就知道一个vue文件可以由三部分组成，其中一个部分就是可以让你编写属于组件的样式代码，这里我们重用组件的时候就会显得非常方便。关于view.css其实就是一个更高层次的编写，属于一个页面的样式文件。</p>
<h5 id="选择器使用"><a href="#选择器使用" class="headerlink" title="选择器使用"></a>选择器使用</h5><p>选择器可对某一个节点进行样式编写，有同学可能会说，我能把我的节点样式应用成功就好，还需要关心它怎么使用吗？其实要的，我们先从css选择器的匹配方案说起，选择器是从右向左进行匹配的，.class ul li a p这样的选择器，会先从全局匹配p标签然后再匹配a标签，依次类推。</p>
<p>所以第一个问题就是我们一定要避免选择器的嵌套过深，因为很耗费性能。假如可以使用ID匹配到唯一的元素就不用使用其他的选择器了。也正是因为选择器的这种匹配规则，使得元素更高效的匹配，也是经过长期的验证得来的结论。最后我们应该更加注意样式的继承，避免多次编写重复样式，所谓少用组合，多用继承原则。</p>
<p>近年来出现的css预处理器可以有效地提高样式的编写，使用一种面向对象的写法，更大程度对样式代码进行复用，有stylus、scss、less等，读者可以自行去官网了解。</p>
<h5 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h5><p>样式风格：关于css的编码风格也是因人而异，一般来说我们应该使用多行的写法，因为这样可读性就更高。假如样式代码写在一行，难免造成阅读困难的情况。后期我们进行项目发布的时候可以进行对代码的压缩。</p>
<p>id/class：id选择器一般使用在全局唯一的元素节点上面，如果确定元素节点唯一的情况下我们就可以使用，但是假如元素节点不唯一，那么就推荐使用class。</p>
<h2 id="05-高质量的行为代码"><a href="#05-高质量的行为代码" class="headerlink" title="05 高质量的行为代码"></a>05 高质量的行为代码</h2><hr>
<h5 id="良好习惯"><a href="#良好习惯" class="headerlink" title="良好习惯"></a>良好习惯</h5><p>因为项目涉及到多人开发，每个人自己使用的变量应该自己来维护，这样可以有效避免代码冲突，覆盖正常的代码等。所以我们应该禁止直接在全局的作用域下进行代码的编写，这样很容易对别人的项目模块造成影响。那么我们的避免的方法有哪些呢？</p>
<ul>
<li>团队合作避免冲突</li>
</ul>
<p>我们把自己的代码写在一个匿名函数里面，如（function(){}）()，这样代码里面的变量就不会是全局的了，而是属于这个函数的内部变量，不会对他人的代码造成影响。用匿名的方式把代码包裹起来，可以有效控制全局变量，避免冲突隐患。</p>
<ul>
<li>统一入口</li>
</ul>
<p>我们还可以给函数一个统一的入口加载文件，可以选择函数入口为init，这样所有初始化的操作都会在这里进行。通过这样我们就可以模拟DOMReady的事件了。</p>
<ul>
<li>CSS放在头部，JS放在底部</li>
</ul>
<p>这个操作应该是每个人都应该遵循的做法，这样更有利于浏览器页面的加载优化，减少页面空白的时间，提升用户体验。</p>
<h5 id="JS分层"><a href="#JS分层" class="headerlink" title="JS分层"></a>JS分层</h5><p>其实这里的分层和css的分层道理是一样的，也可以参考base层、common层、以及view层的形式。其中base层可以封装不同浏览器的差异，提供统一的接口，完成一些兼容的工作。common层提供可复用的组件，功能是给view层提供组件。common层和base层都可以为view层提供组件，不同的是common层可以提供更庞大的组件。比如一些拖拽功能的实现等。关于view层就是直接对前两层的调用，这里是关于页面逻辑的实现部分，如进行接口的请求等与具体功能需求相关的操作。</p>
<h5 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h5><ul>
<li>弹性</li>
</ul>
<p>弹性是指我们能够轻松应对客户提出来的需求，不用每添加一个需求就修改一些js代码，这是很不方便的事情。比如像事件代理一样，可以实现一些精简的操作，不用每添加一个节点就手动添加事件的监听函数。</p>
<ul>
<li>可复用性</li>
</ul>
<p>现在基本上我们实现什么的功能都要先考虑一下如何才可以把这写代码进行复用，以减少一些业务相关或功能相关的代码，做到一次编写，到处可用。能够公用且不影响组件之间的功能就是我们的追求。实现的方法我们可以通过传参的形式来进行。</p>
<ul>
<li>避免副作用</li>
</ul>
<p>我们开发的基础代码可能能够满足我们目前的需求，但也可能我们在使用的过程当中产生了一些副作用不是我们想要的，为了避免这个问题，我们应该考虑一下是否我们的函数耦合性太高，考虑解耦等。</p>
<h2 id="06-小结"><a href="#06-小结" class="headerlink" title="06 小结"></a>06 小结</h2><hr>
<p>今天就和大家聊一下关于编写高质量的代码的事情，其实还有很多方面来不及编写，读者自己也可以自行查阅相关资料。主要是从结构、样式以及行为三个方面来进行讲解，这也是对应着我们前端的基本语言html，css以及js。</p>
<p>结构方面我们说了语义化编写和模块化编写，样式方面我们说了盒子模型，样式的编写、样式风格和选择器的使用等，行为方面我们说了关于编写的良好习惯，js分层等。</p>
<p>其实具体的实现还得大家自己进行感悟，这些都是前人总结下来的经验而已，项目之中的具体细节可以依据以上的规则来进行编写，相信应该会提升一个代码质量层级。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/04/howToMakeHightLevelCode/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>代码规范</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>HR面试我应该怎么进行沟通</title>
    <url>/2020/04/03/HRInterview/</url>
    <content><![CDATA[<h2 id="HR面试我应该怎么进行沟通"><a href="#HR面试我应该怎么进行沟通" class="headerlink" title="HR面试我应该怎么进行沟通"></a>HR面试我应该怎么进行沟通</h2><blockquote>
<p>HR面试是我们的最后一关，主要考察你的一些非技术的能力，看你的价值观是否和公司的一致</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/03/HRInterview/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>HR面试是我们拿offer的最后一关，其实我们到了这一关的话我们就离offer不远了。HR其实考核的主要是了解你是否可以适应公司的文化，你是否可以更快速地融入技术团队等方面，最重要的是看你是否能够在较长的时间服务公司，为公司做贡献。除了看你软能力之外的方面，有些HR面试还会与你进行谈薪资。</p>
<p>但是很多时候我们是没有工资可谈的，有很多原因。比如可能是由于你的学校限制、或者是你的学历限制等，这些我们是无法改变的，但是也有可能是今年公司不会给你议价的机会，也就是统一的白菜价。</p>
<h2 id="02-常见的问题"><a href="#02-常见的问题" class="headerlink" title="02 常见的问题"></a>02 常见的问题</h2><h5 id="你的优缺点"><a href="#你的优缺点" class="headerlink" title="你的优缺点"></a>你的优缺点</h5><p>其实这是一个有陷阱的问题，问你的优点应该是没有问题的，可以说一下自己的学习能力、沟通技巧等方面的事情。但是让你说一下你的缺点的时候其实不是让你真正说自己的缺点，而且让你把你的缺点间接转化成优点。比如其实我们可以这样回答：</p>
<p><strong>优点：</strong></p>
<p>1、学习能力。由于我前端方面的学习起步比较晚，但是经过一年的时间，就可以独立完成网站的一些设计，以及前后端的交互流程，以及我十分关注前端方面的发展，比如一些框架和原理都会进行深入研究且在很短的时间就可以上手使用，掌握得还不错</p>
<p>2、相处能力。在校期间我就经常参加社团活动、参加班干部的竞选等，因为比较爱热闹和与人相处，也交了比较多的朋友，现在的话也和他们保持很好的关系，跟谁都相处比较好，遇到矛盾也能跟对方快速和解等。</p>
<p><strong>缺点：</strong></p>
<p>1、脾气急：比如一个小团队进行一个新的项目研发的时候，一个看似完成不了的项目，经过一段时间的准备都看不到什么效果，队友难免会有一些想放弃。这时候我就会显得脾气急躁，坚持了这么久就放弃？可能会数落他们一顿，打心底里要把事情做好等想法</p>
<p>2、主观感强：比如有时候别人会因为某一件事去尝试说服我，但是又拿不出什么事实证据来，我仍然会坚持自己的观点，不会接受别人无理由的批评，倾向于坚持自己认为正确的观点。</p>
<h5 id="你的未来规划"><a href="#你的未来规划" class="headerlink" title="你的未来规划"></a>你的未来规划</h5><p>1、疯狂的学习新的知识。因为刚毕业学习的激情、速度以及熬夜的能力可以发挥的淋漓尽致</p>
<p>2、扩展知识面。需要性能高、交互好、视觉美的页面，需要从前端框架选型、架构设计、构建工   具，到后端通信机制、设计与交互、网络和浏览器优化等各方面的知识。同时还要开始提升自己的名气，可以通过发表技术博客，提交和参与开源项目，做部门级公司级还有业界分享，参加业界会议等等</p>
<p>3、承担技术评审、架构设计和项目管理等事情。工作中除了完成自己的事情，可能还需要自己去面试别人或者指导新人，做新人培训，带领新人完成项目等</p>
<p>4、技术 or 管理，这里没有对错之分，只有合不合适。有的人就不善于交流，同时喜欢专研，可以继续走技术的路，发展成专家;有的人则可能有比较强的领导力，可以带领一群人完成项目，那可以转向管理，成为Team Leader等。后期可以根据的兴趣进行目标选择。</p>
<h5 id="最成就-遗憾的事情"><a href="#最成就-遗憾的事情" class="headerlink" title="最成就/遗憾的事情"></a>最成就/遗憾的事情</h5><p><strong>最有成就的事情</strong></p>
<p>在大学期间，每天都坚持起床到操场去学习和朗读英语，基本上除了天气原因和身体原因之外没有间断，然后一个学期的努力就顺利通过四六级考试等。或者我在x个月的时间我都坚持做xxx事情，最后我通过这件事情收获了xxx等。</p>
<p><strong>最遗憾的事情</strong></p>
<p>时间规划上面，在xxx期间我们把太多精力在xx活动上面，没有做好时间规划，导致在学习上面有一定的落后，对一些技术的知识积累和学习较少。但是经过一段时间的反思我们已经调整过来，重新找到自己的目标和方向。</p>
<h5 id="平时的时间规划和学习途径"><a href="#平时的时间规划和学习途径" class="headerlink" title="平时的时间规划和学习途径"></a>平时的时间规划和学习途径</h5><p>其实不光是HR面试会问这个问题，技术面试最后也会说一下这个问题，主要是想了解你的时间规划是怎么样的，是否有一个良好的学习习惯于时间规划方案。我们可以大概说一下自己是怎么利用课余时间的，或者你是怎么安排你的技术学习的，以及你对周末的大段时间是怎么安排的等等。</p>
<p>你也可以谈一下你对碎片时间是怎么利用的，其实我们生活中很多时间都是碎片时间，如何把碎片时间利用好就可以展现出你这个人的时间观念有多高。此外你可以说一下自己是在什么时间进行身体锻炼等细节问题。</p>
<p>关于学习途径方面没有固定的说法，一般就说一下你自己的学习阶段是怎么样的，如基础、进阶等是怎么学习的。我一般都会说前期入门的时候就看一套完整的视频，因为视频相对来说不会很枯燥，让你有兴趣继续学下去。但是入门之后就选择阅读专业书籍来学习，因为书籍才是最系统、最全面的知识仓库。同时这也是一个查漏补缺的重要途径，书籍学习可以有效地弥补视频学习带来的学习不精等缺点。</p>
<h2 id="03-薪资谈判"><a href="#03-薪资谈判" class="headerlink" title="03 薪资谈判"></a>03 薪资谈判</h2><hr>
<p>和HR谈薪资的阶段其实就是一个斗智斗勇的过程，在这个过程当中很多人就由于经验不足而得不到一个好的薪资。一般这里就分成两种情况：</p>
<ul>
<li>接受型</li>
</ul>
<p>这类同学可能没有试过怎么谈判，直接不谈，让HR自己给你一个合适的价位。那么这种情况的话只有一种结果，给你的就是批发价（俗称白菜价）。用人单位为了节省开支肯定不会开一个最高的给你，而是一个普通的薪资。或者如果公司没有了HC，那么HR将不会直接拒绝你，而是开给你一个很低的价位让你主动放弃offer。</p>
<ul>
<li>激进型</li>
</ul>
<p>一上来就亮出自己的底牌，说自己薪资要求在xxx k以上。这样的话其实不好，因为假如你说出高于HR心中的价位，可能会拒绝你，但是假如你说低了的话HR一般会直接给你这个。其实这时候我们应该事先摸清公司的价位如何，一般我们都会使用offershow查看一下公司的价位，上面有很多已经拿了offer的小伙伴爆料。</p>
<p>正常来说，我们应该先让HR说一下价位多少，然后你可以根据HR报的价位适当提高一点，好让自己有讨价的余地。但是假如你已经offer拿到手软，不在乎这一个公司的话可以报出你心目当中的价格，即使被对方拒绝了也没有关系，幸运的话你可能拿到这个offer，岂不美哉！</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>由于自己的种种原因，没有很多机会与HR斗智斗勇，奈何offer发过来薪资就直接在上面写着了。但是我们在HR面试的过程中应该要有自信和勇气，比如你已经有了offer什么都好说，这是最有说服力的答案，并不是每个人都可以说。正常来说你可以参考一下行业的标准，或者参考一下跟你水平差不多的同学拿了多少等再说出自己的想法。当然假如你是零offer你也可以说一下心中的价格，说不定人家就中了你的圈套呢！但是一般我们都不会赌这一把，毕竟现在是离offer最近的时候。</p>
<p>第二就是我们永远不要相信口头offer的事情，假如自己已经和HR谈好了，一定要以具体发出的offer为准，不然人家突然说不招人了你也莫得办法。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/03/HRInterview/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>















]]></content>
      <categories>
        <category>面试技巧</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>HR面试</tag>
        <tag>软技能</tag>
        <tag>面试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何上传Excel表导入数据库和导出Excel</title>
    <url>/2020/04/02/importExcel/</url>
    <content><![CDATA[<h2 id="如何上传Excel表导入数据库和导出Excel"><a href="#如何上传Excel表导入数据库和导出Excel" class="headerlink" title="如何上传Excel表导入数据库和导出Excel"></a>如何上传Excel表导入数据库和导出Excel</h2><blockquote>
<p>开始接触的时候觉得这是一件比较难的事情，但是通过两个插件你就可以轻松实现以上的功能</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/02/importExcel/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>最近在做毕业设计的时候遇到的两个问题，特此记录一下自己的实现过程。因为我们知道很多数据都是直接以表格的形式存储的，假如可以使用表格转化成json数据让前端直接操作那岂不是美滋滋。所以想着自己无论如何也要实现以下这个功能。</p>
<p>一开始可能想着直接在小程序弄一下，发现小程序不支持这个功能，所以就简单使用脚手架搭建了一个系统，经过谷歌之后发现需要使用npm 包安装两个插件，相信大家看完之后自己也可以实现成功。废话少说，开搞！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/02/importExcel/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-数据导入"><a href="#02-数据导入" class="headerlink" title="02 数据导入"></a>02 数据导入</h2><hr>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>我们先准备一下安装两个npm 插件：</p>
<ul>
<li>npm install xlsx</li>
<li>npm install file-saver</li>
</ul>
<p>这两个插件其实就是解析excel文件并返回数据和识别数据并以excel的格式导出到本地。首先我们在vue项目component中新建一个vue组件，用于放到页面中检测excel表和解析excel表。index.vue组件代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"drop"</span> @<span class="attr">drop</span>=<span class="string">"handleDrop"</span> @<span class="attr">dragover</span>=<span class="string">"handleDragover"</span> @<span class="attr">dragenter</span>=<span class="string">"handleDragover"</span>&gt;</span></span><br><span class="line">      拖拽文件到这里或者点击上传</span><br><span class="line">      <span class="tag">&lt;<span class="name">el-button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:loading</span>=<span class="string">"loading"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"margin-left:16px;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">size</span>=<span class="string">"mini"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">click</span>=<span class="string">"handleUpload"</span></span></span><br><span class="line"><span class="tag">      &gt;</span>Browse<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们把这个组件引入到import.vue的页面当中，配上element-ui的表格，用于渲染导入之后的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;upload-excel-component :on-success&#x3D;&quot;handleSuccess&quot; :before-upload&#x3D;&quot;beforeUpload&quot; &#x2F;&gt;</span><br><span class="line">&lt;el-button type&#x3D;&quot;primary&quot; round @click&#x3D;&quot;importDataInfo&quot;&gt;</span><br><span class="line">   一键导入数据库</span><br><span class="line">	&lt;i class&#x3D;&quot;el-icon-upload el-icon--right&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;el-table :data&#x3D;&quot;tableData&quot; border highlight-current-row style&#x3D;&quot;width: 100%;margin-top:20px;&quot;&gt;</span><br><span class="line">   &lt;el-table-column v-for&#x3D;&quot;item of tableHeader&quot; :key&#x3D;&quot;item&quot; :prop&#x3D;&quot;item&quot; :label&#x3D;&quot;item&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/02/importExcel/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h5><p>接下来我们先介绍一下组件是怎么识别excel文件的，我们看到上面有handleDragover的函数，我们先来看一下该函数，主要是组织默认事件和冒泡，因为只有这样，接下来你松开鼠标的时候ondrop事件才会执行。</p>
<ul>
<li>handleDragover</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleDragover(e) &#123;</span><br><span class="line">	e.stopPropagation();</span><br><span class="line">	e.preventDefault();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>handleDrop：主要是判断用户是否长传一个文件，或者文件的格式是否正确。判断无误之后就开始执行上传的步骤。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleDrop(e) &#123;</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.loading) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">const</span> files = e.dataTransfer.files;</span><br><span class="line">      <span class="keyword">if</span> (files.length !== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message.error(<span class="string">"一次只可以上传一个文件!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> rawFile = files[<span class="number">0</span>]; <span class="comment">// 只能这样写，因为files是一个数组，取第一个文件</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.isExcel(rawFile)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message.error(</span><br><span class="line">          <span class="string">"仅支持.xlsx, .xls, .csv文件"</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.upload(rawFile);</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">      e.preventDefault();</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>upload：文件上传之后会触发beforeUpload函数，beforeUpload函数在import.vue的父组件中，通过父子传值的方式来判断文件大小。当判断通过之后就正式调用readerData开始获取数据了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">upload(rawFile) &#123;</span><br><span class="line">     <span class="keyword">this</span>.$refs[<span class="string">"excel-upload-input"</span>].value = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">this</span>.beforeUpload) &#123;</span><br><span class="line">       <span class="keyword">this</span>.readerData(rawFile);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">const</span> before = <span class="keyword">this</span>.beforeUpload(rawFile);</span><br><span class="line">     <span class="keyword">if</span> (before) &#123;</span><br><span class="line">       <span class="keyword">this</span>.readerData(rawFile);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>beforeUpload</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeUpload(file) &#123;</span><br><span class="line">     <span class="keyword">const</span> isLt1M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &lt; <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (isLt1M) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.$message(&#123;</span><br><span class="line">       message: <span class="string">"Excel文件上传不能大于1MB"</span>,</span><br><span class="line">       type: <span class="string">"warning"</span></span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>readerData：主要是对excel表格数据的一些处理，最后通过子组件向父组件传值的方式，传递数据给父组件渲染表格。这里有一些概念需要了解一下</li>
</ul>
<blockquote>
<ul>
<li>workbook 对象，指的是整份 Excel 文档。我们在使用xlsx 读取 Excel 文档之后就会获得 workbook 对象。</li>
<li>worksheet 对象，指的是 Excel 文档中的表。我们知道一份 Excel 文档中可以包含很多张表，而每张表对应的就是 worksheet 对象。</li>
<li>cell 对象，指的就是 worksheet 中的单元格，一个单元格就是一个 cell 对象。</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workbook</span></span><br><span class="line">&#123;</span><br><span class="line">    SheetNames: ['sheet1', 'sheet2'],</span><br><span class="line">    Sheets: &#123;</span><br><span class="line">        <span class="comment">// worksheet</span></span><br><span class="line">        'sheet1': &#123;</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            'A1': &#123; ... &#125;,</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            'A2': &#123; ... &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// worksheet</span></span><br><span class="line">        'sheet2': &#123;</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            'A1': &#123; ... &#125;,</span><br><span class="line">            <span class="comment">// cell</span></span><br><span class="line">            'A2': &#123; ... &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">readerData(rawFile) &#123;</span><br><span class="line">     <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();<span class="comment">//获取render对象</span></span><br><span class="line">       reader.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">const</span> data = e.target.result;</span><br><span class="line">         <span class="keyword">const</span> workbook = XLSX.read(data, &#123; <span class="attr">type</span>: <span class="string">"array"</span> &#125;);<span class="comment">//这是获取整张表格</span></span><br><span class="line">         <span class="keyword">const</span> firstSheetName = workbook.SheetNames[<span class="number">0</span>];<span class="comment">//表格有很多表，这里我们获取第一张表</span></span><br><span class="line">         <span class="keyword">const</span> worksheet = workbook.Sheets[firstSheetName];<span class="comment">//根据表明获取对应表</span></span><br><span class="line">         <span class="keyword">const</span> header = <span class="keyword">this</span>.getHeaderRow(worksheet);<span class="comment">//获取表头</span></span><br><span class="line">         <span class="keyword">const</span> results = XLSX.utils.sheet_to_json(worksheet);<span class="comment">//转成json数据</span></span><br><span class="line">         <span class="keyword">this</span>.generateData(&#123; header, results &#125;);<span class="comment">//返回数据</span></span><br><span class="line">         <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">         resolve();</span><br><span class="line">       &#125;;</span><br><span class="line">       reader.readAsArrayBuffer(rawFile);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>generateData：获取上面处理过后的结果以及表格头，用于渲染表格。这里的onSuccess就是回调函数，父组件就可以获取数据了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">generateData(&#123; header, results &#125;) &#123;</span><br><span class="line">      <span class="keyword">this</span>.excelData.header = header;</span><br><span class="line">      <span class="keyword">this</span>.excelData.results = results;</span><br><span class="line">      <span class="keyword">this</span>.onSuccess &amp;&amp; <span class="keyword">this</span>.onSuccess(<span class="keyword">this</span>.excelData);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>到此我们已经可以获取excel的表格数据了，以上只是主要的代码，具体代码我已提交到<a href="https://github.com/wqs2019/importExcelData" target="_blank" rel="noopener">github仓库</a>。这里由于隐私原因我就截取一部分的信息。通过控制台打印出来我们可以看到是一个数组，每一项都是json数据，格式很友好。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/02/importExcel/3.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>然后接下来我们就可以使用这些数据进行数据库导入了，代码部分可以到<a href="https://github.com/wqs2019/importExcelData" target="_blank" rel="noopener">github仓库</a>看一下，这里就不贴了，就是一个循环插入的过程，没什么技术含量。</p>
<h2 id="03-数据导出"><a href="#03-数据导出" class="headerlink" title="03 数据导出"></a>03 数据导出</h2><hr>
<p>数据导出的部分其实也是很简单的，就一个函数就可以。我们首先是与表格关联，不然找不到表格就下载和导出不了。具体代码已上传到<a href="https://github.com/wqs2019/importExcelData" target="_blank" rel="noopener">github仓库</a></p>
<h5 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleDownload() &#123;</span><br><span class="line">      <span class="keyword">this</span>.downloadLoading = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> wb = XLSX.utils.table_to_book(<span class="built_in">document</span>.querySelector(<span class="string">"#table-data"</span>));<span class="comment">//关联表格，表格id为table-data</span></span><br><span class="line">      <span class="keyword">var</span> wbout = XLSX.write(wb, &#123;</span><br><span class="line">        bookType: <span class="string">"xlsx"</span>,</span><br><span class="line">        bookSST: <span class="literal">true</span>,</span><br><span class="line">        type: <span class="string">"array"</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.filename);</span><br><span class="line">        FileSaver.saveAs(</span><br><span class="line">          <span class="keyword">new</span> Blob([wbout], &#123; <span class="attr">type</span>: <span class="string">"application/octet-stream"</span> &#125;),</span><br><span class="line">          <span class="keyword">this</span>.filename + <span class="string">".xlsx"</span> || <span class="string">"excel"</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">console</span> !== <span class="string">"undefined"</span>) <span class="built_in">console</span>.log(e, wbout);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.downloadLoading = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"导出完成"</span>);</span><br><span class="line">      <span class="keyword">return</span> wbout;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>通过各方捣鼓之后功能已经正常。不得不说使用这种方式的数据处理方式实在是很方便，我们可以通过数据导入的方式避免了直接操作数据库进行导入，而是通过一个中间的管理平台，确保数据的安全性，只有管理员权限才可以进行数据导入。</p>
<p>大家也可以自己尝试一下如何进行数据的导入与导出，实践才是检验真理的唯一标准，需要自己认真动手操作一下才知道流程是怎么样的，才真正学到东西。</p>
<p><img src="/2020/04/02/importExcel/2.gif" alt></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Excel导入</tag>
        <tag>Excel导出</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Node是如何进行错误处理的</title>
    <url>/2020/04/02/nodeErrorhandle/</url>
    <content><![CDATA[<h2 id="浅析Node是如何进行错误处理的"><a href="#浅析Node是如何进行错误处理的" class="headerlink" title="浅析Node是如何进行错误处理的"></a>浅析Node是如何进行错误处理的</h2><blockquote>
<p>node是对错误处理要求比较高的语言，假如对错误处理没有到位可能会造成程序进程退出</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/02/nodeErrorhandle/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>错误处理是程序中一个重要的部分，也是判断你的程序是否专业的标准。一般来说我们写程序的时候都会选择使用try…catch来进行错误捕获，或者有时候我们会使用throw进行错误抛出，这是都是常用的错误捕获方法。但是我们在进行node进行开发的时候就会接触到异步过程的中的错误处理。</p>
<p>我们知道在node开发的时候会运用到很多第三方的模块，比如我们经常会使用最大的包管理工具npm，里面下载的包都会放到我们项目当中的node_modules里面，我们打开可以看到里面包含的文件很多，代码量也是巨大的。这里面就会有很多的bug隐患在里面，这时候使用错误捕获就非常有用了。</p>
<p>其实我们一开始想到的就是在全局范围内进行错误的监听，node提供了一个uncaughtException捕获异常，但是这种方法我们会难以定位到错误的发生位置。不应该把该函数当成万能的捕获模块，而是最后的解决方案。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/02/nodeErrorhandle/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-Error模块"><a href="#02-Error模块" class="headerlink" title="02 Error模块"></a>02 Error模块</h2><hr>
<p>Error定义了Node中常见的错误类型，我们可以使用Error进行错误的抛出。Error模块里面包含了一个堆栈轨迹用于描述Error是从哪里产生的，一般来说我们可以准确知道错误发生在哪一部分的代码当中，根据错误的描述信息可以快速定位到错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.readFile(<span class="string">"file"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Node程序中产生的所有Error都是使用Error类的实例或者继承自Error类。我们在程序代码不中不仅可以使用回调函数自带的Error模块，而且我们可以显示第捕获错误。比如当你知道逻辑代码运行都某一部分是不对的，应该进行错误的捕获和提醒，你就可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"自定义错误信息！"</span>)</span><br></pre></td></tr></table></figure>



<h2 id="03-错误捕获方式"><a href="#03-错误捕获方式" class="headerlink" title="03 错误捕获方式"></a>03 错误捕获方式</h2><hr>
<p>接下来就简单介绍一下Node中我们是如何进行错误捕获的，总的来说我们可以有以下三种方式，try/catch、callback、event。之前我们常用的try/catch方式只适用于同步的调用情况，但是我们知道node中会出现很多的异步调用方式。</p>
<h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h5><p>首先我们应该了解的是在异步操作当中该方法是无法捕获错误的，主要原因就是因为异步调用返回时，代码的上下文已经改变，回调函数当中的代码已经脱离了try/catch的范围，所以是无法捕获的。</p>
<p>同步调用情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里可以捕获</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"这里出错了！"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步调用情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'这里出错了！'</span>)&#125;，<span class="number">1000</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e);<span class="comment">//这里无法进行捕获</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h5><p>回调函数的方式主要是通过参数的判断来确定的，node中通常回调函数都会接受两个参数error和result。这两个值肯定会有一个不为空，我们通过读取本地文件的操作来举一个例子。（因为方法返回的是buffer对象难以阅读，我们就是使用utf8进行读取，最后字符串转成json）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.readFile(<span class="string">"./a.json"</span>,<span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(result));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>假如文件存在就会返回输出结果，故意写成a1.json不存在就会抛出错误：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123; [Error: ENOENT: no such file or directory, open 'D:\test\a1.json']</span><br><span class="line">  errno: -4058,</span><br><span class="line">  code: 'ENOENT',</span><br><span class="line">  syscall: 'open',</span><br><span class="line">  path: 'D:\\test\\a1.json' &#125;</span><br></pre></td></tr></table></figure>



<h5 id="Event错误处理"><a href="#Event错误处理" class="headerlink" title="Event错误处理"></a>Event错误处理</h5><p>我们进行对文件流监听的时候，即使文件流读取是一个同步的方法，但是我们依旧不能使用try/catch来捕获，为什么呢？因为该方法返回了一个对象，只能使用事件处理的方式来处理异常。如果使用try/catch的话直接报错退出，使用事件监听的方式就不会影响程序的运行且会报出错误信息。</p>
<p>所以正确的方式应该是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">'./a.json'</span>);</span><br><span class="line">stream.on(<span class="string">"error"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="04-Domain模块"><a href="#04-Domain模块" class="headerlink" title="04 Domain模块"></a>04 Domain模块</h2><hr>
<p>domain模块视图在一个更高的维度上面解决以上提到的三种错误（可处理callback与event形式），但是现在这个模块已经是不推荐使用了。首先它的出发点就是把不同的处理方式统一到这个模块里面监听和捕获。</p>
<p>它的用法是使用了create方法进行创建Domain对象，然后通过Domain对象监听某对象的error事件，且定义好了相应的处理逻辑，最后使用run方法来启动整个Domain，run方法里面的内容就是我们准备监听的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理callback</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">"domain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = domain.create();</span><br><span class="line">d.run(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./a1.json'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">d.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理event</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">"domain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = domain.create();</span><br><span class="line">d.run(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.createReadStream(<span class="string">'./a1.json'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">d.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>除此之外，domain可以支持手动调用add方法把对象添加到监听列表当中。由此可见，Domain其实就是将需要管理的对象包裹起来然后通过run与add方法进行处理和实现。但是如果我们想要把整一个web服务监听的话就是把所有代码都放到run方法里面，可能会造成内存泄露，而且手动调用add方法很难以接受，假如对象被遗漏就可能会花费很多时间进行错误排查。</p>
<p>它的原理其实很简单：</p>
<ul>
<li>通过add方法将对象添加到其监听列表当中（有一个menber属性，维护监听的对象）</li>
<li>监听process.uncaughtException捕获，假如代码被domain包裹就会触发domain的error事件</li>
<li>通过将异步的实现方式，加入domain进行监听，这样就可以把所有的不同的错误处理机制统一到一个对象</li>
</ul>
<h2 id="05-ES6中的错误处理"><a href="#05-ES6中的错误处理" class="headerlink" title="05 ES6中的错误处理"></a>05 ES6中的错误处理</h2><hr>
<p>ES6我们在工作中用的比较多，比如我们常用的就有promise对象了，还有async/await的形式，被称为是异步的终极解决方案。所以我们也来谈一下ES6中如何进行错误处理。</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>首先第一个肯定是promise了，因为这对于回调函数的操作很友好，避免了一些回调地狱的产生，也提供了try/catch的形式捕获异常。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve,reject)&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错啦！"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>Generator与async</p>
<p>可以使用try/catch语句进行错误捕获，当yield后面的异步操作发生了错误，一样可以使用try语句进行捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">yield</span> asyncFunction();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">		<span class="built_in">console</span>,log(e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'end'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们使用async的形式来写（其实就是语法糖，本质一样），也可以使用try/catch来捕获。假如await内部操作出错则后续代码不会执行，可使用try进行包裹。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">await</span> asyncFunction()</span><br><span class="line">	&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="06-小结"><a href="#06-小结" class="headerlink" title="06 小结"></a>06 小结</h2><p>以上我们介绍了如何在异步的世界里面进行错误的捕获，之前我们进行的代码编写都是在同步的世界里，使用try/catch就可以解决大部分你的问题。但是近年来我们出现了Node，同步的世界被打破了，所以我们也有必要学习一下如何进行错误的捕获。</p>
<p>上面我们说了使用原始的方法try/catch、callback回调函数、事件触发机制三种方法。</p>
<p>假如我们遇到一些不可避免的错误，导致系统崩溃或者程序得不到正常运行，我们还是有最后的解决方法并且大部分是有效的，那就是：重启试试！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/04/02/nodeErrorhandle/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

]]></content>
      <categories>
        <category>错误处理</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>应届生小白如何找一份靠谱工作</title>
    <url>/2020/03/31/howToFindJobs/</url>
    <content><![CDATA[<h2 id="应届生小白如何找一份靠谱工作"><a href="#应届生小白如何找一份靠谱工作" class="headerlink" title="应届生小白如何找一份靠谱工作"></a>应届生小白如何找一份靠谱工作</h2><blockquote>
<p>疫情之下，很多同学都难以找到一份好工作，很多公司招聘需求也比较少，那么我们该如何辨别是否是靠谱的呢？</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/31/howToFindJobs/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>大家都知道，临近毕业很多事情都变得忙碌起来了，以前三年没有想过的事情如今一年就要全部想清楚，你说这能不难嘛？然而最近的疫情影响，大家都难以找到工作，一下子压力就大了起来，老师同学都鼓励大家积极就业，其实道理我们都懂，但是我的老板到底在哪？</p>
<p>除了我们要考虑就业、找工作的问题之外，我们还要好好准备我们的毕业设计、毕业论文。都说我们是见证历史的一届，美股熔断、高考延期、奥运推迟…</p>
<p>说实在的，这一年发生了太多的事情以前从来都不敢想象的，本应该大家都快乐去踏进社会，开启一段新的旅程。但是即使我们很难，但是我们总归要一步步找到方法，方法总比困难多，社会才会进步，我们也是。所以我们居家的这段时间也可先解决我们的未来一大难题——找工作。接下来就思考和判断一下我们应该如何找到一份好工作。</p>
<h2 id="02-公司定位"><a href="#02-公司定位" class="headerlink" title="02 公司定位"></a>02 公司定位</h2><hr>
<p>之前我就写过一篇关于毕业何去何从的文章，简要说了一下我们该如何去选择大公司和小公司的问题。这里我也再提醒一下，找工作先定位自己的目标，是去大公司还是创业公司？我们先把自己的定位做好，然后才慢慢准备其他的内容。</p>
<h5 id="能力要求"><a href="#能力要求" class="headerlink" title="能力要求"></a>能力要求</h5><p>大公司和小公司的能力要求是不一样的，先说一下大公司，它里面的体系都是比较完整的，有系统的培训体系、薪酬福利、发展路线等，相对来说是一个人人向往的办公环境。除此之外，我们还可以与很多大牛同事共事，从技术成长上面来说我们是比较好的，我们会对某一个领域的知识有独到的见解。大公司可能会每周/每月定时举行一次技术交流会，分享技术心得与问题的解决方法，这些都是很宝贵的资源，外面也很难听到这些知识。</p>
<h5 id="薪酬福利"><a href="#薪酬福利" class="headerlink" title="薪酬福利"></a>薪酬福利</h5><p>除了一些隐形的福利，我们也更关心薪酬的多少，一般来说大公司的薪酬是比小公司多，而且还有各种福利等。公司体量的大就代表了它有一定的稳定性，跟你的机会也相对来说比较多，即使部门不太合适你也可以进行内部转岗。但是进大公司也不是大多数人都可以去的，有一定的门槛和要求，除了本科应届生还有应届的硕士研究生跟你一同竞争。</p>
<p>再来看一下小公司，我们知道初创公司一般都是比较小的公司，团队只有十几人左右，分工相对来说不是很明确，每个人都应该懂得很多业务知识与技术知识，对人员的技术能力也会比大公司的好。一般来说你需要懂前后端的交互、系统的部署等跨专业知识的方面，我之前实习的公司就要要求你有linux的知识，懂得上线和部署系统，虽然你是前端开发。</p>
<p>然后公司的稳定性也不好，我们知道创业的成功率不高，而且我们的基本薪资是比较少的，这些才是我们关心的事情。总的来说，大家好好准备，能去大公司的话一定要去试一下，不要再小公司后悔当初没有努力。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/31/howToFindJobs/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-公司背景"><a href="#03-公司背景" class="headerlink" title="03 公司背景"></a>03 公司背景</h2><hr>
<p>除了关注一些比较大方向的内容之外，我们在面试之前一定要看一下公司的背景是怎么样的，公司的规模是多大的，业务有哪些方面以及现在已经投放到市场的产品有哪些。总之想别人对你进行背景调查一样，你也应该提前了解一下你即将面试的公司是怎么样的。有些面试的时候还会问你，你对我们公司的了解有多少？这其实也是一道开放的题目，就是为了了解候选人是否认真了解过公司，还是只是海投。</p>
<p>我们查看公司的背景可以通过以下的三个方面来看：</p>
<ul>
<li>估值</li>
</ul>
<p>首先我们应该关心一下公司的估值有多少，虽然这些钱跟我们没有什么关系。但是这也是一个评估你们公司是否有实力和有前途，通过大致的估值你可以了解到你们公司的市场业务是有前景，是否有发展前途。可以通过查看公司的CEO，看是哪一行业的任务，他的高层政策方针是否有问题，领导下的公司走向等。还有一个就是查看公司的融资情况，这个也是很有代表性的，一般来说越到后面你的公司存活率就会越高，因为别人舍得给你投资就证明你们做的产品是有价值的。</p>
<ul>
<li>业务</li>
</ul>
<p>公司的业务，大部分是指公司现在正在做的一些产品是怎么样的，产品是否正在盈利与用户规模有多大。同时我们也要关注我们自身的利益，薪酬制度是否合理，你目前的情况是否与当前的薪资相匹配。最后一个就是技术栈，公司用的技术到底是怎么样的，是否与市场接轨。公司的技术关系到你以后的发展方向，因为你不可能一直在那个公司干，所以你学的技术一定是要和国内大部分的互联网企业用的技术是相通的。</p>
<p>关于技术成长，你需要考虑公司对实习生的培训制度，当你进去之后有没有人愿意带你。如果是没有人带你，可能你在里面过的比较辛苦，因为业务你不熟悉，技术你也跟不上，怎一个难字了得。</p>
<ul>
<li>舆情</li>
</ul>
<p>舆论方面，我觉得是最能真实反映公司的情况的，大家想想吃瓜群众是很多的。一旦公司出了什么事情，总会有员工出来发表或者吐槽一下。比如最近哪个公司进行大规模的裁员，那么我们想想，自己还会想去吗？又或者公司要求全员996且不得有意见等，这些其实都是舆论，都会在互联网这个圈子里面流传。还有一个就是领导的人品如何，跟对了老板你就会前途一片光明，但是跟不对你就有点不妥了。</p>
<p>其实舆论方面大部分是一些很小的事情，但是事情的影响很恶劣，所以总会被推到风口浪尖上面。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/31/howToFindJobs/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-offer选择"><a href="#04-offer选择" class="headerlink" title="04 offer选择"></a>04 offer选择</h2><hr>
<p>一般来说你如果能顺利拿到满意的offer就应该马上签了，犹豫不得，特别是你有且仅有的offer。因为假如你在规定的时间内没有答复或者同意对方的offer，可能直接废弃你的offer然后重新甄选候选人。假如是一个大公司，更应该是快点决定，因为公司都会有一个简历人才库，其中都有很多厉害的人在里面躺着，985/211/海外留学等。所以我当时是很快就同意了，知道自己菜没办法。</p>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>疫情期间，家家都有一本难念的经。其实每个公司都想更好地发展，扩大生产和经营的规模，加大对市场人才的录用率。但是奈何现在大家都是处于一种经济困难的状态，企业复工率也是比较低，业务和产品都得不到发展等各种困难，真实来说现在能找到工作也是一件不错的事情了。</p>
<p>还是那句话，市场永远都是青睐那些有技术的高端人才，只有你有技术，迟一年去好的公司又如何，待春暖花开时，自然就是一片好的生态。我们在家也要好好准备工作、面试、毕设、论文的事情，并不是你们所说的煲剧看电影打游戏睡懒觉的状态，好好准备自己如何在弯道超车，但是车速也不宜过快，好好沉淀自己，切勿心浮气躁。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/31/howToFindJobs/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>







]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>毕业</tag>
        <tag>工作</tag>
        <tag>应届生</tag>
        <tag>公司判断</tag>
        <tag>大公司or小公司</tag>
      </tags>
  </entry>
  <entry>
    <title>自己开发的程序有必要自己测试吗</title>
    <url>/2020/03/28/testProcess/</url>
    <content><![CDATA[<h2 id="自己开发的程序有必要自己测试吗"><a href="#自己开发的程序有必要自己测试吗" class="headerlink" title="自己开发的程序有必要自己测试吗"></a>自己开发的程序有必要自己测试吗</h2><blockquote>
<p>“程序员的职责就是开发自认为完美的程序，我们自己写的程序是否要自己重新测试一遍呢？”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/28/testProcess/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>自己最近也在疯狂的输出代码，首先不是因为自己有多厉害，而是因为毕业设计的相关事情。我知道很多小伙伴都对自己写的代码很有信心，认为经过我手的代码肯定不会出错，肯定是测试坑的我。但是奈何自己没有测试小帮手，唯有身兼数职，一边开发一边测试。</p>
<p>抛开自己一个人负责的项目来说，很多大公司都会有自己的测试团队，他们会对代码进行完整的测试之后才会上线。但是很多人都会觉得我自己写的代码，有必要自己再测试一遍吗？而且不还有测试工程师吗？这里有一个很搞笑的问题，万一系统上线之后，出现问题该是谁来背锅？开发人员说都是测试的责任，没有测试出来错误；但是测试人员就说都是开发，代码写得不好。所以这里到底是谁的锅我们就有点难判断了。</p>
<p>所以为了避免这种事情发生，我们开发人员退一步，自己开发的代码先自己测试一遍，看功能是否正常，逻辑是否有问题，然后我们再交给测试，这样的愉快过程对大家都好。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/28/testProcess/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-为什么要自己测试"><a href="#02-为什么要自己测试" class="headerlink" title="02 为什么要自己测试"></a>02 为什么要自己测试</h2><hr>
<p>我们自己来测试自己的程序首先肯定是基于我们自己是对程序最熟悉的人员，别人不可能知道我们代码的每一个部分的内容。我们这里基于几个方面来说，第一是测试人员是否可靠，第二是第三方代码是否可靠，第三是产品迭代的质量保证。</p>
<ul>
<li>测试人员</li>
</ul>
<p>这里的测试人员就是测试工程师，测试开发人员会把用户所有操作可能出现的情况都跑一边，这里能否保证测试的质量、能否找出bug就是测试用例是否完善。我们如果在leetcode上面刷题的话就知道，他都会有一个测试用例库在里面，只有你完全通过之后才算你的程序没有问题，一般我们着重考虑的就是边界情况和特殊情况。举一个简单的例子，也是我最近的做的一个修改初始密码的功能。大家可以想一下用户有哪几种操作？</p>
<p>为什么要这样说呢？因为我们写的程序一开始就要一套用户逻辑在里面，就相当于我们自己限定了一套流程，觉得用户理应是这么操作的。但是用户不是开发，他们有可能出现很多种操作情况，我们都要一一覆盖完全。比如用户可以不输密码，用户可以只输原始密码没有输入新密码就提交，或者旧密码错误你就不能让他改了，万一他不是本人操作呢？所以我们都每一种情况都是试一下，保证用户的操作不会超出自己的范围外。</p>
<p>测试是有一套工具的，测试人员是没有比我们更熟悉的程序的，所以第一个考虑的问题就是我们一定要对自己的程序负第一责任，这锅该背的时候还是得背。</p>
<ul>
<li>第三方代码</li>
</ul>
<p>我们现在，就前端来说已经是偏向工程化的时代，页面已经不是单纯的html+css或者div+css开发模式这么简单了。我们熟知的npm包管理工具已经有几万个代码包，很多时候我们并不能判断这些代码库是否安全，直接npm install就完事了。但是这里一般来说也不是什么大问题，毕竟大家都在用这里面的代码和集成的方法，可是万一某个包被人参杂了一些不合法的程序怎么办呢？我们的项目一般都是依赖很多组件或者页面的，一旦出了问题那就是很严重的情况了。</p>
<p>假如大家为了安全起见可以去了解一下源代码，看一下是否其中藏着什么猫腻。但是我一般不会去看，因为看不懂。一般来说一些常用的包是没有问题的，有问题一早就反应出来了，而且我们用的一般都是常用的，比如vue，vue-router，vuex，element-ui等，常用的基本上都没有问题。</p>
<p>所以第二个方面就是检查一下第三方包是否靠谱（假如有能力），因为第三包出了问题，测试或者开发员人可能都难以准确定位问题出在哪，更难以解决了。</p>
<ul>
<li>产品迭代</li>
</ul>
<p>第三个就是我们的产品迭代方面，可能有些项目还没有上线就凉了或者我开发出来的版本就不打算长期迭代了，这种情况我们就另说了。一般来说我们的产品都是长期迭代的，如何保证后续的开发顺利和产品的质量？首先肯定是我们的基础层面做的好，平台没有做好我们是很难向下发展的。代码是否向下兼容，接口升级有没有问题，这些我们都要保质保量。做到随时进行代码移植、随时小功能上线，随时合并项目等。</p>
<p>这些过程可能在早期来说比较耗费时间和精力，但是想想以后你项目出现问题找bug的时间根本不算什么，而且你的项目早期做的越好，以后的排查难度会降低很多，问题也可以非常快速的定位。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/28/testProcess/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-自己如何做测试"><a href="#03-自己如何做测试" class="headerlink" title="03 自己如何做测试"></a>03 自己如何做测试</h2><hr>
<p>说了这么多，那我们到底该如何测试自己的代码呢？换句话来说我们测试应该要遵循什么样的原则呢？</p>
<ul>
<li>单一职责</li>
</ul>
<p>我们测试某一个功能肯定是从最小的功能做起，测试是否有问题，就像函数一样，只做一件事情。一旦我们的代码比较多的时候，测试就难以进行了，可能因为功能之间相互引用，假如某环节出了问题你也不知道从哪里推测出来。</p>
<p>最近我也在写node相关的后台接口，我发现一个简单的数据库接口查询都是要分开很多个文件来写的，可以分为数据库配置文件以用来配置数据库的地址、端口、用户名密码等，还有一个文件用来接收sql语句写连接查询，还有一个文件用来写某一个接口的sql语句，还有用来写接口路由的，最后都集合到index.js当中开启服务。</p>
<p>整一个流程下来我们难免会有多个文件，但是我们把耦合性降到了最低。以后我们修改接口名称或者新增接口都是十分地方便，也容易排查错误。所以我们测试也要做到单一职责的则是，一次只做一个功能，如webpack中的loader一样。</p>
<ul>
<li>用例完整</li>
</ul>
<p>按照正常的逻辑思维来说，我们的程序大部分情况下都不会有问题，一般出现问题的就是一些边缘情况，我们称之为特殊值或者边界情况。比如我们常见的数组下标越界都是这种情况，这种情况涉及的问题可大可小，堆栈溢出实际上是很严重的问题，不要小看这一个下标，可能会覆盖正常的数据或者读取非法数据。</p>
<p>所以我们一定要保证测试的用例在我们可控的范围之内，否则就会有问题，数据的完整性就是指数据不能多也不能少。通过不断地添加测试用例，将会不断覆盖代码的分支和不同的情况。</p>
<p>我觉得上面这两种原则已经可以涵盖大部分的情况了，剩下的情况我们可以考虑一些性能测试，压力测试等方面的内容。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/28/testProcess/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>测试的意义就在于，用户消费产出的代码之前，开发者先消费它，给予其重要的质量保证。——《深入浅出Node.js》</p>
<p>今天我们聊了关于程序产出之后，我们是否应该进行先测试，答案相信大家已经有了。很多时候我与上线成功就只差一个测试，大家其实应该也要考虑开发环境与线上环境的问题，因为开发没有任何问题，部署之后却死活不行。因为线上环境很特殊，不仅考虑网络是否流畅，是否有阻塞的情况，线上代码资源文件的地址是否错误等，而且还要考虑线上环境代码走的分支也是不一样的。</p>
<p>举个简单的例子，我们在vue项目设置代理的时候一般都是在proxyTable下面进行设置，但是这里只是开发环境的情况，线上环境却是不走这里的，要想我们的接口生效我们可以去配置nginx进行反向代理，这又是另一种情况了。只是为了告诉大家，测试很重要，上线测试更重要。</p>
<p><img src="/2020/03/28/testProcess/2.gif" alt></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>开发</tag>
        <tag>代码质量</tag>
        <tag>测试用例</tag>
        <tag>测试原则</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用JWT做简单的登录验证操作</title>
    <url>/2020/03/26/jwtToken/</url>
    <content><![CDATA[<h2 id="如何使用JWT做简单的登录操作"><a href="#如何使用JWT做简单的登录操作" class="headerlink" title="如何使用JWT做简单的登录操作"></a>如何使用JWT做简单的登录操作</h2><blockquote>
<p>注册登录方面的鉴权对于一个网站来说是及其重要的，不仅可以保护你的个人信息，还可以方便后续的操作。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/26/jwtToken/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>今天和大家聊一下我们的登录注册流程是怎么样的。我们知道登录方面有很多种情况，比如可以使用账号密码进行登录，可以使用扫码登录，还可以使用第三方的账号登录，其实原理都是大同小异的，无非就是验证你的账号是否合理以及你的登录信息是否有效。</p>
<p>但是本文就是用简单的登录流程给大家说一下其中的奥妙。一般来说我们登录成功之后服务端会返回一个token，大家不要以为这是一个毫无逻辑的字符串，一开始我就是这么认为的。其实token里面就保存了我们账号的信息，只不过经过加密操作而已，我们进行解密之后就可以拿到信息了。</p>
<h2 id="02-准备工作"><a href="#02-准备工作" class="headerlink" title="02 准备工作"></a>02 准备工作</h2><p>大家可能一开始不知道jwt是什么，简单来说这个就是用户信息的加密版，可以加密你的账号，也可以解密。理解了这个我们就可以使用它来做一点事情了，我们这里使用的是vue+jwt+node+mysql这样一个简单的架构，我们可以在vue页面简单写一下登录的操作，使用node写一个login的接口就可以了。</p>
<p>为了照顾大部分的小伙伴们，我把流程再说详细一点。开始我们肯定要装mysql和jsonwebtoken这两个插件的，为了更加方便之后，我还装了express，目的就是为了使用路由的时候方便操作。</p>
<h5 id="打通数据库"><a href="#打通数据库" class="headerlink" title="打通数据库"></a><strong>打通数据库</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">api.js文件</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">const</span> sqlMap = <span class="built_in">require</span>(<span class="string">'./sqlMap'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链接对象</span></span><br><span class="line"><span class="keyword">const</span> pool = mysql.createPool(&#123;</span><br><span class="line">    host: <span class="string">'xx.xx.xxx.xxx'</span>,</span><br><span class="line">    user: <span class="string">'root'</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    password: <span class="string">'xxxxxx'</span>,</span><br><span class="line">    database: <span class="string">'xxxxxx'</span>,</span><br><span class="line">    multipleStatements: <span class="literal">true</span>    <span class="comment">// 多语句查询</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//写一个登录接口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    login(req, res, next) &#123;</span><br><span class="line">      <span class="keyword">var</span> username = req.query.username;</span><br><span class="line">      <span class="keyword">var</span> password = req.query.password;</span><br><span class="line">      pool.getConnection(<span class="function">(<span class="params">err, connection</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sql = sqlMap.login; <span class="comment">//这里有一个sqlMap对象，用来写sql语句</span></span><br><span class="line">        connection.query(sql,[username,password] ,(err, result) =&gt; &#123;</span><br><span class="line">            res.json(result);</span><br><span class="line">            connection.release();</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//接下来可以写更多的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>还有写一个接口的路由，就是你请求这个的时候就会连接数据库和查询数据库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.js文件</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> api = <span class="built_in">require</span>(<span class="string">'./api'</span>); <span class="comment">//这里引入上面的文件</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/login'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  api.login(req, res, next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后记得导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>



<p>上面我还有用到一个sqlMap的一个对象，我们单独写一个，就是为了以后方便，而且耦合性更低，容易扩展。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sqlMap &#x3D; &#123;</span><br><span class="line">    login: &#39;select * from teacher where teacherName &#x3D; ? and &#96;password&#96; &#x3D; ?;&#39;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最后也记得要导出</span><br><span class="line">module.exports &#x3D; sqlMap;</span><br></pre></td></tr></table></figure>

<p>这样我们在文件中引入的时候就可以使用这个对象了，这里面还可以写很多sql的语句查询。</p>
<p>说了这么多，我们肯定要启动服务的，那么我们就简单起一个服务，可以调用我们写的所有接口，这是一个主文件，我们把它命名为index.js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const routerApi &#x3D; require(&#39;.&#x2F;router&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;); &#x2F;&#x2F; post 数据解析</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">&#x2F;&#x2F; 后端api路由</span><br><span class="line">app.use(&#39;&#x2F;api&#39;, routerApi);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听端口</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#39;success listen at port:3000......&#39;);</span><br></pre></td></tr></table></figure>

<p>这样我们node index.js之后就会监听3000端口了，到此我们的服务启动完毕，数据库部分也就打通了。</p>
<h5 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a><strong>前端页面</strong></h5><p>这里我们作为讲解，就不用写一些很好看的页面，有两个输入框就可以了，vue有双向数据绑定的功能，这样我们就可以很方便地获取输入框里面的内容，使用账号密码传给后端做sql查询。怎么样，是不是特别简单？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">form: &#123;</span><br><span class="line">    username: <span class="string">""</span>,</span><br><span class="line">    password: <span class="string">""</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如在data下面我们就这样来存储输入框的数据，如果大家可以做一些验证之类的操作，使用elementui组件库，你会发现新的世界。这里就不展开了。</p>
<p>然后再methods里面写一个login方法，用来与后端进行数据交互，这里也是很简单的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在script标签下面引入：</span></span><br><span class="line"><span class="comment">//const jwt = require("jsonwebtoken");</span></span><br><span class="line"><span class="comment">//const secret = "your string"; //自己的密钥</span></span><br><span class="line"></span><br><span class="line">login() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$axios</span><br><span class="line">        .get(<span class="string">"/api/login"</span>, &#123;<span class="comment">//请求的接口</span></span><br><span class="line">          params: &#123; <span class="attr">username</span>: form.username, <span class="attr">password</span>: form.password &#125;<span class="comment">//传递参数</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.data.length &gt; <span class="number">0</span>) &#123;<span class="comment">//假如返回有数据就使用token加密一下</span></span><br><span class="line">            <span class="keyword">const</span> token = jwt.sign(</span><br><span class="line">              &#123;</span><br><span class="line">                name: res.data[<span class="number">0</span>]<span class="comment">//这里就是数据库返回的用户相关的信息</span></span><br><span class="line">              &#125;,</span><br><span class="line">              secret,<span class="comment">//这是一个密钥，可以使用你喜欢的字符串</span></span><br><span class="line">              &#123;</span><br><span class="line">                expiresIn: <span class="number">86400</span> <span class="comment">//秒，到期时间，一天</span></span><br><span class="line">              &#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">this</span>.$store.commit(<span class="string">"SET_TOKEN"</span>, token);<span class="comment">//写入token</span></span><br><span class="line">            <span class="keyword">this</span>.$router.replace(<span class="string">"home"</span>);<span class="comment">//跳转到主页</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.$message.error(<span class="string">"登录失败"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大家可以看到我把token写到了vuex里面以及放到了sessionStorage，就是以一个全局的状态进行管理，比如以后再首页显示你的名字以及以后做权限控制等方面都很实用。以后可以使用this.$store.state.user的形式获取用户信息。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/26/jwtToken/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>假如大家在哪里需要使用用户数据的时候可以直接解析token，这里我为了方便专门多写了一个字段存放用户名以及身份等信息。这里解析数据我们就使用jwt自带的函数方法就好，token就是你存储在全局的token，secret就是你当初进行加密使用的那个，这样就可以顺利解析出来了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里也要引入</span></span><br><span class="line"><span class="comment">//const jwt = require("jsonwebtoken");</span></span><br><span class="line"><span class="comment">//const secret = "your string"; //自己的密钥</span></span><br><span class="line"></span><br><span class="line">jwt.verify(token, secret, <span class="function"><span class="keyword">function</span>(<span class="params">err, decoded</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">          User.id = decoded.name.teacherId;</span><br><span class="line">          User.username = decoded.name.teacherName;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>这篇文章我只讲了一些如何使用jwt来进行简单的登录验证操作，适合一些小白同学去尝试一下，毕竟这也是比较常用的npm包之一。网上其实很多教程都有说怎么去使用jwt进行验证，可能大家觉得这么一个简单的知识点有必要将那么复杂吗？其实你不明白小白心里的苦，当初我也是很简单的用法都不会，也是看了很多关于细节方面的实现，最后才有所领悟。</p>
<p>其实我的文章讲解应该是针对一些基础比较薄弱的同学们，我明白他们想做出一个简单的功能但却不知道怎么写的痛苦，挡当初自己也是这么过来的。我认为讲不明白别人的文章，可读性不大，虽然我也不知道能不能讲明白大家。</p>
<p>因为最近在完善毕业设计相关的事情，所以没有什么时间去看书学习，质量可能有所下降，以后一定分享更多的干货给大家。</p>
<p><img src="/2020/03/26/jwtToken/2.gif" alt></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>jsonWebToken</tag>
        <tag>登录验证</tag>
        <tag>数据库连接</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一下毕业之后该何去何从</title>
    <url>/2020/03/25/companyChoose/</url>
    <content><![CDATA[<h2 id="谈一下毕业之后该何去何从"><a href="#谈一下毕业之后该何去何从" class="headerlink" title="谈一下毕业之后该何去何从"></a>谈一下毕业之后该何去何从</h2><blockquote>
<p>不得不说，今年毕业季又有一大波毕业生涌向互联网行业，但是市场的岗位有可能也是不能满足毕业生的需求，我们又将走向何方。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/25/companyChoose/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>今天就不聊技术相关的事情了，因为最近也被一些bug搞得心烦意乱，实在没有心情去总结过程当中遇到的问题，不然有可能会更烦，索性就跟大家聊一点轻松的话题，也是最近所想的一些东西。（主要是我的bug还没有解决）</p>
<p>由于今年的疫情原因，我久久不能去实习上班，虽然每天都憧憬着去工作，但是仔细想想工作了就不能如自己所愿的学习了。换个角度想想自己可能还是赚到了，毕竟学习对自己以后的知识是比工作有好处的。最近也和一些朋友保持联系，大家也聊了一些关于工作的事情，有感而发遍写下了此文。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/25/companyChoose/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-毕业该如何选择"><a href="#02-毕业该如何选择" class="headerlink" title="02 毕业该如何选择"></a>02 毕业该如何选择</h2><hr>
<p>其实之前就有说过相关的事情，但是也是一笔带过。毕业了，就业就大多数同学都会选择的方向，找到一个比较好的公司，拿着不错的薪酬，过着为公司拼命的生活。也有可能有同学不想去就业，不甘做一份平凡的工作而转去创业，但是身边同学去创业也是屈指可数，不是没有技术就是没钱。虽然我不知道创业有多难，但我知道生存下来是很难的。还有就是可以选择考研或者考公等，也是一个方向。</p>
<p>总的来说，自己的选择没有对错，既然大家都选择了你所认定的方向，也一定要自己想法，比如关于工作压力，是否离家近，自己的性格，喜欢挑战或者喜欢稳定……</p>
<p>曾经我看到一部关于农村题材的电影《那山，那人，那狗》，电影中说到山里人为什么选择住在山里，主人公就说，他们住在山里，就像脚穿在鞋里，舒服。所以我们也不难想象为什么有人喜欢住在偏僻的地方，你把他们接到大城市去生活他们反而会不习惯。这就是有一种“不舒服”在里面。</p>
<p>其实找工作也是一样的道理，有人挤破脑袋去进大公司，拖着疲惫的身体回到宿舍只为了洗一个热水澡，却不想去思考其他事情。有人却喜欢生活在三线城市，每天下班买一袋水果舒缓一下工作一天的紧张感。但是他们相应的获得的满足感是不一样的，有人为了生活，有人为了体验生活。无非就是找到自己的“舒服”在哪。</p>
<p>举个简单的例子，有人为了工作而牺牲了自己的生活的时间，那你觉得他是否值得？我们是无从判断的，关键是看别人对“舒服”的定义是什么。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/25/companyChoose/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-我一定要去大公司吗"><a href="#03-我一定要去大公司吗" class="headerlink" title="03 我一定要去大公司吗"></a>03 我一定要去大公司吗</h2><hr>
<p>经常听别人说去大公司好呀，更好的福利，更好的薪酬，还有不错的发展前景。其实这些我们又何尝不知道呢？只是奈何自己太菜去不了大公司而已，但是当你有机会去到大公司，心里就会觉得，这里都是汪洋大海，自己作为公司里面很小的一份子，能力得不到发展。</p>
<p>我们互联网有一个很经典的名言，面试造火箭，入职拧螺丝。其实这也是很正常的，校招生一般看重的就是你的可锻性，社招看重的就是可用性。有朋友说，入职了之后自己却变得瞎忙活，每天总觉得很忙的样子，但是一天下来却好像什么也没有做到，总感觉自己一直在退步的样子。相信很多人都深有感触，实习的时候，每天上班除了做一些业务上的开发之外你又不能做其他的事情，搞来搞去也就是cv的操作。一旦发现你做其他的事情，就会觉得你的工作不饱和。</p>
<p>相信我们面试的时候我们都经历了很长时间的刷题以及准备面试相关的事情，说白了就是背答案。但是你的答案是否有技巧就另说了。好不容易我们拿到了自己喜欢的offer，但是却失去了学习的激情，忘记了很多基本的知识。有同学说，大学四年，我除了找工作那段时间是最努力的，可以说是知识学习的巅峰（除了高三）。但是，现在无论我们去大公司还是小公司，面试是必不可少的一个环节，先不说后面的事情，现在小公司面试也要“造火箭”了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/25/companyChoose/4.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>我觉得你是否要去大公司要主要考虑这几个方面：</p>
<ul>
<li>发展空间</li>
</ul>
<p>人总是要成长的，加入你去到一个大公司没有任何成长那也是白忙活。在现在这段刚毕业的时间里，我们要抓住尽可能的机会去学习某一项技术，因为你过了30岁你就把重心放到别的事情上面了，家庭、生活、社交等。总的来说一定要看一下这家公司的技术栈是否符合你的技术栈，假如你不熟悉可以看一下项目时候有前景，或者你可以看一下团队里面是否有很厉害的牛人可以助你一臂之力。</p>
<p>假如上面的你觉得对你自身的帮助不大，那你可以找别的公司看一下，一定会找到适合自己的。我觉得大家一定要看重一下发展这一块的事情，因为这是对自己最有效的投资，不论以后去到那家公司你都是要学习的，你也是要用自身的技术驱动产品和业务的发展，然后业务创造价值。</p>
<ul>
<li>公司氛围</li>
</ul>
<p>其实我觉得这个是也是比较重要的因素，一个公司假如整天都是属于一种比较混乱的状态，人员分配不足，每个人分工也不明确，更加可怕的就是整天开会。不仅自己的技术得不到成长，你的业务能力也得不到成长。反过来，要是你遇到一个公司每天的技术氛围都很活跃，除了工作都会探索和讨论一些新的技术，大家相处十分融洽，有困难也会比较快得到解决，那样就更好了。</p>
<p>虽然你是在工作，但是却有一种生活的感觉在里面。其实氛围这种东西是比较虚的，但是缺少了氛围你就会觉得工作总会有一些不如意。要是每一个人都沉默在自己的格子间里面，你是不是会觉得有一种什么气氛笼罩在你的周围，让你惶恐不安？</p>
<ul>
<li>兴趣驱动</li>
</ul>
<p>我认为要想在某一个领域有长久的发展，首先肯定是兴趣驱动你的发展。还是那句老话，兴趣是最好的老师。大家认为数学家为什么整天喜欢钻研一些看似没有一点用处的数学题呢？那我就反问你一句，你为什么喜欢刷一些没有任何营养的抖音视频呢？</p>
<p>不难看出，关键是看你接触某种东西以后是否会产生一种愉悦感，大脑不会骗人，当你愉悦的时候会产生一种多巴胺的物质，让你感觉身处比较轻松的环境。无非就是数学题可以让数学家的精神得到满足，而我们刷抖音也是因为我们的精神得到满足了。</p>
<p>按照这个道理，我们有没有可能想刷抖音一样痴迷于学习呢？</p>
<p>这里只是一些参考的信息，但是归根结底的选择还是在于人身上。大家可以考虑的主要的因素大概是这样，没办法做到面面俱到。我看了知乎上面也有很多人探讨关于去大公司还是小公司的问题，其中有一个回答是让我比较印象深刻的，他说毕业前两年一定要去小公司锻炼一下，这样你的创造力、决策力、承受力和抗压能力都会得到一定的成长。也有一些人说大公司的各种规则制度都比较完善，有完整的培训体系，不要钱都要去大公司。</p>
<p>关于这个问题的矛盾也是比较突出的，毕竟每个人的经历不一样，他也是按照自己的经历说出来了自己的所思所想。我们也不要去喷别人带偏别人的思想等话，只能给建议，不能给很多建议。有时候你过多的建议就会让人跟着你的思路走。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/25/companyChoose/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>说实话，这是一篇比较杂的文章，只是记录了自己的思想，并没有什么有实质性的建议，大家就一笑而过就好。关于找工作大家也要遵从自己的内心，对比自己心里所定义的那个“舒服”的概念是什么。找到自己所定义的理想生活，不一定是最好的，但是一定是最“舒服”的。</p>
<p><img src="/2020/03/25/companyChoose/2.gif" alt=" "></p>
]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>毕业</tag>
        <tag>工作</tag>
        <tag>生活</tag>
        <tag>技术成长</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端小白也能搭建上线系统</title>
    <url>/2020/03/24/vueProject2/</url>
    <content><![CDATA[<h2 id="服务端小白也能搭建上线系统"><a href="#服务端小白也能搭建上线系统" class="headerlink" title="服务端小白也能搭建上线系统"></a>服务端小白也能搭建上线系统</h2><blockquote>
<p>继上一篇文章之后，我把开发的系统放到阿里云服务器当中，并且成功上线。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/24/vueProject2/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>继上一篇文章之后，上一次我写的是前端搭建的后台系统如何与本地数据库或者线上数据库连接的文章，但是我们所有开发的项目不可能是放在本地运行的，怎么也得把它放到服务器上面，让别人也可以通过你的公网地址访问，今天折腾了一下还是挺费劲的，遇到了几个坑，接下来就跟大家说一下如何解决这些问题。</p>
<p>但是你如果要把项目放到服务器的话肯定是要有一台属于你的服务器，不然的话也没办法做。如果你还没有的话可以去阿里云买一个，学生价也是比较便宜的，一年也就100多。这里我是推荐大家一定要玩一下服务器怎么操作，也是作为前端的必备技能之一，废话少说，开始。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/24/vueProject2/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-连接服务器"><a href="#02-连接服务器" class="headerlink" title="02 连接服务器"></a>02 连接服务器</h2><hr>
<p>首先我们购买服务器之后就进行连接一下，关于怎么购买和配置等的内容大家可以网上找一下，很简单的操作。</p>
<p>我们可以选择一个连接工具，我这里选择的是FinalShell，大家也可以选择其他的。我们先打开软件新建一个链接，输入服务器的公网IP和密码你就可以连接了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/24/vueProject2/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>由于服务器大都是使用linux系统，所以大家就必须知道一些linux的指令，方便我们进行文件操作。常用的指令就几种而已，复杂的基本上用不到，作为初学者的我们就了解即可。</p>
<ul>
<li>cd 进入某一个文件夹，可以进入多级，如 cd var/www/ 这种</li>
<li>ls 查看当前的文件夹有哪些文件或者文件夹</li>
<li>pwd 查看当前你的位置是哪里</li>
<li>vim xxx 编辑xxx这个文件，进去之后输入i就可以编辑了，完了之后按退出键(esc)，然后输入:wq退出并保存</li>
<li>cat xxx 查看xxx这个文件</li>
</ul>
<p>了解了这些你就可以上手服务器部署了，其实是比较简单的操作，但是有一些删除的指令就不要乱学了，防止小白乱操作整坏了自己的服务器，这个finalshell可以通过右键进行上传或者删除操作，适合入门和那些习惯window的小伙伴。</p>
<h2 id="03-文件上传"><a href="#03-文件上传" class="headerlink" title="03 文件上传"></a>03 文件上传</h2><hr>
<p>连接上了之后，基本上和window的操作差不多，你选择一个位置放你的项目，我一般是放在 var/www下面。大家也可以选择你任意的位置，记住放在哪里就好了。</p>
<h5 id="路径引入问题"><a href="#路径引入问题" class="headerlink" title="路径引入问题"></a><strong>路径引入问题</strong></h5><p>我们在上传之前要对你的项目进行打包，执行npm run build 进行项目的打包，这是你项目上线部署才需要做的，一般我们平时开发都是使用npm run dev 来启动一个本地的服务器。但是你在打包之前要改一些东西，不然你的项目放上去之后是无法访问的。要改哪里呢？</p>
<p>我们在项目根目录之下有一个config的文件夹，里面有一个index.js的配置文件，修改dev下面的assetsPublicPath的值，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line">    env: require(<span class="string">'./dev.env'</span>),</span><br><span class="line">    port: process.env.PORT || <span class="number">7999</span>,</span><br><span class="line">    autoOpenBrowser: <span class="keyword">true</span>,</span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="string">'./'</span>,</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">        <span class="string">'/api'</span>: &#123;</span><br><span class="line">            target: <span class="string">'http://localhost:3000/api'</span>,</span><br><span class="line">            changeOrigin: <span class="keyword">true</span>,</span><br><span class="line">            pathRewrite: &#123;</span><br><span class="line">                <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>我们平时开发的是 ‘/’ ，现在我们要改成 ‘./’。这个值表示你的项目打包之后，index.html里面引用资源的相对路径。不得不说，这个坑其实我之前就踩过一次，但是没办法之前没有好好总结下来，没有形成总结的习惯，现在我知道写博客的好处了，要是以后我再踩这个坑……不，以后不会了。</p>
<h5 id="静态资源引用"><a href="#静态资源引用" class="headerlink" title="静态资源引用"></a><strong>静态资源引用</strong></h5><p>我们进行项目打包之后，根目录下面会生成一个dist文件夹，然后我们可以看一下里面的内容，除了一个static和一个html文件其他就没有了。这就是单页应用，最后只导出一个出口。</p>
<p>我们可以在之前写好的server文件夹下面的index.js文件修改一下，我们之前是使用express框架搭建的，所以我们在部署上去的时候加上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'../dist'</span>)));</span><br></pre></td></tr></table></figure>

<p>这里的意思就是我们引入静态文件的内容，如果没有引用我们的项目也是无法启动的，显示不出什么页面。</p>
<h5 id="Nginx代理问题"><a href="#Nginx代理问题" class="headerlink" title="Nginx代理问题"></a><strong>Nginx代理问题</strong></h5><p>我们的上线网站是给别人看的，所以我们设置一下代理，让所有的请求都可以定向到你的项目地址。我们配置之前首先要进行一下nginx服务器的安装，在服务器上面也是比较简单的，当然你的服务器也要有node环境才可以，一行命令搞定：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -y nginx</span><br></pre></td></tr></table></figure>

<p>然后安装完成之后我们就去它的配置文件看一下，默认的路径就是在 /etc/nginx/nginx.conf 下面，我们也不用去更改。我们可以通过cat命令查看一下，假如你要进行配置就使用vim命令。这里我们使用vim命令进去，找到server这一地方，像我这里配置：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/24/vueProject2/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>server_name就是你的IP地址，也可以写你的域名，不过你要有域名相关的配置和解析，这里我们就暂时不管它。然后我们看到location这里，就是写你的项目放到的地方，我就是放到了var/www/vue-admin下面。修改完了之后我们退出并保存。重启一下nginx服务器，不然可能配置不生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<p>这样配置后我们就可以每次访问这个公网IP+端口之后（默认80端口）就会找你的项目，这样你的项目就会显示了。综上，其实我们就在写bug和找bug之间徘徊。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/24/vueProject2/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-启动项目"><a href="#04-启动项目" class="headerlink" title="04 启动项目"></a>04 启动项目</h2><hr>
<p>大家先别急，我们上面是配置了一些东西，但是项目还没有启动的，我们要做的是先安装一下相关的依赖。我们把项目的package.json文件上传到与dist文件夹同级下面，然后执行npm install 就好，如果安装不成功或者网速很慢，大家可以切换到国内的淘宝镜像即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>这个过程可能有一点费时间。安装完成之后我们进入server的文件夹，执行node index.js启动我们的服务，它会进行数据库的连接，我们就可以使用写好的接口查询数据库。值得注意的是我们不能使用本地的数据库连接，因为线上是访问不到你的数据库的，最好在服务器上面安装mysql服务器，把数据都导进去里面，关于这部分也比较简单，大家网上查阅一下即可。</p>
<p>项目启动之后我们我们可以输入你的ip+端口访问你的项目，如12.56.567.789:3000这样。因为它默认的是80端口，我的端口已经被占用了，所以我就采用3000端口，就是server启动后的监听的3000端口，这里你可以改成其他的，但是访问的时候你也要跟着变。</p>
<p>可能有同学的服务器端口没有开放，导致项目运行不成功，我们可以去到阿里云的控制台看一下，找到安全组配置，开放你的端口就可以了，因为每次搞都比较麻烦，索性我所有端口都开放了。</p>
<p>如无意外我们就可以看到你自己的项目了，如果有报错或者其他的可以看一下浏览器的控制台。但是到这里我们就会出现一个问题，就是我们如果关闭了服务器我们的server服务就会停止了，这样不行呀，我的页面不可能一直这样挂着。所以我们就使用一个比较牛的东西 pm2 ，叫进程守候。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/24/vueProject2/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="05-pm2"><a href="#05-pm2" class="headerlink" title="05 pm2"></a>05 pm2</h2><p>说实话一开始听说这个东西的时候就觉得挺厉害的，因为没有接触过，而且听起来也有点东西。其实当你用起来之后你就会觉得就是安装一个npm包一样的原理。</p>
<p>首先使用它肯定要进行安装的操作，也是简单的一句命令就搞定了，在 / 目录下面执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>

<p>然后添加一下到环境变量里面，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>在文件的最底部添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_HOME=/root/node-v8.9.1-linux-x64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NODE_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p>退出并保存后重新编译一下这个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>到现在为止我们已经搞定了pm2的安装以及配置过程了，接下来我们就美滋滋地去启动我们的项目了。在server文件夹下面，输入以下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start index.js</span><br></pre></td></tr></table></figure>

<p>我们发现即使我们关闭了窗口，程序一样完美运行。到此为止我们的配置以及所有的手续都弄完了，大家也应该顺利完成了自己的项目吧。</p>
<h2 id="06-小结"><a href="#06-小结" class="headerlink" title="06 小结"></a>06 小结</h2><p>其实回想一下整个过程，说简单也是有一点繁琐，但是这始终是我们都要去尝试一下的操作，我一开始接触的时候连基本的命令都不会，但是没关系，看教程慢慢搞就好，反正坏了你可以重装一下。计算机的同学都应该多折腾一下这种繁琐的配置，因为你以后也会接触的，提前锻炼一下。</p>
<p>假如一开始我们就顺利地执行下来，我想你已经不是一个小白了，而是变成了服务端老鸟了，如果自己对服务器比较感兴趣的可以多去学习一个一下linux相关的指令，以后转成运维工程师也不是不可。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/24/vueProject2/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>









]]></content>
      <categories>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>服务端</tag>
        <tag>线上环境</tag>
        <tag>进程守候</tag>
      </tags>
  </entry>
  <entry>
    <title>教你十分钟搞定毕业设计</title>
    <url>/2020/03/23/vueProject/</url>
    <content><![CDATA[<h2 id="教你十分钟开发后台管理系统"><a href="#教你十分钟开发后台管理系统" class="headerlink" title="教你十分钟开发后台管理系统"></a>教你十分钟开发后台管理系统</h2><blockquote>
<p>本文叫你如何轻松配置系统设计的功能架构，让开发不再困难，剩下的你就可以cv操作了。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>如无意外，大家最近也应该也是在家里学（闲）习（鱼）吧，不过我还是建议一下大家，新的风暴已经出现，怎么能够停滞不前… 似乎想起了什么。不论如何现在是大四狗最忙碌的时候了，而且大家也应该利用这段时间好好巩固自己的知识点，争取在一两个月内做出一个比较像样的项目，好给自己的大学一个交代。</p>
<p>不管怎么说，一个好的项目是可以写在自己的简历上面的，一不小心可能你就凭着这个项目拿到满意的offer。所以本文就给那些还在困惑的孩子们一个导向，希望你们也可以做出一个属于自己的项目。我深知大家的难处，因为我之前也是苦于这种设计系统的问题，找了多方资料也不怎么理想，所以我觉得分享是对我们程序员最好的回报。</p>
<p>最近我也是在弄相关的事情，奈何导师又给你一个新的需求。还能怎么办，做呗。这一次我就新增了一个后台管理系统，方便管理人员的操作，折腾了一晚上加一早上，尝试了几种方案都不太满意，现在我就把自己遇到的坑和问题都说出来，为大家填坑。我使用开源的项目vue+element-ui+mysql+node+express的组合。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-开源管理系统"><a href="#02-开源管理系统" class="headerlink" title="02 开源管理系统"></a>02 开源管理系统</h2><hr>
<p>大家应该对现在的前端框架vue比较熟悉了，基本上如果你是从事前端行业的话是必学的框架之一。推荐这个框架是因为上手比较简单，对新手比较友好，而且生态完善，每天都有无数的程序员为你排忧解难，这就是生态好的好处。好了废话不多说，接下来就是推荐两个比较好的开源项目。</p>
<ul>
<li><a href="https://panjiachen.gitee.io/vue-element-admin-site/zh/" target="_blank" rel="noopener">vue-element-admin</a></li>
</ul>
<p>这是一个比较大型的后台管理系统，包含了很多的东西与功能，如果你是一个新手的话可能hold不住，毕竟他的项目是比较完善的，但好在也有完善的文档。大家自己可以自由查看，当然你也可以好好研究里面的架构层次是怎么设计的。一般来说你要学习某一项新的技术，查看别人现成的项目是很有帮助的。毕竟人家可是掉了一地的头发才开发出这么一个伟大的系统，造福大家年轻的程序员。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<ul>
<li><a href="https://preview.pro.ant.design/dashboard/analysis" target="_blank" rel="noopener">Ant Design Pro</a></li>
</ul>
<p>这是一个由蚂蚁金服出品的后台管理系统，也是非常不错的模板项目，可以做到开箱即用，界面美观，文档详细，居家旅行都可以一看。跟前面的一样，这也是一个庞大的框架，因为也有很多集成的功能，但是大家也可以看一下里面的架构是怎么设计的，相信你会有一个很不错的收获。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>不过大家千万不要直接拿来当毕业设计哦，但是说一个比较实在的话，很多高校的讲师并不会关注互联网的发展，也有一些还是教你用jQuery的，想想都觉得可怕。上面提到的模板有老师不知道也是正常。所以同学们一定要关注互联网的发展，特别是前端，隔三差五更新一个新的技术出来也是正常的。</p>
<p>我相信很多高校也该没有教你这些东西和技术，也没有推荐你看一下那个开源项目很不错，基本上都是c语言、c++、java、jsp等编程语言的入门级学习，好了不扯这个了。</p>
<p>比较好的我就觉得是这两个了，有一些是结合bootstrap的，大家也可以看一下。不过现在主流的都是使用element-ui和ant-design组件库，所以我们也顺应潮流。</p>
<h2 id="03-从零开始"><a href="#03-从零开始" class="headerlink" title="03 从零开始"></a>03 从零开始</h2><hr>
<p>说是从零开始，但是你也必须要有js基础，有命令行的基础，你知道什么是node和npm这些东西。你可以去官网上面先安装vue，使用他们的脚手架<a href="https://cli.vuejs.org/zh/guide/installation.html" target="_blank" rel="noopener">vue-cli</a>搭建一个项目。这个过程比较简单，你只需要几个常用的命令就可以实现了。不过这次我使用了github上面的一个开源项目，因为省去了自己配置的步骤（是因为懒）。<a href="https://github.com/luichooy/vue-admin" target="_blank" rel="noopener">查看地址</a></p>
<p>接下来讲的就是如何自己写接口，连接mysql数据库以及通过前端的调用返回数据，这里就不是假数据了，而是真实存在的数据。</p>
<p>在开始之前，你需要把项目clone下来，执行npm i 安装一下本身的依赖。</p>
<p>假如你的网不是很好，你可以切换到淘宝的镜像源地址，只需在命令后面加上–registry= https: //registry.npm.taobao.org即可。国内的相对来说比较快，也不容易出错，假如你不加的话可能会安装失败。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>

<p>然后你还要安装一下以下依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install element-ui --save  （回车，这是组件库）</span><br><span class="line">npm install axios --save  （回车，这是请求发送的方法）</span><br><span class="line">npm install mysql --save  （回车，数据库连接）</span><br><span class="line">npm install express --save  （回车，便于获取数据）</span><br><span class="line">npm install body-parser --save  （回车，解析响应体）</span><br></pre></td></tr></table></figure>

<p>然后我们可以在main.js下面把axios添加到vue的原型上面，方便调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">Vue.prototype.$axios = axios <span class="comment">//全局注册，使用方法为:this.$axios</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/7.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-数据库"><a href="#04-数据库" class="headerlink" title="04 数据库"></a>04 数据库</h2><hr>
<p>数据库我们选用的是关系型数据库mysql，可视化工具是navicat。</p>
<p>首先大家可以看一下刚创建好的项目，我们可以在src目录下面创建一个文件夹server，这个文件夹用于存放数据库配置和数据库连接相关的代码。</p>
<p>文件夹里面创建几个文件，分别用于存放配置，连接等相关内容。为什么要分这么多个呢？原因就是我们之前提到的解耦问题，把耦合性降到最低。方便以后修改和更新接口等操作，不然如果你全都写在一个文件里面就会很繁琐。</p>
<ul>
<li>api.js 用于配置一些接口，就是你以后调用的接口返回相应的数据库数据</li>
<li>sqlMap.js 用于编写一些sql语句，就是上面的接口的实际实现过程</li>
<li>router.js 接口路由相关</li>
<li>index.js 这里就是总的导出文件，就是简单的http服务</li>
</ul>
<p>接下来实现每一个文件的编写</p>
<h5 id="api-js"><a href="#api-js" class="headerlink" title="api.js"></a><strong>api.js</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">const</span> sqlMap = <span class="built_in">require</span>(<span class="string">'./sqlMap'</span>);</span><br><span class="line"><span class="comment">//创建链接对象</span></span><br><span class="line"><span class="keyword">const</span> pool = mysql.createPool(&#123;</span><br><span class="line">    host: <span class="string">'47.98.151.134'</span>,</span><br><span class="line">    user: <span class="string">'root'</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    password: <span class="string">'Wqs2019..'</span>,</span><br><span class="line">    database: <span class="string">'design'</span>,</span><br><span class="line">    multipleStatements: <span class="literal">true</span>    <span class="comment">// 多语句查询</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getValue(req, res, next) &#123;</span><br><span class="line">      pool.getConnection(<span class="function">(<span class="params">err, connection</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sql = sqlMap.getValue;</span><br><span class="line">        connection.query(sql, (err, result) =&gt; &#123;</span><br><span class="line">            res.json(result);</span><br><span class="line">            connection.release();</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="sqlMap-js"><a href="#sqlMap-js" class="headerlink" title="sqlMap.js"></a><strong>sqlMap.js</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sqlMap = &#123;</span><br><span class="line">  getValue: <span class="string">'SELECT * FROM test;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sqlMap;</span><br></pre></td></tr></table></figure>

<h5 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a><strong>router.js</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> api = <span class="built_in">require</span>(<span class="string">'./api'</span>);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/getValue'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  api.getValue(req, res, next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<h5 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><strong>index.js</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routerApi = <span class="built_in">require</span>(<span class="string">'./router'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>); <span class="comment">// post 数据是需要</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端api路由</span></span><br><span class="line">app.use(<span class="string">'/api'</span>, routerApi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'success listen at port:3000......'</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码完善之后你就可以在server的目录下面执行，node index.js开启服务，它会监听3000端口的内容。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="05-前端文件"><a href="#05-前端文件" class="headerlink" title="05 前端文件"></a>05 前端文件</h2><hr>
<p>接下来我们就随便找一个文件测试一下，我们可以选择刚刚创建好的helloworld.vue文件测试一下，写一个点击事件，然后在methods里面实现请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;p @click&#x3D;&quot;go&quot;&gt;首页&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      go() &#123;</span><br><span class="line">         this.$axios.get(&#39;&#x2F;api&#x2F;getValue&#39;, &#123;</span><br><span class="line">            params: &#123;&#125;</span><br><span class="line">          &#125;).then( (res) &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;res&#39;, res);</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如无意外，当你运行vue项目的时候，这是会报错的。</p>
<p>因为我们刚刚说到你的服务器是监听3000端口，但是你的vue项目是监听8080端口，是不通的。所以我们想一下在项目的config目录下面的index.js文件，里面是可以设置跨域相关的配置，我们只需要把dev下面的proxyTable写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line">    env: <span class="built_in">require</span>(<span class="string">'./dev.env'</span>),</span><br><span class="line">    port: process.env.PORT || <span class="number">8080</span>,</span><br><span class="line">    autoOpenBrowser: <span class="literal">true</span>,</span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://localhost:3000/api'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这段代码的意思就是把任何以api开头的请求都定向到target这个地址下面。所以配置完成之后重新编译一下，应该就没有问题了，能够正确返回数据。我点击首页的时候就会发送请求并顺利返回数据。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/3.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>另外注意的是：</p>
<p>假如你想要请求本地的json数据数据，我发现一定要放在static的目录下才可以，不然是无法获取的。不过我们一般也要或者线上的数据，或者连接你本地的数据库。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/23/vueProject/8.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="06-小结"><a href="#06-小结" class="headerlink" title="06 小结"></a>06 小结</h2><hr>
<p>不得不说，代码是要经常打的，不然时间久了你就会忘记很多事情，也忘记很多配置啥的。一开始我遇到的坑就是直接调用mysql的时候，发现Net.createConnection is not a function的问题，困扰许久，后来才知道不是mysql的锅而是在于node本身。你需要起服务才可以访问数据相关的内容。</p>
<p>在此也推荐大家去看一下node相关的技术，以及express和koa2等，可以方便地搭建后台以及编写接口，这些都是web框架，详情大家也可以去官网看一下，也有很多入门级别的教程，值得一学。毕竟现在node已经走进了大家的视野，就像之前那句话说的，是业务成就了人，驱动了你的成长。</p>
<p>好了，本文就说到这里，文章同步发送到微信公众号《前端小时》，欢迎大家关注，觉得不错可以点赞收藏转发。大家加油！</p>
<p>参考文章</p>
<ul>
<li>segmentfault  vue+node+mysql搭建个人博客（一） <a href="https://segmentfault.com/a/1190000012186439#item-1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012186439#item-1</a></li>
</ul>
<p><img src="/2020/03/23/vueProject/2.gif" alt></p>
]]></content>
      <categories>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>毕业设计</tag>
        <tag>代码配置</tag>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员六个赚外快的方法</title>
    <url>/2020/03/22/howToEarnMoney/</url>
    <content><![CDATA[<h2 id="程序员六个赚外快的方法（建议收藏）"><a href="#程序员六个赚外快的方法（建议收藏）" class="headerlink" title="程序员六个赚外快的方法（建议收藏）"></a>程序员六个赚外快的方法（建议收藏）</h2><blockquote>
<p>在你低头写代码的同时，很多人都在高调赚外快</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/22/howToEarnMoney/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>近日闲来无事，总喜欢钻研一些“技巧”型的东西，也一直考虑别的除技术以外的东西（虽然现在技术不好），想想也觉得无事，毕竟可能以后就没有什么时间去想了。</p>
<p>一直都炒的很热的问题，关于程序员如何去赚取外快的问题。以前自己的想法就是去接单，做私活呀，钱来的很快，但是也很累。想想这个终究也不是什么长久之计，反观一下当今的市场，想想还是有一些可以适合程序员做的事情的。接下来一一分享一下。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/22/howToEarnMoney/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-方法论"><a href="#02-方法论" class="headerlink" title="02 方法论"></a>02 方法论</h2><hr>
<p>认真思考了一下，大概有6种方法可以值得一试，当然是在你的技术有一定的实力，或者你的关注人数比较多的时候，有个人的影响力的前提下，利用以下介绍的方法会非常奏效。</p>
<ul>
<li>接外包项目</li>
</ul>
<p>这是一个非常好的赚钱方法，首先是因为给的钱多，对于技术强的同学来说不是什么大问题，但是对于菜鸟一族来说就先别碰这个东西了，你也做不来。也许很多人都抱怨说自己的工作已经很辛苦了，哪里还有时间这搞这些的东西呀，恨不得回家洗洗睡。这里我就像大家灌一碗毒鸡汤了，时间就像海绵，挤一下总会有的，看你是不是想赚钱而已。大家也可以试一下这些平台：</p>
<ol>
<li>猪八戒网</li>
<li>码市</li>
<li>云沃客</li>
<li>解放号</li>
<li>程序员客栈</li>
</ol>
<p>大家可以先去了解一下，试一下水，万一有点东西呢？</p>
<ul>
<li>做运营</li>
</ul>
<p>相比于上面这种接外包的形式，做运营就是比较好的方案了，但是唯一的缺点就是涨粉比较难，不仅要你持续输出，获取第一批种子用户，还需要你的文章价值和质量都比较高，得到别人的认可。如果大家比较喜欢去分享和码字的话一定要去尝试一下，不仅可以锻炼你自己的能力，还能赚一些钱（别人打赏或者广告）。更重要的是你可以建立自己的品牌，当你有自己的品牌的时候，很多事情就比较顺利了。</p>
<p>其实现在大家都提倡知识付费的时代，假如你有一种分享为乐的心态，一定要尝试这种方法。另外现在掘金小册也是一种不错的知识付费的平台，还有极客时间，知识星球等。大家可以根据自己的需求来选择属于自己的平台。呼吁大家把更优质的内容分享出来，让大家都得到提升，自己也得到收获。</p>
<ul>
<li>讲师</li>
</ul>
<p>这种方法需要你有比较多的时间，也需要你有一定的社会阅历和公司经验，有说话技巧以及口才等。你可以选择一些培训机构，申请去做一些兼职的讲师，分享社会工作经验已经学习方法等。还有一些高校也可以去做兼职讲师，因为高校很多都是在书本上的知识，很多一线的公司用的技术，需要的知识高校都接触不到，更重要的是很多老师也愿意请你们来普及一下社会的需求，同步自己的教学内容。</p>
<p>一般来说你也会得到相应的报酬，几千几万的都有，一般你的工作经验起码也要几年以上别人才会相信你说的东西，而且你最好是一线知名的企业，才会有更多的机会做这件事情。</p>
<p>除了培训机构和高校，你也可以去尝试录制课程，然后发布在各大教学平台，比如极客时间，慕课网等。这种方法也是不错的，但是总归那句话，有知识和有阅历。我们可以去看一下线上的课程卖的价格也不低，虽然不会都到你的手上，但是你也可以获得大部分的收益。</p>
<ul>
<li>理财投资</li>
</ul>
<p>关于理财投资，很多人就觉得是去炒股等高风险高收益的途径，但是作为程序员还是有几分理性在内心的。大家可以去尝试买基金、投资等风险相对比较低的方式。如果你实在是理财小白，你也可以把工资放余额宝或者微信理财，也是不错的。前提是你的本金足够多，收益才会多。</p>
<ul>
<li>积累人脉，做咨询</li>
</ul>
<p>这种方法一般都是工作5年以上的老司机才会比较好，一来你的人脉积累肯定是有的，这时候你也建立起自己的朋友圈（不是微信朋友圈），你可以建立自己的圈子，提供收费咨询等。这也是一种不错的选择。</p>
<p>我觉得做咨询相对来说是一种零成本的服务，唯一要的就是你的脑子。所以大家要是以后想在这个方向发展的话，记得从现在起开始就好好充电，争取实现自己的目标。</p>
<ul>
<li>大厂内推</li>
</ul>
<p>关于内推，大家可能不知道推荐别人成功入职也是有奖金的，而且奖金还不少呢。之前听网上说像字节跳动的大公司，内推成功的话就会拿到几千块的奖励。所以很多大厂的程序员都喜欢推荐别人，不是因为他们有多好，而是有收益拿。当然也有一些是想真心让学弟学妹找到好工作，回馈社会的人。</p>
<p>所以你如果是大厂的开发人员，每一年你都可以拿着你的个人内推码发给学弟学妹，那么他们如果成功入职了，你就会拿到相应的奖金。但是这种方法也不是每个人都有机会，毕竟去大厂的人还是少数，小公司应该也不会有这种内推的操作。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/22/howToEarnMoney/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-思考"><a href="#03-思考" class="headerlink" title="03 思考"></a>03 思考</h2><hr>
<p>其实个人是很羡慕一些人，能够在工作之余拿出自己的时间做别的事情，不管是学习也好，赚外快也好，奈何自己现在没有这种能力，毕竟目前的工作经验不足，相信自己在未来几年会有所发展。能够尝试一下上面提到的方法，那么我们现在能做什么呢？当然是学习充电呀。</p>
<p>之前很多人都说学习无用论，老是拿别人初中毕业，如今身家多少的事情来打压我们。其实我对这种人是很鄙视的，为什么呢？因为你看到的是一个人，这里面的偶然性非常高，或许他中间买彩票呢？或者跟上了一个很好的机会呢？或者刚好老板提拔？或者刚好创业成功？这些我们是不知道的，我们看到的只是他的结果。</p>
<p>所以我想说不要觉得别人偶然的成功，来断定我们的学习无用，假如你说90%的初中毕业生如今都混的很好，我就相信了。现在大家的学习素质或者学习激情都普遍提高，大家也越来越支持知识付费的时代，大家也应该努力创建出优质的内容，回馈社会，尊重知识产权，尊重劳动成功，别人自然喜欢给你买单。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/22/howToEarnMoney/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>通过上面的介绍，我相信很多小伙伴都会想试一下，但是大家也不用急。毕竟像那句话说的“钱是赚不完的，活是干不完的”一样，如果你是在校的大学生，一定好好利用这段充裕的时间好好提升自己，特别是技术相关的东西，对以后找工作很有帮助；如果你是在职的职场人士，你可以根据自己的时间和精力选择你认为合适的方式，理性选择；如果你是成功人士，那…那就教一下我怎么做，感激不尽！</p>
<p>好了，以上是这篇文章的全部内容，觉得文章不错的点赞收藏，文章同步到公众号《前端小时》，欢迎关注！希望大家都可以找到自己的方向，共勉！</p>
<p><img src="/2020/03/22/howToEarnMoney/2.gif" alt></p>
]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>前端</tag>
        <tag>程序员</tag>
        <tag>副业</tag>
        <tag>赚外快</tag>
      </tags>
  </entry>
  <entry>
    <title>小白看大型网站架构设计方案</title>
    <url>/2020/03/21/architectureLearning/</url>
    <content><![CDATA[<h2 id="小白看大型网站架构设计方案"><a href="#小白看大型网站架构设计方案" class="headerlink" title="小白看大型网站架构设计方案"></a>小白看大型网站架构设计方案</h2><blockquote>
<p>大型网站的架构设计一般与小型的网站差别很大，考虑的技术点也是不一样的</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>最近对大型网站的架构比较感兴趣，就看了一本关于架构的书籍，顺便记录一下自己的所思所想。</p>
<p>我们知道想淘宝、微博、12306等的软件设计，必然与我们平时使用的软件设计不同，原因是前者涉及到大量的数据存储，大量的用户访问，还有就是高并发量（瞬间访问量）。假如有其中的一个环节没有做好的话肯定是影响整体的性能，因此就会出现短板效应。</p>
<p>我们看到的例如准点抢票、双十一抢购、微博热搜等都可能会导致服务器宕机，网络瘫痪等结果，一方面可能是网络拥挤，但是更重要的是网站的架构设计，是否能够满足高并发、高可用（7*24小时）的状态。下面就看一下大型网站的架构设计是怎么一步步实现的。</p>
<h2 id="02-网站特点"><a href="#02-网站特点" class="headerlink" title="02 网站特点"></a>02 网站特点</h2><hr>
<p>我们从表面上看到的特点就是这两个，网站访问量大，网站并发量高。除此之外，我们就不会关心其他的事情了，这是用户能想到的，也是用户最想解决的两个迫切的问题。但是在开发的技术人员看来，却要考虑很多的因素，总的来说有以下几点：</p>
<ul>
<li>高并发</li>
</ul>
<p>网站要承受一瞬间访问的量是多少，比如双十一的抢购并发量可以达到亿的级别，这么高的并发是普通网站根本承受不了的压力，不仅仅是服务器多少的问题，还要考虑服务器之间的设计方案等因素。</p>
<ul>
<li>高可用</li>
</ul>
<p>一开始我也不懂什么是高可用，简单来说就是7*24小时保持服务正常。因为你不能保证用户在大半夜会不会浏览你的网站，所以我们要保证服务是一直正常的。通常来说，一些小型的网站或者系统会在晚上0点就进行更新操作，限制人员的访问。</p>
<ul>
<li>海量数据存储</li>
</ul>
<p>涉及到大型网站，一般用户都是海量的，需要考虑如何存储用户数据、用户浏览信息等。比如我们每天用的微信，每天发布的朋友圈以及聊天的信息都是海量的，存储在腾讯专门的服务器集群（很多服务器）。</p>
<ul>
<li>安全系数高</li>
</ul>
<p>不可否认我们每天都会涉及一些银行交易，微信转账或者支付宝转账等操作，其实你想一下你的现金变化只是一个数字的改变而已，想想都觉得令人担忧。比如你的支付宝余额仅仅是一个数字躺在那里，钱已经被支付宝用于其他途径了，但是你提现等操作又会调度回来。这其中的种种过程都要保证安全才可以。</p>
<ul>
<li>需求频繁更新</li>
</ul>
<p>因为后台会收集用户的一些信息用来改善产品功能和产品的体验，或是用户希望增加某一种功能。这时候就会有用户需求，需要更新产品功能。每一款软件的发展都是满足一种功能，然后不断更新迭代发展的。</p>
<ul>
<li>渐进式发展</li>
</ul>
<p>无论多大的网站都是从很小的开始，无论多大的高楼都是一砖一瓦构成。渐进式发展与传统的软件开发与设计不一样，没有软件完整的期望与功能整体的预见性，都是在不断发展中完善自我。通过对产品的不断运行，适应用户需求，适应时代的潮流。</p>
<h2 id="03-设计演化"><a href="#03-设计演化" class="headerlink" title="03 设计演化"></a>03 设计演化</h2><hr>
<p>不知道大家是否听过“LAMP”这个词语，这就是早期的网站设计方案，只适用于小型的网站，如今是肯定不行的。由于开始的数据量不大，一台服务器足以支撑真个网站的运行，操作系统使用Linux，服务器用Apache，数据库使用mysql还有语言使用PHP开发。</p>
<p>网站经过业务的发展，不断改进、不断演化，形成了一个有章可循的技术方案。经历的每一个阶段都是由业务的驱动，假如你的网站没有这种需求，程序员是不是搞这些大的设计方案的。正如书中所说的，是业务成就了技术，是事业成就了人。</p>
<h5 id="初始发展阶段"><a href="#初始发展阶段" class="headerlink" title="初始发展阶段"></a><strong>初始发展阶段</strong></h5><p>业务需求量不高，使用简单的配置，免费开源的软件就可以搭起一套系统。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="应用数据与服务数据分离"><a href="#应用数据与服务数据分离" class="headerlink" title="应用数据与服务数据分离"></a><strong>应用数据与服务数据分离</strong></h5><p>随着业务的发展，网站的性能必然下降，所以这时候就可以把服务进行分离。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a><strong>使用缓存</strong></h5><p>参考二八法则，我们知道80%的用户访问网站20%的功能，所以我们只需要把用户最需要的功能做好，那么我们就可以用到缓存的技术，能够及时快速地把用户需要的资源返回给用户。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="应用服务器集群"><a href="#应用服务器集群" class="headerlink" title="应用服务器集群"></a><strong>应用服务器集群</strong></h5><p>随着你的业务量的增加，以及功能的不断增加，一台服务器的处理可能会顶不住，那这样的话我们就放多台服务器同时处理这个业务。就比如把用户的请求交给多个人去做一样，性能肯定会提升。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/4.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a><strong>数据库读写分离</strong></h5><p>不仅是应用层面，数据的操作也是同样重要的，我们知道数据不是读就是写，一般来说用户读操作比较多。所以我们就把数据库读写分离，一台数据库提供数据，另一台写入用户的数据，然后中间进行数据同步（主从备份）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/5.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="负载均衡与CDN"><a href="#负载均衡与CDN" class="headerlink" title="负载均衡与CDN"></a><strong>负载均衡与CDN</strong></h5><p>对于业务量比较大的网站，如遍布全国乃至全球的，就需要使用CDN了。因为南方的用户访问北方的服务器，中间也会有延迟；或者美国的用户访问中国，那么延迟就更大了。CDN的就是内容分发网络，离用户最近的服务器就会直接返回数据，这样就快很多了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/6.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>还有就是负载均衡，加入CDN的数据过期，用户需要访问数据中心的时候就会先到负载均衡服务器，这里也有缓存，如果没有命中就统一把你的请求分发给压力比较小的应用服务器。总的来说，CDN与负载均衡服务器的原理就是利用了缓存技术。</p>
<h5 id="分布式文件系统与分布式数据库系统"><a href="#分布式文件系统与分布式数据库系统" class="headerlink" title="分布式文件系统与分布式数据库系统"></a><strong>分布式文件系统与分布式数据库系统</strong></h5><p>分布式其实就是对原来的数据存储再进行拆分，把不同业务的数据存储到不同的服务器当中，减少其余服务器的压力。举个例子，可以把用户的订单数据存储到A数据库服务器，用户的信息放到B数据库服务器。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/7.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="NoSQL和搜索引擎"><a href="#NoSQL和搜索引擎" class="headerlink" title="NoSQL和搜索引擎"></a><strong>NoSQL和搜索引擎</strong></h5><p>搜索引擎是为了应对网站的搜索功能。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/8.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a><strong>业务拆分</strong></h5><p>把一个网站拆分成多个不同的应用，每个应用独立部署和维护。比如可以把某个功能独立出去，提供接口嵌入网站里面，本身的逻辑处理是在别的服务器。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/9.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a><strong>分布式服务</strong></h5><p>把公共的业务提取出来，然后独立部署，通过分布式服务调用共用服务完成具体业务操作。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/architectureLearning/10.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>我们可以看一下当前的互联网公司，能称得上BAT级别的也就是这么几个，毕竟大部分都是小公司，正在逐步发展属于自己的业务。他不可能每一个领域都有时间和精力去研究、去开发。但是一般的公司都会有自己的专业点，你只要把自己的业务发展好，服务好我们的用户足矣，有时候搞很多花里胡哨的东西反而没有益处。</p>
<blockquote>
<p>小型网站最需要做的就是为用户提供好的服务来创造价值，得到用户的认可，活下去，野蛮生长。——李智慧《大型网站技术架构》</p>
</blockquote>
<p>有的公司因为看到最近新出了很多技术，所以也想把自己的架构改造一下，这就是为了技术而技术。有时候自己的出发点是好的，但是也有可能带来坏的结果，没有顺应自己的业务发展趋势。还有也不要盲目模仿大公司的技术方案，要发展自己的独立业务，发展自己的独立技术。</p>
<p>总的来说，现在每个公司都有自己的一套技术方案，是否重构你的技术方案或者是否改变你的服务器分布等都取决于你是否有这个需要。不过现在互联网技术发展越发成熟，有一些资源你都可以付费购买，像阿里云、腾讯云等都可以使用，而且技术稳定，质量过关。毕竟是大公司。你要多优质的资源，取决于的钱给多少，非常简单，没有后顾之忧（已经帮你决解好了）。</p>
<p>最后也向大家推荐一下这本书《大型网站技术架构：核心原理与案例分析》，本书作者的技术非常好，分析独到，值得深入阅读。</p>
<p>参考文章</p>
<ul>
<li>李智慧 《大型网站技术架构：核心原理与案例分析》</li>
</ul>
<p><img src="/2020/03/21/architectureLearning/2.gif" alt></p>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
        <tag>大型网站</tag>
        <tag>网站特点</tag>
        <tag>方案</tag>
      </tags>
  </entry>
  <entry>
    <title>小白也能听懂的前端工程化</title>
    <url>/2020/03/20/frontProject/</url>
    <content><![CDATA[<h2 id="小白也能听懂的前端工程化"><a href="#小白也能听懂的前端工程化" class="headerlink" title="小白也能听懂的前端工程化"></a>小白也能听懂的前端工程化</h2><blockquote>
<p> 前端工程化最近也是被很多公司或者企业都用起来了，变成了一个很火的名词，所以我就好奇一下中间的前因后果是怎么样的</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/20/frontProject/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端工程化这个方面的内容我也是近年来才听到的一个信息，我一听就觉得十分地高大上，什么时候前端开始变成了一个工程化的层面了？不过现在随着技术的更新换代我逐渐相信前端的发展了。之前觉得惊讶的时候，我还是大家认为前端该干的事情——切图，套模板。</p>
<p>本文就和大家扯一下前端工程化的前世今生，没有技术在里面。大家可以带着好奇的心情阅读。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/20/frontProject/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-前端开发？切图？"><a href="#02-前端开发？切图？" class="headerlink" title="02 前端开发？切图？"></a>02 前端开发？切图？</h2><p>其实之前对于前端的概念基本上是没有的，那时候很多招的就是后端的开发，所以java的开发就很吃香了，差不多站到了鄙视链的顶端。那为什么我不去学后端呢？因为我（后）相（端）信（太）前（难）端（了）的发展。</p>
<p>所以没办法，我就随便找个其他的学一下，由于美工不好那就找前端吧！有点东西还可以马上出效果。</p>
<h5 id="前端历史"><a href="#前端历史" class="headerlink" title="前端历史"></a><strong>前端历史</strong></h5><p>不得不承认的是，现在前端经历了两次的重生。才有今天突飞猛进的发展，第一次是从静态网站变成了动态网站；第二次就是Node.js的推出，可以使脚本语言JavaScript运行在服务器端，这可是解放了生产力，让前端不再卑微了。</p>
<p>很多人都觉得动态网站不是很早就有了吗？一开始我也是这么觉得的，毕竟写一个脚本就可以让页面动起来，但是这里说的动态可不是这个意思，是可以与用户进行交互了。大家可以想想看之前的前端历史，无非就是把几个页面模板拼凑起来，然后使用js加上几个动画，就会觉得你的网站不得了了。那时候的网站基本上是没有交互的，就是给别人看的页面，仅此而已。</p>
<p>有时候你辛苦调试出来的一个完美的页面，发给同学朋友看的时候，页面也可能会乱。没错，那个就是不兼容的时代，会让每一个前端抓狂的时代，而现在就不一样了，很多框架都帮你弄好了，很少会有兼容的问题。</p>
<h5 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a><strong>开发模式</strong></h5><p>由于本人是没有经历过前后端混合的开发模式，我开始学习前端的时候，vue和elementui这些都已经出来了，所以我就跟高兴晚出生了几年，让前人们帮我们这群人铺平了前端道路。</p>
<p>当我谷歌了前端工程化了之后，发现之前的开始模式是比较混乱的，也是没有很强的逻辑在里面的。大概的开发模式就是切一下图，把设计的部分做了和写一下脚本（相信大家都知道dreamweaver这个软件，既可网页设计也能写前端代码）。然后页面模板就交给后端来做，前后端混合在一起，耦合性非常高。这真的就是牵一发而动全身的局面。相信大家都知道大名鼎鼎的JSP了，我在大学的时候也学了这个，基本上没什么用（下一届取消这门课程）。</p>
<p>后来后端就忍不住了，你这前端的东西啥玩意，零碎的很，又毫无逻辑可言。</p>
<p>好吧，前端本着背锅的心态啃了这块骨头，把所有页面相关的东西都给了前端，后端就负责发给我数据就好了。这就是上面提到的动态网站的开始，这得益于Ajax的诞生。从此以后前端的工作就不用去切图了，你的工作就变成了怎么搞模板，设计与美化页面的工作了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/20/frontProject/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-前端工程化"><a href="#03-前端工程化" class="headerlink" title="03 前端工程化"></a>03 前端工程化</h2><hr>
<p>之前我们开发完了页面之后，剩下的就等后端来给你数据了。但是你前端的开发快了，但是后端的接口跟不上啊，这可怎么办？聪明的前端就想出了“假数据”这个东西，就是我先把数据自己模拟出来，你后端就必须按照我的格式给我返回数据（与后端沟通好格式）。</p>
<p>这不，出了很多数据模拟的工具，比如easymock等。大家可以脱离后端的控制单飞了，我们可以把这个项目同步进行开发，每一个过程都是完整可交付的状态，可以随时给客户演示这个过程而不用等后端的接口。项目组一看，前端做的不错（升职加薪）。但是这和工程化的概念还很远呢，我们知道项目大概可以分成四部分：设计，开发，测试，部署。</p>
<h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a><strong>设计</strong></h5><p>这里的设计主要是由产品经理与UI设计一起，设计这款产品的愿景以及要实现的功能，简单一点就是把用户需求的功能通过产品设计出来，交给开发。</p>
<p>前端就主要通过产品页面的评估，主要是评估开发周期以及项目的难度，然后是技术栈的选择。后端会对系统进行架构设计，包括系统接口，权限控制，性能，可维护可复用等的设计。基本上前后端设计的都是关于技术类型的。</p>
<h5 id="开发"><a href="#开发" class="headerlink" title="开发"></a><strong>开发</strong></h5><p>接下来就会进行开发的状态，根据需求进行开发。这个阶段就要注意一些小功能的开发，是否可以通过所有的测试用例。不知道大家是否听过敏捷开发的技术，这是一种高效的模式，确保开发的过程中每个部分的功能都可以使用。他的初衷就是能够高效地开发迭代，快速地转变用户需求。前端的组件化、模块化的设计就是能够保证敏捷开发的前提。</p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h5><p>测试的作用就是进行小范围的对功能本身的验证，一般来说会有很多测试用例，只有你通过了所有的用例测试之后就可以进行下一部的操作。测试是直接面向用户的，这时候就站在用户的角度去体验这个产品，把用户可能出现的操作都测试一遍看服务或者数据是否正常，前端工程师是主要责任人。通常可能还会包含压力测试等，用来测试产品的性能，这时候就是后端的主要责任。</p>
<h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a><strong>部署</strong></h5><p>部署的流程就是一个很重要的一部分，假如前期的工作做得不够好，项目上线之后可能会遇到很多问题，让你难以定位问题出在哪，项目难以维护等。前后端分离的开发模式可以有效的减少故障的发生，能够快速定位问题，解决问题。其实这里也是得益于单元测试以及项目工程拆分的过程。</p>
<p>这里的部署可以把一些静态的文件部署到静态服务器或者CDN，把涉及数据交互的放在web服务器，做到类似“读写分离”的功能，能够最大程度提升性能。</p>
<p>在开发的过程中就可以使用前后端分离的开发模式，这是一种与技术无关的模式，就是一种工程思维的考量。很多面试都会问你谈谈前端工程化的理解，其实无非就是为什么有前端工程化、怎么做才可以、有什么好处等。基本上这就是一种工程的思维，与技术的关系不大。总的来说有以下三个优点：</p>
<ul>
<li>并行开发，缩短开发周期</li>
<li>快速定位问题，迅速解决问题</li>
<li>部署可以动静分离，简化流程，提升程序的健壮性</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/20/frontProject/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>其实我发现一些书籍把前端工程化的概念讲的很深，比如可能会说前端的打包工具、持续集成等。当然这也是前端工程化的一部分，简单来说它的核心就是“解耦”，让之前的纠结不清的脉络重新整理出来，变成一个可维护可复用的状态。</p>
<p>总结一下前端工程化就是为了简化开发流程，并行开发，互不影响且能够方便合并整个项目。核心目标就是建立一种开发环境，提升整体的开发效率。</p>
<p><img src="/2020/03/20/frontProject/2.gif" alt></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>项目开发</tag>
        <tag>测试部署</tag>
        <tag>接口</tag>
        <tag>交付</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么不推荐大家太注重学习</title>
    <url>/2020/03/19/notFocusStudyOnly/</url>
    <content><![CDATA[<h2 id="我为什么不推荐大家太注重学习"><a href="#我为什么不推荐大家太注重学习" class="headerlink" title="我为什么不推荐大家太注重学习"></a>我为什么不推荐大家太注重学习</h2><blockquote>
<p>本期学习来给大家聊一下学习相关的日常，除了学习我们还需要干嘛？</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/19/notFocusStudyOnly/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>作为一个喜欢专注学习的我，要是当初谁给我说不要太专注与学习的话，我大概率会骂他一顿，不学习怎么来提升自己，怎么来取得好成绩？</p>
<p>其实大家说的也不是没有道理，我想说的是除了学习之外的事情，学习过后你应该做点什么事情。这样大家或许就会明白，学习是仅仅是一个过程，而不是最终的结果。下面我就说一下怎么学，学完之后应该做的什么？</p>
<h2 id="02-不要盲目学习"><a href="#02-不要盲目学习" class="headerlink" title="02 不要盲目学习"></a>02 不要盲目学习</h2><hr>
<p>早期我们是小白的时候，总觉得知识的宇宙非常之大，很多事情都触不可及，令人心生敬畏。没错，如果你从零开始定会很多东西都想学，很想给别人秀一下自己的学习方法是多么高效，自己的学习能力是多么突出，你看我一周时间的看完了好几门的技术文档，能够入门这个技术了。</p>
<p>人是一种有虚荣心的生物，总喜欢听别人给自己说一些赞美的话。如果别人问你学了哪些技术，你恨不得把所有沾边的都说出来，就为了别人的一句，“哇，你好厉害啊！” 仅此而已，但是其实自己是属于哪种水平，你是最清楚的。</p>
<p>之前我开始接触一门新技术的时候，过不了几天就跑去学习另一门技术。我这种心理其实就是生怕别人会而你是不会的，但是到头来自己也是一知半解的水平。跟大家说一个我自己的例子，之前学习前端的时候，我就在学习基本语法标签的时候跑去学JavaScript、jQuery之类的。然后导致很多的基本语法或者css样式都不清楚，最后还是乖乖打基础。</p>
<p>所以我的第一个关于学习的建议就是认准一线，日后不会变。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/19/notFocusStudyOnly/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-输入重要，输出更重要"><a href="#03-输入重要，输出更重要" class="headerlink" title="03 输入重要，输出更重要"></a>03 输入重要，输出更重要</h2><hr>
<p>还记得之前我发过的一篇文章，里面说过主动学习与被动学习的关系吗？除了学习，我觉得大家更应该去产出一些东西证明你是真正的理解过，虽然学习的东西还没有完全吸收变成你自己的，但这个过程你是真正有思考的、有内化书本的知识的。假如你只是一个会看书、会阅读的人，那就只是最低层的学习，效率是不会高的。</p>
<p>相比之下，你若学会总结，学会提炼文章中的知识点，还会思考这么说的意义是什么，那就会比前者更印象深刻。倘若自己还有时间和精力，那么你就可以把自己的所思所想产出一篇文章，那么就最好了。</p>
<p>昨天看到腾讯关于技术的宣讲会，里面主持人提到一个“黄金圈法则”令我觉得很有道理。最外面一层就是你知道了某个结论，比如我们说计算机之间建立连接是要通过TCP三次握手的，这是一个结论你记住了。但是这是没有什么用的，这只是最表层、最表现的知识点。我们常说要究其本质是什么，看一下内在的东西是怎么样的，所以我们更近一步就是学会看它的原理。他为什么是通过三次呢？我两次是否可行？或者我四次呢？其实你想到了这一层的时候，说明你是有经过思考和理解的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/19/notFocusStudyOnly/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>但是这一层次还不够，你需要进一步考虑，或许这会花费你一些时间，但是请相信你收获的会比记住一个简单的结论好。我们可以再问一下，为什么要握手，我不握手计算机就不能连接了吗？有没有不用握手就可以的。你看，经过一番思考确实你会了解的更多，你的未知领域就这样一步步探索出来，你的知识盲区就会变小，你就会知道UDP是不用握手就可以传输数据的协议。</p>
<p>所以经过一番思考过后你就会知道什么是比标准答案更重要的事情了。所以每读的一本书，大家不要以为这本书我看过了，知识我都大概懂了，就继续看其他的。这是站在一个第三者的角度看问题，你想想看作者产出的整一本是肯定经过很长时间的编写、修改、提炼等，哪是你一下子就能领悟的精髓。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/19/notFocusStudyOnly/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="04-学习质量与数量"><a href="#04-学习质量与数量" class="headerlink" title="04 学习质量与数量"></a>04 学习质量与数量</h2><hr>
<p>我们时间是有限的，不可能把所有的知识都学习一遍，或者把一个知识点的所有资料看一遍，这些都是不可取的。关于这一点我深有体会，刚开始入门的时候很困难，也没有带你该怎么去学，也没有人给你资料，你也无从下手，这就导致了我踩过很多坑。怎么说呢？</p>
<p>其实大家开始学习的时候可能对看书这件事情十分的畏惧，一看三不知。我就遇到这种情况，其实我们要认清一点就是不是你的智商有问题，而是你的知识储备还没有到这个地步，这本书的内容是不适合你的。所以很多人会选择视频入门，相对简单轻松，有时候还会给你扯一下皮，整个学习的工程轻松没压力。但是正是因为这个原因你的时间就浪费在这里，不但没有学到有用的东西，反而会害了你。</p>
<p>很多技术入门的视频，比如我经常在某些公众号里里面看到的广告（xxx技术从入门到精通，史上最全的学习资料，把之前的资料都丢掉只看整套）等等… 其实大家不要被他们的广告骗了，其实里面的质量是不行的，不都分都是某些培训机构的课程而已，这里就不细说了。</p>
<p>所以我建议大家还不如乖乖买一本基础的书籍，少整这些没用的还害你的东西。今天学习困难一点，明天的入门就轻松一点。选择合适的学习资料，一般都是官方的文档，无可否认。一些技术的书籍无非就是”翻译“一遍而已，用另一种方式来解释技术，这也是不错的想法，毕竟很多人都会说官方文档都是看不到的。大家可以深入体会一下”官方“二字就知道了。</p>
<p>知识都是互联互通的，学习在于质量而不是数量。你理解了一个知识点之后最多可以做的就是去尝试拓展知识的本身，而是重新学习一遍。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/19/notFocusStudyOnly/4.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>好啦，今天的瞎聊环节就到这里了，其实作为程序员来说，是一个与代码打交道比较多的职位，每天面对的就是一坨别人看不懂的代码，就会觉得这个人很高冷呀，这个人好像不爱说话呀。类似的，好像我们却慢慢地变成了别人眼中的那个人，渐渐变得不爱说话了。其实大家可能对程序员有一点误解，我觉得恰恰相反，我觉得给程序员打的标签应该是乐于分享、乐于交流、善良、简单，纯粹等。</p>
<p>大家在学习技术的同时，不妨写一些学习经验、学习技巧等软技能的东西，这样可以让你的大脑得到锻炼与思考，也可以让别人收益，何乐而不为？</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/19/notFocusStudyOnly/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
        <tag>学习内容</tag>
        <tag>学习质量</tag>
      </tags>
  </entry>
  <entry>
    <title>解读进程与线程区别、进程间通信</title>
    <url>/2020/03/18/thread/</url>
    <content><![CDATA[<h2 id="解读进程与线程区别、进程间通信"><a href="#解读进程与线程区别、进程间通信" class="headerlink" title="解读进程与线程区别、进程间通信"></a>解读进程与线程区别、进程间通信</h2><blockquote>
<p><strong>“</strong> 纸上得来终觉浅，绝知此事要躬行<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/thread/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <tags>
        <tag>通信</tag>
        <tag>线程</tag>
        <tag>计算机基础</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法( JavaScript版 )</title>
    <url>/2020/03/18/jsSortMethods/</url>
    <content><![CDATA[<h2 id="常见排序算法-JavaScript版"><a href="#常见排序算法-JavaScript版" class="headerlink" title="常见排序算法( JavaScript版 )"></a>常见排序算法( JavaScript版 )</h2><blockquote>
<p>“失之东隅，收之桑榆”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsSortMethods/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端面试中，手写代码常常会要求你写一些常见的排序算法，虽然不是每次都会遇到手写代码的部分，但是BAT的大厂可能就要你熟悉了。总之多懂一点也不是坏事。接下来我将把几种常见的算法用JavaScript的方法实现。</p>
<h2 id="02-算法实现"><a href="#02-算法实现" class="headerlink" title="02 算法实现"></a>02 算法实现</h2><hr>
<p>我们常见的排序算法中，我就列举常考的5种。</p>
<ul>
<li>快速排序</li>
<li>插入排序</li>
<li>冒泡排序</li>
<li>选择排序</li>
<li>归并排序</li>
</ul>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h5><p>快速排序的基本思想就是分治法的思想，寻找中间点，并对其左右的序列递归进行排序，直到左右都排序完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pirotIndex=<span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">var</span> pirot = arr.splice(pirotIndex,<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> left=[],right=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;pirot)&#123;</span><br><span class="line">            right.push(arr[i])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(pirot,quickSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">99</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsSortMethods/3.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h5><p>将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insertionSort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">99</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsSortMethods/4.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h5><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]]=[arr[j+<span class="number">1</span>],arr[j]] <span class="comment">//ES6解构</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">99</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsSortMethods/5.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h5><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">var</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(selectionSort([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">99</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsSortMethods/6.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h5><p>基本思想是把数组分半，不断递归排序，最后进行已排序的数字进行合并。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">var</span> left = arr.slice(<span class="number">0</span>, middle)</span><br><span class="line">    <span class="keyword">var</span> right = arr.slice(middle)</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">        result.push(left.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">        result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">99</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsSortMethods/7.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-算法复杂度"><a href="#03-算法复杂度" class="headerlink" title="03 算法复杂度"></a>03 算法复杂度</h2><hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsSortMethods/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>前端的排序算法虽然很少在项目中用到，但是可能用的比较多的是对后端数据进行处理的时候会用到，一般后端返回来的数据都会经过预处理。因为后端处理一般会比前端容易，只要早数据库查询的时候加上排序就好。</p>
<p>但是特殊时候可能就要前端的算法来大展身手啦，所以大家还是理解一下比较好。养兵千日用兵一时，而且面试还会考到的，这也是前端面试和别人拉开距离的地方，不仅考察业务能力，基础能力也是很重视的。</p>
<p><img src="/2020/03/18/jsSortMethods/2.gif" alt></p>
]]></content>
      <categories>
        <category>排序算法高性能</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>排序算法</tag>
        <tag>快速排序</tag>
        <tag>算法复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中关于数组的问题</title>
    <url>/2020/03/18/jsArrayAPI/</url>
    <content><![CDATA[<h2 id="JavaScript中关于数组的问题"><a href="#JavaScript中关于数组的问题" class="headerlink" title="JavaScript中关于数组的问题"></a>JavaScript中关于数组的问题</h2><blockquote>
<p>“路漫漫其修远兮，吾将上下而求索”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/jsArrayAPI/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端面试当中，关于js数组的面试也占据了很大的一部分，特别是关于数组的操作上。下面我就以前端中经典面试题，说说js中数组有哪些方法开始说起。也有很多面试官下一步就会问，哪些是改变原数组，哪些不会改变呢？这时候很多同学就会不记得了。</p>
<h2 id="02-创建方式"><a href="#02-创建方式" class="headerlink" title="02 创建方式"></a>02 创建方式</h2><hr>
<p>JavaScript中创建数组有两种方式，第一种是构造函数的方式，第二种是字面量的方式。</p>
<p>（一）构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>（二）使用数组字面量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = [];</span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>两者的区别</p>
<p>使用new关键字的方法会在内存中开辟一些空间，用来记录与存储该变量，也就是这是一个实例化过程。在Javascript里分配大量的new变量地址是一项很慢的操作。Array()是一个对象，[]是一个数据原型。使用new Array()系统每次都会新生成一个对象，浏览器每生成一个对象都会耗费资源去构造他的属性和方法。</p>
<p>其实这和字符串的创建差不多，new String(‘str’)，一种是直接创建了一个字符串，一个是调用字符串的构造函数创建字符串对象然后再创建这个字符串，中间多了一个创建对象的过程。所以为了效率起见，推荐使用字面量的方式创建。</p>
<h2 id="03-数组方法"><a href="#03-数组方法" class="headerlink" title="03 数组方法"></a>03 数组方法</h2><hr>
<ul>
<li>push()        pop()</li>
<li>shift()        unshift()</li>
<li>sort()         reverse()</li>
<li>concat()      slice()  </li>
<li>splice()       join()</li>
<li>indexOf()     lastIndexOf()</li>
<li>forEach()      map()</li>
<li>filter()         every()</li>
<li>some()       reduce()</li>
<li>reduceRight()</li>
</ul>
<p>下面详细介绍一下各个方法的基本功能。</p>
<h5 id="push-和pop"><a href="#push-和pop" class="headerlink" title="push()和pop()"></a><strong>push()和pop()</strong></h5><p>push(): 把元素逐个添加到数组末尾，可接收任意数量的参数并返回修改后数组的长度。<br>pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.push(<span class="string">"d"</span>,<span class="string">"e"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["a", "b", "c", "d", "e"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// e</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["a", "b", "c, "d"]</span></span><br></pre></td></tr></table></figure>

<h5 id="shift-和-unshift"><a href="#shift-和-unshift" class="headerlink" title="shift() 和 unshift()"></a><strong>shift() 和 unshift()</strong></h5><p>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。<br>unshift():将参数添加到原数组开头，并返回数组的长度 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.unshift(<span class="string">"d"</span>,<span class="string">"e"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//["d", "e", "a", "b", "c"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// d</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["e", "a", "b", "c"]</span></span><br></pre></td></tr></table></figure>

<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a><strong>sort()</strong></h5><p>sort()：按升序排列数组项，即最小的值位于最前面，最大的值排在最后面。</p>
<p>但是注意的是，在排序时，sort()方法会调用数组项的 toString()方法，然后比较得到的字符串来确定如何排序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sort()); <span class="comment">// ["a", "b", "c", "d"]</span></span><br><span class="line">arr2 = [<span class="number">18</span>, <span class="number">29</span>, <span class="number">50</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort()); <span class="comment">// [18, 29, 4, 50]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [18, 29, 4, 50]</span></span><br></pre></td></tr></table></figure>

<p>sort()方法可以接收一个比较函数作为参数，若参数比较返回-1则是升序排序，返回1则是升序排序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">18</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">50</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [4, 18, 29, 50]</span></span><br></pre></td></tr></table></figure>

<p>如果是降序的话，只需要交换返回值就好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2 = [<span class="number">18</span>, <span class="number">29</span>, <span class="number">50</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(compare)); <span class="comment">// [50, 29, 18, 4]</span></span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a><strong>reverse()</strong></h5><p>reverse()：反转数组项的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">18</span>, <span class="number">29</span>, <span class="number">50</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse()); <span class="comment">//[4, 50, 29, 18]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[4, 50, 29, 18]</span></span><br></pre></td></tr></table></figure>

<h5 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h5><p>默认用逗号为分隔符，参数是分隔符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(arr.join()); <span class="comment">// 1,2,3 </span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">"+"</span>)); <span class="comment">// 1+2+3 </span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a><strong>concat()</strong></h5><p>concat() ：将参数添加到原数组中。该方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。若没有给concat()方法传递参数，默认情况下复制当前数组并返回，不会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr.concat(<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy); <span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h5 id="slice"><a href="#slice" class="headerlink" title="slice()"></a><strong>slice()</strong></h5><p>slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy2 = arr.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy3 = arr.slice(<span class="number">1</span>,<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy4 = arr.slice(<span class="number">-4</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 3, 5, 7, 9, 11](原数组没变)</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy); <span class="comment">//[3, 5, 7, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2); <span class="comment">//[3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy3); <span class="comment">//[3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy4); <span class="comment">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure>

<p>arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。<br>arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。<br>arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。<br>arrCopy4两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。</p>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice()"></a><strong>splice()</strong></h5><p>splice()：数组中最强大的方法，可以实现多种操作。</p>
<p>添加：向数组中添加项，参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,1,1)会从当前数组的位置 2 开始插入1和1。</p>
<p>删除：删除数组中的项，参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</p>
<p>修改：向数组中添加项，且同时支持删除数组中的项，参数：起始位置、要删除的项数和要插入的项。例如，splice (2,1,1,1)会删除当前数组位置 2 的项，然后再从位置 2 开始插入1和1。</p>
<p>splice()方法返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>];</span><br><span class="line"><span class="keyword">var</span> arrCut1 = arr.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ 'c', 'd', 'e', 'f' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCut1);<span class="comment">//[ 'a', 'b' ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrCut2 = arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ 'c', 'd', 1, 1, 'e', 'f' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCut2); <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrCut3 = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ 'c', 2, 2, 1, 1, 'e', 'f' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCut3); <span class="comment">//[ 'd' ]</span></span><br></pre></td></tr></table></figure>

<h5 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf()和 lastIndexOf()"></a><strong>indexOf()和 lastIndexOf()</strong></h5><p>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 </p>
<p>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</p>
<p>若没有查找到则返回-1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'e'</span>,<span class="string">'a'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'c'</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'c'</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'e'</span>,<span class="number">4</span>)); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'e'</span>,<span class="number">4</span>)); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">"aa"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><strong>forEach()</strong></h5><p>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有参数，参数分别为：遍历的数组内容；对应的数组索引，数组本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, index, a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + <span class="string">','</span> + index + <span class="string">','</span> + (a === arr));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="number">1</span>,<span class="number">0</span>,<span class="literal">true</span></span><br><span class="line"><span class="number">2</span>,<span class="number">1</span>,<span class="literal">true</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="literal">true</span></span><br><span class="line"><span class="number">4</span>,<span class="number">3</span>,<span class="literal">true</span></span><br><span class="line"><span class="number">5</span>,<span class="number">4</span>,<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>关于forEach是否可以改变原数组的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样操作发现是改变不了的</span></span><br><span class="line"><span class="keyword">let</span> oldArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ;</span><br><span class="line">oldArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item = <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(oldArr);<span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样操作发现是可以改变的</span></span><br><span class="line"><span class="keyword">let</span> oldArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ;</span><br><span class="line">oldArr.forEach(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">    oldArr[index] = <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(oldArr); <span class="comment">//[ 0, 0, 0, 0, 0 ]</span></span><br></pre></td></tr></table></figure>

<p>其实每次forEach的循环的item，只是forEach给我们在另一个地方复制创建新元素，和原来的元素并无关系。到头来其实是JavaScript的基本数据类型与引用数据类型的区别。对于基本数据类型：Number, String, Boolean, Null, Undefined, Symbol，它们在<strong>栈内存中直接存储变量与值</strong>。Object对象的真正的数据是保存在<strong>堆内存</strong>，<strong>栈内只保存了对象的变量以及对应的堆的地址</strong>，所以操作Object其实就是直接操作了原数组对象本身。</p>
<p>forEach 的基本原理也是for循环，所以使用arr[index]的形式赋值改变，其实就是操作堆地址，是可以改变的。</p>
<h5 id="map"><a href="#map" class="headerlink" title="map()"></a><strong>map()</strong></h5><p>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item+<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[ 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><strong>filter()</strong></h5><p>filter()：对数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//[ 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h5 id="every"><a href="#every" class="headerlink" title="every()"></a><strong>every()</strong></h5><p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">7</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">5</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="some"><a href="#some" class="headerlink" title="some()"></a><strong>some()</strong></h5><p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">6</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span>;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h5 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce()和 reduceRight()"></a><strong>reduce()和 reduceRight()</strong></h5><p>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。</p>
<p>reduce()方法从数组的第一项开始，依次遍历到最后。而 reduceRight()则从数组的最后一项开始，依次向前遍历到第一项。</p>
<p>方法接收两个参数：一个在每一项上调用的函数和基础的初始值。</p>
<p>reduce()和 reduceRight()的函数接收 4 个参数：前一个值（pre）、当前值（cur）、项的索引（index）和数组对象（array）。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<p>下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>以上的数组方法不论在面试中还是在项目中都非常管用，特别是后端的数据处理的时候会经常用到。现在总结一下哪些方法是改变原数组的，哪些是没有的。值得注意的是forEach的特殊点，文中已做说明。</p>
<p>1.改变原数组：</p>
<ul>
<li>push()        pop()</li>
<li>shift()        unshift()</li>
<li>sort()         reverse()</li>
<li>splice()</li>
</ul>
<p>2.原数组不变：</p>
<ul>
<li>concat()       join()</li>
<li>slice()         map()</li>
<li>indexOf()     lastIndexOf()</li>
<li>filter()         every()</li>
<li>some()       reduce()</li>
<li>reduceRight()</li>
</ul>
<p><img src="/2020/03/18/jsArrayAPI/2.gif" alt></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GET/POST本质区别，面试官想听什么</title>
    <url>/2020/03/18/getandpost/</url>
    <content><![CDATA[<h2 id="关于GET-POST本质区别，面试官想听什么"><a href="#关于GET-POST本质区别，面试官想听什么" class="headerlink" title="关于GET/POST本质区别，面试官想听什么"></a>关于GET/POST本质区别，面试官想听什么</h2><blockquote>
<p> 书犹药也，善读之可以医愚</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/getandpost/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>我们常说要注重基础知识，并不是要你把简单的用法记忆下来，而是要从基础上理解。所谓基础就是根基，诞生的地方，才是基础。比如说一些很简单的问题，我们可能会回答不好，那是因为你没有从基础原理上解释它，而是从基础用法上解释了。</p>
<p>我们都知道万变不离其宗，万千世界都是由最初的演变而来的，万物皆有联系。所以我们学习知识一定要从它的原理上面入手，对它的印象才会深刻理解。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/getandpost/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-原理与使用"><a href="#02-原理与使用" class="headerlink" title="02 原理与使用"></a>02 原理与使用</h2><hr>
<p>原理和使用其实是两个截然不同的地方，所谓学习就是学习原理，使用次之。由于现在前端的业务可能会变得更加复杂，我们需要利用一些现成的框架或者组件库来开发我们的产品，难免就只关注了使用而忽略了原理。现成的轮子并不会满足日常开发的所有需要，我们有可能在原基础上再进行封装，要是不懂原理我们就很难进行二次开发。</p>
<p><strong><font color="red">原理</font></strong>：就是我们利用原生的技术来实现的组件，框架。实现和封装了一些便于操作的事件与方法，让我们的业务更加轻松。</p>
<p><strong><font color="red">使用</font></strong>：对开源的框架或者组件进行项目的嵌入，能够快速高效地开发出符合产品需求的程序，并且耦合程度低，使用方便。直接使用已经封装好的事件与方法即可。</p>
<h2 id="03-GET-POST"><a href="#03-GET-POST" class="headerlink" title="03 GET/POST"></a>03 GET/POST</h2><hr>
<p>这是一道很简单的面试题，也可以说在面试中非常高频。但是很多时候同学们回答的所谓正确答案往往是比较表面的。网上查找一下，我们发现别人总结的主要有以下几种：</p>
<ul>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/getandpost/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>我们知道，GET\POST是http协议中的两种方法，方法与数据其实是没有必然联系的，只是用法的约定而已。也就是说，你也可以使用GET方法，把数据放在body里面也是可以的。</p>
<blockquote>
<p>Both HTTP GET and HTTP POST can be used to execute search with body. Since not all clients support GET with body, POST is allowed as well.</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html</a></p>
</blockquote>
<p>这是Elasticsearch的说明，当使用时GET时请求时是可以把数据放在body里面的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"term"</span> : &#123; <span class="string">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么真正的区别是什么呢？</p>
<p>GET/POST的最大区别是GET请求有幂等性，但是POST请求没有。什么是幂等性呢？我们知道使用GET方法请求同样的接口，返回来的数据是不会改变的，但是对于POST请求，实现一些增删改查的操作的时候可能会发生重复提交的问题。</p>
<p>也就是说我们如果使用GET请求做增删改查的时候，遇到网络不好可能会多次操作，造成数据库的混乱，这是一个很严重的问题，但是使用POST就不会有这种情况。</p>
<p>当我们在面试中的时候我们要从原理和使用上面两个方面来进行回答。先回答使用上有哪些区别，说几种就好，但是重要的是把本质的说出来，那样就加分不少。把简单的问题回答到有深度的就不简单。</p>
<p>关于网上《99%的人都理解错了 HTTP 中 GET 与 POST 的区别》这篇文章说的“GET产生一个TCP数据包；POST产生两个TCP数据包”，其实也不是完全正确，因为数据包产生多少个完全是由浏览器等第三方工具的具体做法，与协议方法没有任何联系。</p>
<p>当用户是以POST方法来进行数据的发送的时候，可能浏览器等服务器返回100状态码之后才会进行数据的发送，相当于第一个数据包是询问服务器是否接受数据，如果不接受就不会进行发送。</p>
<blockquote>
<p>The purpose of the 100 (Continue) status (see section 10.1.1) is to allow a client that is sending a request message with a request body to determine if the origin server is willing to accept the request (based on the request headers) before the client sends the request body.</p>
<p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3</a></p>
</blockquote>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>无论是做什么，个人的感觉就是一定要重视基础和原理，这是最简单但也是最重要的一部分。每一个知识点背后都会藏着巨大的知识，我们就做那个挖掘知识的人。作为应届生和校招生，面试过很多公司，要求并不高，但是你不一定答得出来。这就是把简单的问题回答得不简单。</p>
<p><img src="/2020/03/18/getandpost/2.gif" alt></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>get/post</tag>
        <tag>幂等性</tag>
        <tag>网络</tag>
        <tag>请求方法</tag>
      </tags>
  </entry>
  <entry>
    <title>一次读懂flex布局</title>
    <url>/2020/03/18/flexLayout/</url>
    <content><![CDATA[<h2 id="一次读懂flex布局"><a href="#一次读懂flex布局" class="headerlink" title="一次读懂flex布局"></a>一次读懂flex布局</h2><blockquote>
<p> 千里之行，始于足下。——老子</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端的页面布局，在之前那是颇为头疼，一个简单的水平垂直居中可能要写上不少代码，但是现在利用一种新的布局方式，三行代码就可以实现。可以说，flex布局是未来布局的首选方案，且兼容性对各大浏览器都良好。</p>
<h2 id="02-主轴属性"><a href="#02-主轴属性" class="headerlink" title="02 主轴属性"></a>02 主轴属性</h2><hr>
<p>当容器设置为flex布局之后，可以对里面的各个元素采用不同的排列方式。对于采用flex布局的容器，可以使用以下属性。</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>一个容器默认会存在主轴（main axis）和交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<p>基本节点结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span>D<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span>E<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a><strong>flex-direction</strong></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">   <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，我们的属性值是row，按行排列。</p>
<p><strong>row</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/row.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>row-reverse</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/rowreverse.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>column / column-reverse</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/col.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a><strong>flex-wrap</strong></h5><p>默认情况下，容器内部的item都排在主轴上。该属性定义如果轴线排不下的时候该如何换行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下是不换行，nowrap。下面展示换行wrap和反向换行的情况。</p>
<p>wrap</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/wrap.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>wrap-reverse</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/wrapre.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a><strong>flex-flow</strong></h5><p>该属性是flex-direction和flex-wrap的简写方式（一般不用关注）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//默认 flex-flow: row nowrap</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">flex-flow</span>: flex-direction flex-wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a><strong>justify-content</strong></h5><p>该属性定义了item是如何在主轴上排列</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下是flex-start</p>
<p>flex-start</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/flexstart.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>flex-end</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/flexend.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>space-between</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/spaceb.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>space-around</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/spacearound.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>center</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/center.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a><strong>align-items</strong></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flex-start / stretch / baseline</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/baseline.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>center</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/center2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>flex-end</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/flexend2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a><strong>align-content</strong></h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>由于自己写出来的效果不直观，所以就使用官网的例子来进行演示。注意此属性对于单行的弹性盒子模型无效，即 flex-wrap : nowrap</p>
<h2 id="03-交叉轴属性"><a href="#03-交叉轴属性" class="headerlink" title="03 交叉轴属性"></a>03 交叉轴属性</h2><hr>
<p>交叉轴上面可以运用的属性有以下6种：</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h5 id="order"><a href="#order" class="headerlink" title="order"></a><strong>order</strong></h5><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给H添加 order : -1</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/H.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a><strong>flex-grow</strong></h5><p>该属性是指当子元素总宽度和比盒子宽度小的时候，子元素该如何瓜分父元素剩余宽度。下面是分别给ABCD四个元素的flex-grow设置为1，2，3，3</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/flexgrow.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>那么元素是如何获得占比值呢？元素实际宽度又是多少呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">子容器宽度总和为1800（500+400+300+800），（盒子宽度2100）剩余空间为100</span><br><span class="line">A元素的占比：1/(1+2+3+3) = 0.111</span><br><span class="line">A元素的占比值：100*0.111=11.1</span><br><span class="line">A的实际宽度：500 + 11.1 = 511.1</span><br></pre></td></tr></table></figure>

<h5 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a><strong>flex-shrink</strong></h5><p>该属性是指当子元素总宽度和比盒子宽度大的时候，子元素该如何压缩自己适应父元素宽度。下面是分别给ABCD四个元素的flex-shrink设置为1，2，3，2</p>
<p>计算结果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">子容器宽度总和为1800，溢出空间为200</span><br><span class="line">总压缩：500 * 1 + 400 * 2 + 300 * 3 +800 * 2= 3800</span><br><span class="line">A的压缩率：500*1 / 3800 = 0.132</span><br><span class="line">A的压缩值：200 * 0.132 = 26.4</span><br><span class="line">A的实际宽度：500 - 26.4 = 473.6</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/flexs.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a><strong>flex-basis</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MDN定义：指定了 flex 元素在主轴方向上的初始大小</span><br></pre></td></tr></table></figure>

<p>项目（item）放进盒子之前，给出一个初始宽度，默认值为auto，即项目本身的实际宽度，浏览器会根据 flex-basis 计算主轴是否有剩余空间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的值可以与项目的width一样，项目会按此宽度占据。通过设置with和max-width以及flex-basis，他们是有优先级关系的，我把A的width设置为400，flex-basis设置为500，max-width设置为600，通过浏览器依次去掉宽度属性值，得出一下结论：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">max-width/min-width &gt; flex-basis &gt; width &gt; box</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/640(1).gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="flex"><a href="#flex" class="headerlink" title="flex"></a><strong>flex</strong></h5><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt; &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平时写代码直接可以把属性分开来就好，一般不用记住简写方式。但面试可能会考到是哪几种属性简写，还是记下来的好。</p>
<h5 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a><strong>align-self</strong></h5><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处我给项目B单独设置align-self属性</p>
<p>auto | flex-start | flex-end | baseline</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/self.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>center</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/center3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>flex-end</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/end.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>flex布局属性可以快速满足我们日常开发的常见布局需要，解决使用定位、浮动等影响其他元素的属性。目前该属性可以支持主流的浏览器，可放心使用。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/bro.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>比如面试官会问你如何实现水平垂直居中的时候你就可以使用flex布局，简单快速：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">     <span class="attribute">background-color</span>: orange;</span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">     <span class="attribute">line-height</span>: <span class="number">400px</span>;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">     <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">     <span class="attribute">display</span>: flex;</span><br><span class="line">     <span class="attribute">justify-content</span>: center;</span><br><span class="line">     <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/mi.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/flexLayout/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>flex布局</tag>
        <tag>css3</tag>
        <tag>主轴</tag>
        <tag>交叉轴</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端安全知多少</title>
    <url>/2020/03/18/webSecurity/</url>
    <content><![CDATA[<h2 id="Web前端安全知多少"><a href="#Web前端安全知多少" class="headerlink" title="Web前端安全知多少"></a>Web前端安全知多少</h2><blockquote>
<p><strong>“</strong>  绳锯木断，水滴石穿<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/webSecurity/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>近年来前端的功能再也不是简单的页面开发这么简单，前端难免会和浏览器打交道，大多数人们都会通过浏览器进行网上的业务办理，信息查找等。但是这意味着我们会泄露自身的隐私，如手机号、身份证号等。</p>
<p>早期没有任何防护措施的浏览器发生了很多诈骗事件，随着浏览器的不断更新换代，安全系数也越来越高，接下来我将通过几种常见的前端安全策略，阐述一下我们的隐私如何被保障。</p>
<h2 id="02-前端安全分类"><a href="#02-前端安全分类" class="headerlink" title="02 前端安全分类"></a>02 前端安全分类</h2><hr>
<p>前端主要通过浏览器进行交互操作，涉及到浏览器安全的主要有以下5种。</p>
<ul>
<li>浏览器安全</li>
<li>跨站脚本攻击(XSS)</li>
<li>跨站请求伪造(CSRF)</li>
<li>点击劫持(ClickJacking)</li>
</ul>
<h5 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a><strong>浏览器安全</strong></h5><p>浏览器拥有同源策略，它可以说是浏览器的核心功能，如果没有同源策略的保护，浏览器的正常功能将受到很大的影响。那么什么是同源策略呢？</p>
<p><strong>浏览器的同源策略，限制来自不同源的脚本对当前域的调用和访问。</strong></p>
<p>听起来很抽象，举个例子，小明正在浏览 a.com，如果没有同源策略，那么a.com的网站可能会执行来自b.com的一段脚本数据，从而纂改a.com的内容，造成混乱。所以为了不让a.com调用其它页面的脚本或者数据，限制在同一个源内。那么如何才是同一个源呢？</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/webSecurity/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>想要满足同源策略，必须满足以下3个条件，才会被视为同源。</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>以上条件缺一不可，首先是协议方面，网站有http协议和https协议之分，https比http更安全，原因是https通过（SSL/TSL）来加密数据，防止数据被窃听和修改。SSL是安全套接层，TSL是传输层安全协议。</p>
<p>然后是域名相同，如 www .a.com , www .b.com就是不同的域名，域名不一样也是不满足策略。最后是端口相同，www .a.com:3000 , www .b.com:5000就是端口不同，也不满足条件。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/webSecurity/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a><strong>跨站脚本攻击(XSS)</strong></h5><p>XSS攻击，通常是通过“HTML”注入修改网页，当浏览器执行恶意脚本时可能会被他人控制。XSS攻击危害极大，如果网页开发者不注意防范XSS攻击，可能会对用户产生危害。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">"XSS攻击！"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/webSecurity/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>XSS攻击可以分为两种：</p>
<ul>
<li>持久型</li>
<li>非持久型</li>
</ul>
<p>①持久型：代码被写进数据库，比如在评论界面的输入框注入恶意代码，那么每一个用户访问帖子的时候都会执行恶意代码。这种类型的攻击影响最大，特别是对于那种日访问量以千万计算的网站。</p>
<p>②非持久型：一般是通过修改URL的参数方式加入攻击代码，利用某种方式诱导用户进行点击，从而实施攻击。比如以下的代码不加过滤处理就会发生攻击。谷歌浏览器是可以防御此类攻击的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- http:&#x2F;&#x2F;www.domain.com?name&#x3D;&lt;script&gt;alert(1)&lt;&#x2F;script&gt; --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/webSecurity/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>那么既然危害如此之大，该如何防御呢？主要有以下方法：  </p>
<ul>
<li>转义字符</li>
<li>CSP</li>
<li>HtppOnly</li>
</ul>
<p>①转义字符：因为一般恶意代码都会是脚本语言，由<script></script>包含，所以我们的思想就是把&lt;，&gt;等转义就可以高效防御。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于富文本那样的编辑器，通过过滤转义等方式可能加大任务量，所以另外一种就是通过CSP的方式，也就是建立白名单的方式进行防御。</p>
<p>②CSP：建立白名单，明确告诉浏览器哪些外部资源可以被加载并执行。通过前端配置规则，浏览器则会自动拦截。</p>
<ul>
<li>通过设置HTTP Header中的 Content-Security-Policy</li>
<li>设置meta标签的方式 <meta http-equiv="Content-Security-Policy"></li>
</ul>
<p>比如：</p>
<ul>
<li>只允许加载本站资源</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只允许加载https协议的照片</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: img-src https:<span class="comment">//*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>允许加载任何来源框架</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: child-src <span class="string">'none'</span></span><br></pre></td></tr></table></figure>

<p>只有当前端配置好之后，剩下的就交给浏览器处理。</p>
<p>③HttpOnly：浏览器将禁止页面的JavaScript访问带有HttpOnly属性的Cookie。实际上HttpOnly并非是为了防御XSS攻击，而是XSS攻击之后的Cookie劫持。</p>
<p>首先解释一下Cookie的产生过程：</p>
<ol>
<li>浏览器向服务器发送请求，这时还没有Cookie</li>
<li>服务器返回时带有 Set-Cookie 头，向浏览器写入Cookie</li>
<li>Cookie会有一个过期时间，在到期之前，浏览器访问该域名下的页面都会带上Cookie</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">header(<span class="string">"Set-Cookie: name=zhangsan"</span>);</span><br><span class="line">header(<span class="string">"Set-Cookie: age=12; HttpOnly"</span>);</span><br></pre></td></tr></table></figure>



<h5 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a><strong>CSRF</strong>攻击</h5><p>CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p>
<p>我们来看一下典型的CSRF攻击（假设）：</p>
<ol>
<li>A用户登陆某银行账号，本地留有登陆信息cookie</li>
<li>A突然收到黑客B发来的诱导链接，A在登陆状态下打开链接</li>
</ol>
<p>其实这就产生攻击。</p>
<p>我们在这里假设A，B都有银行账户，链接就是一个转账申请（按照银行的转账申请格式手动构造请求），然后提交申请后银行服务器误以为是A在操作，所以转账就会成功，此时就产生了攻击。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/webSecurity/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>那么如何预防CSRF攻击呢？</p>
<p>我们知道一般这个攻击都是第三方网站发起的，被攻击的网站无法阻止攻击的发生。所以我们只能增强自己的网站来提升安全性。</p>
<p>通常我们根据CSRF的攻击的特点来进行防御：</p>
<ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
<li>CSRF Token</li>
<li>双重cookie验证</li>
</ul>
<p>①同源策略：在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p>
<ul>
<li>Origin Header</li>
<li>Referer Header</li>
</ul>
<p>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个Header中的域名，确定请求的来源域。若不是来自同一个域的HTTP请求则不会生效。</p>
<p>②Samesite Cookie：HTTP响应头中有Set-Cookie属性，属性有两个值，Strict 和 Lax。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: foo=<span class="number">1</span>; Samesite=Strict</span><br><span class="line"><span class="built_in">Set</span>-Cookie: bar=<span class="number">2</span>; Samesite=Lax</span><br><span class="line"><span class="built_in">Set</span>-Cookie: baz=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>当设置为Strict的时候，伪造的请求是不会带上本地的cookie进行请求，所以这时候CSRF攻击不会生效。当设置为Lax的时候，在同源内发送请求是可以带上的。</p>
<p>③CSRF Token：用户打开页面的时候服务器下发一个Token，值为通过加密算法进行加密。每次请求都要加上这个Token值，服务端验证是否有效，无效则拒绝。</p>
<p>④双重Cookie验证：用户在发送请求的时候生成一个Cookie值，内容为随机字符串，前端向后端发送请求时取出Cookie值与服务端进行比较，若一致则有效，不一致则拒绝。</p>
<h5 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a><strong>点击劫持</strong></h5><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/webSecurity/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>防御方法：</p>
<ul>
<li>X-FRAME-OPTIONS</li>
<li>JS防御</li>
</ul>
<p>①X-FRAME-OPTIONS：X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。该响应头有三个属性可选：</p>
<ul>
<li>DENY，表示页面不允许通过 iframe 的方式展示</li>
<li>SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示</li>
<li>ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示</li>
</ul>
<p>②JS防御：对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;作用就是当通过 iframe 的方式加载页面时，</span><br><span class="line">&#x2F;&#x2F;攻击者的网页直接不显示所有内容了</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style id&#x3D;&quot;click-jack&quot;&gt;</span><br><span class="line">    html &#123;</span><br><span class="line">      display: none !important;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (self &#x3D;&#x3D; top) &#123;</span><br><span class="line">      var style &#x3D; document.getElementById(&#39;click-jack&#39;)</span><br><span class="line">      document.body.removeChild(style)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      top.location &#x3D; self.location</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>前端安全已经成为了面试必问的知识点，前端的发展离不开浏览器的更新换代，互联网人数的激增始终会有一些不法分子利用安全漏洞进行网络诈骗，我们作为离用户最近的开发人员，有义务去保护我们的用户的隐私安全，给用户一个良好的体验和信任。</p>
<p><img src="/2020/03/18/webSecurity/2.gif" alt=" "></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>跨域</tag>
        <tag>计算机网络</tag>
        <tag>web攻击</tag>
        <tag>防御方法</tag>
      </tags>
  </entry>
  <entry>
    <title>2020中高级前端面试题合集</title>
    <url>/2020/03/18/interview/</url>
    <content><![CDATA[<h2 id="2020中高级前端面试题合集"><a href="#2020中高级前端面试题合集" class="headerlink" title="2020中高级前端面试题合集"></a>2020中高级前端面试题合集</h2><blockquote>
<p>“全方位总结一下所遇到的面试题目，与大家共同学习，也是对自己的一次总结”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>2020是不平凡的一年，这一年里发生许多事情，大家也都知道。对于互联网行业来说也是一次重大的打击，也有一些企业在这次疫情中倒闭了，所以可能对于今年2020年毕业的同学来说是一次很大的考验，也关乎我们的前途。</p>
<p>今年的面试基本上都不会线下面试，都是采取线上电话/视频的形式来进行，今天我就总结一下，分享一下自己所遇到的一些面试题，希望大家在这次春招中能够拿到满意的offer！毕竟自己当初也是看了很多师兄姐的面经，算是一个回馈社区。共勉！</p>
<h2 id="02-目录"><a href="#02-目录" class="headerlink" title="02 目录"></a>02 目录</h2><hr>
<p>下面是这篇文章的目录结构，一般比较简单的问题我就一笔带过了，主要是分享一下比较有难度的知识点，答案来自网上，如果有版权问题我会删除。还有本文只是给出一个大概的知识点，如果想要深入学习还要靠自己去查一下哦！</p>
<p>如果答案有错误，欢迎指正！</p>
<ul>
<li>计算机基础</li>
<li>前端基础（HTML/CSS）</li>
<li>JavaScript</li>
<li>前端框架</li>
<li>浏览器渲染</li>
<li>计算机网络</li>
<li>手写代码</li>
<li>Webpack</li>
<li>Node</li>
<li>ES6</li>
</ul>
<h2 id="03-计算机基础"><a href="#03-计算机基础" class="headerlink" title="03 计算机基础"></a>03 计算机基础</h2><hr>
<h5 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a><strong>进程与线程的区别</strong></h5><p><a href="http://blog.alanwu.site/2020/03/06/process/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>进程是系统进行资源分配和调度的一个独立单位</li>
<li>线程是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位</li>
<li>一个进程至少有一个线程组成</li>
</ul>
<p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源</p>
<h5 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a><strong>进程间通信方式</strong></h5><ul>
<li>管道通信</li>
<li>消息队列通信</li>
<li>信号量通信</li>
<li>共享内存通信</li>
<li>套接字通信</li>
</ul>
<h5 id="函数库与系统库"><a href="#函数库与系统库" class="headerlink" title="函数库与系统库"></a><strong>函数库与系统库</strong></h5><ul>
<li>系统库调用运行在内核模式，函数库运行在用户模式</li>
<li>系统调用是os提供的服务，处于内核态且不能直接调用，而要使用类似int 0x80的软中断陷入内核</li>
<li>库函数中有很大部分是对系统调用的封装</li>
<li>函数库属于过程调用，开销小；系统库需用户空间和内核上下文环境切换，开销大</li>
<li>用户态可以调用系统提供API接口调用内核来切换成内核态（中断方式）</li>
</ul>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h5><ul>
<li>二叉树每一个节点不能多于两个孩子</li>
<li>没有孩子的节点就是叶子节点</li>
<li>一个节点有左右两个指针，若无则指向null</li>
<li>深度为h的二叉树最多有2^h-1个结点(h&gt;=1)，最少有h个结点</li>
<li>二叉树的遍历三种方式，如下：<br>（1）前序遍历（DLR），首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。<br>（2）中序遍历（LDR），首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。<br>（3）后序遍历（LRD），首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根</li>
</ul>
<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a><strong>数据库索引</strong></h5><ul>
<li><p>索引是一种数据结构（B+树）</p>
</li>
<li><p>不推荐使用索引</p>
</li>
</ul>
<p>（1）表记录太少；<br>（2）数据重复且分布平均的字段（只有很少数据值的列）；<br>（3）经常插入、删除、修改的表要减少索引；</p>
<ul>
<li>使用索引</li>
</ul>
<p>（1）主键，unique字段；<br>（2）和其他表做连接的字段需要加索引；<br>（3）在where里使用＞，≥，＝，＜，≤，is null和between等字段；<br>（4）使用不以通配符开始的like，where object like ‘Math%’；<br>（5）order by和group by字段；</p>
<h5 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a><strong>数据库引擎</strong></h5><ul>
<li>InnoDB存储引擎</li>
<li>MyISAM存储引擎</li>
<li>MEMORY存储引擎</li>
<li>Archive存储引擎</li>
</ul>
<h5 id="虚拟内存及缓冲区溢出"><a href="#虚拟内存及缓冲区溢出" class="headerlink" title="虚拟内存及缓冲区溢出"></a><strong>虚拟内存及缓冲区溢出</strong></h5><h6 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h6><ul>
<li>虚拟内存是计算机系统内存管理的一种技术</li>
<li>应用程序认为它拥有连续的可用的内存，实际分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上</li>
<li>虚拟内存技术可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现</li>
</ul>
<h6 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h6><ul>
<li>计算机向缓冲区填充数据时超出了缓冲区本身的容量，覆盖合法数据</li>
</ul>
<h6 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h6><ul>
<li>堆栈溢出，可以改变返回程序地址</li>
<li>程序崩溃，拒绝服务</li>
<li>执行非法代码，获取非法权限</li>
<li>程序运行失败，系统宕机，重启</li>
</ul>
<h5 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><strong>排序算法</strong></h5><p><a href="http://blog.alanwu.site/2020/03/18/jsSortMethods/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>快速排序（nlogn）</li>
<li>选择排序（n^2）</li>
<li>插入排序（n^2）</li>
<li>希尔排序（n^1.5）</li>
<li>归并排序（nlogn）</li>
<li>冒泡排序（n^2）</li>
</ul>
<h5 id="常用git指令"><a href="#常用git指令" class="headerlink" title="常用git指令"></a><strong>常用git指令</strong></h5><ul>
<li>下载一个项目和它的整个代码历史  git clone [url]</li>
<li>添加指定目录到暂存区，包括子目录   git add [dir]</li>
<li>提交暂存区到仓库区   git commit -m [修改信息]</li>
<li>同步到远程仓库， git　push</li>
<li>列出所有本地分支  git branch</li>
<li>新建一个分支，并切换到该分支  git checkout -b [branch]</li>
</ul>
<h5 id="路由器与交换机"><a href="#路由器与交换机" class="headerlink" title="路由器与交换机"></a><strong>路由器与交换机</strong></h5><ul>
<li>路由器可以给你的局域网自动分配IP，交换机只是用来分配网络数据的</li>
<li>路由器在网络层，路由器根据IP地址寻址，路由器可以处理TCP/IP协议，交换机不可以</li>
<li>交换机在中继层，交换机根据MAC地址寻址</li>
<li>路由器提供防火墙的服务，交换机不能提供该功能</li>
</ul>
<h2 id="04-前端基础（HTML-CSS）"><a href="#04-前端基础（HTML-CSS）" class="headerlink" title="04 前端基础（HTML/CSS）"></a>04 前端基础（HTML/CSS）</h2><hr>
<h5 id="flex容器布局"><a href="#flex容器布局" class="headerlink" title="flex容器布局"></a><strong>flex容器布局</strong></h5><ul>
<li><a href="http://blog.alanwu.site/2020/03/18/flexLayout/" target="_blank" rel="noopener">查看详情</a></li>
</ul>
<h6 id="主轴属性"><a href="#主轴属性" class="headerlink" title="主轴属性"></a>主轴属性</h6><ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h6 id="交叉轴属性"><a href="#交叉轴属性" class="headerlink" title="交叉轴属性"></a>交叉轴属性</h6><ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h5 id="BFC-IFC"><a href="#BFC-IFC" class="headerlink" title="BFC/IFC"></a><strong>BFC/IFC</strong></h5><p>BFC（Block Formatting Context）叫做“块级格式化上下文”</p>
<p>（1）内部的盒子会在垂直方向，一个个地放置；<br>（2）盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠；<br>（3）每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；<br>（4）BFC的区域不会与float重叠；<br>（5）BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此；<br>（6）计算BFC的高度时，浮动元素也参与计算。</p>
<p>触发条件<br>（1）float的属性不为none；<br>（2）position为absolute或fixed；<br>（3）display为inline-block，table-cell，table-caption，flex；<br>（4）overflow不为visible</p>
<p>IFC（inline Formatting Context）叫做“行级格式化上下”</p>
<p>（1）内部的盒子会在水平方向，一个个地放置；<br>（2）IFC的高度，由里面最高盒子的高度决定；<br>（3）当一行不够放置的时候会自动切换到下一行；</p>
<h5 id="CSS3的filter属性详解"><a href="#CSS3的filter属性详解" class="headerlink" title="CSS3的filter属性详解"></a><strong>CSS3的filter属性详解</strong></h5><ul>
<li><p><a href="http://blog.alanwu.site/2020/03/07/cssFilter/" target="_blank" rel="noopener">查看详情</a></p>
</li>
<li><p>blur</p>
</li>
<li><p>brightness</p>
</li>
<li><p>contrast</p>
</li>
<li><p>grayscale</p>
</li>
<li><p>hue-rotate</p>
</li>
<li><p>invert</p>
</li>
<li><p>opacity</p>
</li>
<li><p>saturate</p>
</li>
<li><p>sepia</p>
</li>
</ul>
<h5 id="CSS的继承属性（部分）"><a href="#CSS的继承属性（部分）" class="headerlink" title="CSS的继承属性（部分）"></a><strong>CSS的继承属性</strong>（部分）</h5><ul>
<li>font-size：设置字体的尺寸</li>
<li>text-indent：文本缩进</li>
<li>text-align：文本水平对齐</li>
<li>text-shadow：设置文本阴影</li>
<li>line-height：行高</li>
<li>元素可见性：visibility</li>
<li>光标属性：cursor</li>
</ul>
<h5 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a><strong>CSS盒模型</strong></h5><ul>
<li><p>W3C 标准盒模型：<br>属性width,height只包含内容content，不包含border和padding</p>
</li>
<li><p>IE 盒模型：<br>属性width,height包含border和padding，指的是content+padding+border</p>
</li>
</ul>
<p>content-box（标准盒模型）<br>border-box（IE盒模型）</p>
<h5 id="CSS的四种定位"><a href="#CSS的四种定位" class="headerlink" title="CSS的四种定位"></a><strong>CSS的四种定位</strong></h5><ul>
<li><p><strong>Static</strong></p>
<p>这个是元素的默认定位方式，元素出现在正常的文档流中，会占用页面空间。</p>
</li>
<li><p><strong>Relative</strong></p>
<p>相对定位方式，相对于其父级元素（无论父级元素此时为何种定位方式）进行定位，准确地说是相对于其父级元素所剩余的未被占用的空间进行定位（在父元素由多个相对定位的子元素时可以看出），且会占用该元素在文档中初始的页面空间，即在使用top，bottom，left，right进行移动位置之后依旧不会改变其所占用空间的位置。可以使用z-index进行在z轴方向上的移动。</p>
</li>
<li><p><strong>Absolute</strong></p>
<p>绝对定位方式，脱离文档流，不会占用页面空间。以最近的<strong>不是static定位的父级元素</strong>作为参考进行定位，如果其所有的父级元素都是static定位，那么此元素最终则是以当前窗口作为参考进行定位。可以使用top，bottom，left，right进行位置移动，<strong>亦可使用z-index在z轴上面进行移动</strong>。当元素为此定位时，如果该元素为内联元素，则会变为块级元素，即可以直接设置其宽和高的值；如果该元素为块级元素，则其宽度会由初始的100%变为auto。</p>
<p>注意：当元素设置为绝对定位时，在没有指定top，bottom，left，right的值时，他们的值并不是0，这几个值是有默认值的，默认值就是该元素设置为绝对定位前所处的正常文档流中的位置。</p>
</li>
<li><p><strong>Fixed</strong></p>
<p>绝对定位方式，直接以浏览器窗口作为参考进行定位。其它特性同absolute定位。当父元素使用了transform的时候，会以父元素定位</p>
</li>
</ul>
<h5 id="CSS权重计算"><a href="#CSS权重计算" class="headerlink" title="CSS权重计算"></a><strong>CSS权重计算</strong></h5><ul>
<li>第一等级：代表内联样式，如style=””，权值为 1000</li>
<li>第二等级：代表id选择器，如#content，权值为100</li>
<li>第三等级：代表类，伪类和属性选择器，如.content，权值为10</li>
<li>第四等级：代表标签选择器和伪元素选择器，如div p，权值为1<br>注意：通用选择器（*），子选择器（&gt;），和相邻同胞选择器（+）并不在这个等级中，所以他们的权值为0</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="CSS优化技巧"><a href="#CSS优化技巧" class="headerlink" title="CSS优化技巧"></a><strong>CSS优化技巧</strong></h5><ul>
<li>合理使用选择器</li>
<li>减少DOM操作，减少重绘和重排</li>
<li>去除无效的选择器</li>
<li>文件压缩</li>
<li>异步加载文件</li>
<li>减少@import的使用</li>
</ul>
<h5 id="px-em-rem-vh-vw"><a href="#px-em-rem-vh-vw" class="headerlink" title="px/em/rem/vh/vw"></a><strong>px/em/rem/vh/vw</strong></h5><ul>
<li>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的</li>
<li>em是相对长度单位。相对于当前父元素的字体尺寸。如未设置，则相对于浏览器的默认字体尺寸</li>
<li>rem是CSS3新增的一个相对单位。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素</li>
<li>css3新单位，view width的简写，是指可视窗口的宽度。假如宽度是1200px的话。那10vw就是120px</li>
<li>css3新单位，view height的简写，是指可视窗口的高度。假如高度是1200px的话。那10vh就是120px</li>
</ul>
<h2 id="05-JavaScript"><a href="#05-JavaScript" class="headerlink" title="05 JavaScript"></a>05 JavaScript</h2><hr>
<h5 id="闭包以及作用域"><a href="#闭包以及作用域" class="headerlink" title="闭包以及作用域"></a><strong>闭包以及作用域</strong></h5><ul>
<li><p><a href="http://blog.alanwu.site/2020/03/04/this/" target="_blank" rel="noopener">查看详情</a></p>
</li>
<li><p>作用域是可访问变量的集合，可以分为全局作用域和局部作用域。</p>
</li>
<li><p>闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
</li>
<li><p>this是在函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用</p>
</li>
</ul>
<h5 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a><strong>事件循环机制</strong></h5><ul>
<li><p><a href="http://blog.alanwu.site/2020/03/06/eventLoop/" target="_blank" rel="noopener">查看详情</a></p>
</li>
<li><p>宏任务与微任务的区别</p>
</li>
<li><p>Node中的事件循环机制</p>
</li>
</ul>
<h5 id="JS垃圾回收与V8垃圾回收"><a href="#JS垃圾回收与V8垃圾回收" class="headerlink" title="JS垃圾回收与V8垃圾回收"></a><strong>JS垃圾回收与V8垃圾回收</strong></h5><ul>
<li>JS：标记清楚法/引用计数法</li>
<li>V8：标记清除发/标记压缩法/增量标记法/压缩算法  <a href="http://blog.alanwu.site/2020/03/03/nodeCollect/" target="_blank" rel="noopener">查看详情</a></li>
</ul>
<h5 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a><strong>原型与原型链</strong></h5><ul>
<li>所有原型链的终点都是 Object 函数的 prototype 属性</li>
<li>每一个构造函数都拥有一个 prototype 属性，此属性指向一个对象，也就是原型对象</li>
<li>原型对象默认拥有一个 constructor 属性，指向指向它的那个构造函数</li>
<li>每个对象都拥有一个隐藏的属性 __ proto __，指向它的原型对象</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="JavaScript基本类型及其判断"><a href="#JavaScript基本类型及其判断" class="headerlink" title="JavaScript基本类型及其判断"></a><strong>JavaScript基本类型及其判断</strong></h5><ul>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
<li>object</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="string">'[object Boolean]'</span>: <span class="string">'boolean'</span>,</span><br><span class="line">    <span class="string">'[object Number]'</span>: <span class="string">'number'</span>,</span><br><span class="line">    <span class="string">'[object String]'</span>: <span class="string">'string'</span>,</span><br><span class="line">    <span class="string">'[object Function]'</span>: <span class="string">'function'</span>,</span><br><span class="line">    <span class="string">'[object Array]'</span>: <span class="string">'array'</span>,</span><br><span class="line">    <span class="string">'[object Date]'</span>: <span class="string">'date'</span>,</span><br><span class="line">    <span class="string">'[object RegExp]'</span>: <span class="string">'regExp'</span>,</span><br><span class="line">    <span class="string">'[object Undefined]'</span>: <span class="string">'undefined'</span>,</span><br><span class="line">    <span class="string">'[object Null]'</span>: <span class="string">'null'</span>,</span><br><span class="line">    <span class="string">'[object Object]'</span>: <span class="string">'object'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> map[str];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JavaScript数组API"><a href="#JavaScript数组API" class="headerlink" title="JavaScript数组API"></a><strong>JavaScript数组API</strong></h5><p><a href="http://blog.alanwu.site/2020/03/18/jsArrayAPI/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>push()        pop()</li>
<li>shift()        unshift()</li>
<li>sort()         reverse()</li>
<li>concat()      slice()  </li>
<li>splice()       join()</li>
<li>indexOf()     lastIndexOf()</li>
<li>forEach()      map()</li>
<li>filter()         every()</li>
<li>some()       reduce()</li>
<li>reduceRight()</li>
</ul>
<h5 id="JavaScript设计模式"><a href="#JavaScript设计模式" class="headerlink" title="JavaScript设计模式"></a><strong>JavaScript设计模式</strong></h5><p><a href="http://blog.alanwu.site/2020/03/17/designMode/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>单例模式</li>
<li>适配器模式</li>
<li>代理模式</li>
<li>发布-订阅模式</li>
<li>策略模式</li>
<li>迭代器模式</li>
</ul>
<h5 id="操作节点API总结"><a href="#操作节点API总结" class="headerlink" title="操作节点API总结"></a><strong>操作节点API总结</strong></h5><h6 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h6><ul>
<li>document.getElementById ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个</li>
<li>document.getElementsByClassName ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。</li>
<li>document.getElementsByTagName ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。 </li>
<li>document.getElementsByName ：根据元素的name属性查找，返回一个 NodeList 。 </li>
<li>document.querySelector ：返回单个Node，如果匹配到多个结果，只返回第一个。 </li>
<li>document.querySelectorAll ：返回一个 NodeList。 </li>
<li>document.forms ：获取当前页面所有form，返回一个 HTMLCollection ；</li>
</ul>
<h6 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h6><ul>
<li>createElement创建元素</li>
<li>createTextNode创建文本节点</li>
<li>cloneNode 克隆一个节点</li>
<li>createDocumentFragment 创建文档碎片，主要是用来存储临时节点，大量操作DOM时用它可以大大提升性能</li>
</ul>
<h6 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h6><ul>
<li>appendChild</li>
<li>insertBefore</li>
<li>removeChild</li>
<li>replaceChild</li>
</ul>
<h2 id="06-前端框架"><a href="#06-前端框架" class="headerlink" title="06 前端框架"></a>06 前端框架</h2><hr>
<h5 id="vue的双向数据绑定原理"><a href="#vue的双向数据绑定原理" class="headerlink" title="vue的双向数据绑定原理"></a><strong>vue的双向数据绑定原理</strong></h5><ul>
<li>监听器 Observer ，用来劫持并监听所有属性（转变成setter/getter形式），如果属性发生变化，就通知订阅者</li>
<li>订阅器 Dep，用来收集订阅者，对监听器 Observer 和 订阅者 Watcher 进行统一管理</li>
<li>订阅者 Watcher，可以收到属性的变化通知并执行相应的方法，从而更新视图</li>
<li>解析器 Compile，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="vue不能检测哪些属性变化"><a href="#vue不能检测哪些属性变化" class="headerlink" title="vue不能检测哪些属性变化"></a><strong>vue不能检测哪些属性变化</strong></h5><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><ul>
<li>使用下标更新数组元素</li>
<li>使用赋值方式改变数组长度</li>
<li>使用下标增删数组元素</li>
</ul>
<p>官方应对方法：</p>
<ul>
<li>Vue.set( target, key, value )</li>
<li>vm.items.splice(indexOfItem, 1, newValue)</li>
</ul>
<h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6><ul>
<li>增删元素</li>
</ul>
<p>官方应对方法：</p>
<ul>
<li>Vue.set(target,  propertyName, value);</li>
<li>Vue.delete( target, propertyName/index )</li>
</ul>
<h5 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a><strong>虚拟DOM</strong></h5><p><a href="http://blog.alanwu.site/2020/03/03/virtualDom/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树</li>
</ul>
<h5 id="vue模板解析"><a href="#vue模板解析" class="headerlink" title="vue模板解析"></a><strong>vue模板解析</strong></h5><p><a href="http://blog.alanwu.site/2020/03/08/vueTemplate/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>模板变成AST（解析器）</li>
<li>AST遍历静态节点（优化器）</li>
<li>生成渲染函数（代码生成器）</li>
</ul>
<h5 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a><strong>diff算法</strong></h5><ul>
<li>diff算法是比对组件中的节点异同的情况</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a><strong>vue的生命周期</strong></h5><ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
<li>beforeUpdate</li>
<li>updated</li>
<li>beforeDestroy</li>
<li>destroyed</li>
<li>activated</li>
<li>deactivated</li>
<li>erroeCaptured</li>
</ul>
<h5 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><strong>vuex</strong></h5><p><a href="http://blog.alanwu.site/2020/03/10/vuex/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>state：用于数据的存储，是store中的唯一数据源</li>
<li>getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li>
<li>mutation：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</li>
<li>action：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作</li>
<li>modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li>
</ul>
<h5 id="vue组件通信方式"><a href="#vue组件通信方式" class="headerlink" title="vue组件通信方式"></a><strong>vue组件通信方式</strong></h5><ul>
<li>props / $emit 适用 父子组件通信</li>
<li>ref 与 $parent / $children 适用 父子组件通信</li>
<li>EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</li>
<li>$attrs/$listeners 适用于 隔代组件通信</li>
<li>provide / inject 适用于 隔代组件通信</li>
<li>Vuex 适用于 父子、隔代、兄弟组件通信</li>
</ul>
<h5 id="watch-computed的区别"><a href="#watch-computed的区别" class="headerlink" title="watch/computed的区别"></a><strong>watch/computed的区别</strong></h5><ul>
<li>computed是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值</li>
<li>watch是观察监听的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作</li>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch</li>
</ul>
<h5 id="v-if与v-show的区别"><a href="#v-if与v-show的区别" class="headerlink" title="v-if与v-show的区别"></a><strong>v-if与v-show的区别</strong></h5><ul>
<li>v-if 是真正的条件渲染，直到条件第一次变为真时，才会开始渲染</li>
<li>v-show是由display样式决定，不管初始条件是什么都会渲染</li>
<li>v-if 适用于不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景</li>
</ul>
<h5 id="vue中的路由模式"><a href="#vue中的路由模式" class="headerlink" title="vue中的路由模式"></a><strong>vue中的路由模式</strong></h5><h6 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h6><ul>
<li><ul>
<li>HTML5中的两个API：pushState和replaceState，改变url之后页面不会重新刷新，也不会带有#号，页面地址美观，url的改变会触发popState事件，监听该事件也可以实现根据不同的url渲染对应的页面内容</li>
<li>但是因为没有#会导致用户在刷新页面的时候，还会发送请求到服务端，为避免这种情况，需要每次url改变的时候，都将所有的路由重新定位到跟路由下</li>
</ul>
</li>
</ul>
<h6 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h6><ul>
<li><ul>
<li>url hash: http ://foo.com/#help</li>
<li>#后面hash值的改变，并不会重新加载页面，同时hash值的变化会触发hashchange事件，该事件可以监听，可根据不同的哈希值渲染不同的页面内容</li>
</ul>
</li>
</ul>
<h5 id="vue-3-0中proxy数据双向绑定"><a href="#vue-3-0中proxy数据双向绑定" class="headerlink" title="vue 3.0中proxy数据双向绑定"></a><strong>vue 3.0中proxy数据双向绑定</strong></h5><ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<h2 id="07-浏览器渲染"><a href="#07-浏览器渲染" class="headerlink" title="07 浏览器渲染"></a>07 浏览器渲染</h2><hr>
<h5 id="输入网址到现实的过程"><a href="#输入网址到现实的过程" class="headerlink" title="输入网址到现实的过程"></a><strong>输入网址到现实的过程</strong></h5><ol>
<li>重定向</li>
<li>查看缓存</li>
<li>DNS解析，获取IP地址</li>
<li>TCP连接建立</li>
<li>发送报文请求</li>
<li>响应报文数据</li>
<li>浏览器解析数据</li>
<li>渲染</li>
</ol>
<p>补充：这里值得注意的是，很多同学都会忽略<strong>重定向</strong>这个过程，其实重定向是一个很重要的部分。我们尝试使用webpagetest工具测试一下百度的网址。</p>
<p>第一次是输入 <a href="https://baidu.com后测试的效果" target="_blank" rel="noopener">https://baidu.com后测试的效果</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>第二次是输入<a href="https://www.baidu.com后测试的效果，可见两次请求相差1.8s左右，这是一个很慢的过程。" target="_blank" rel="noopener">https://www.baidu.com后测试的效果，可见两次请求相差1.8s左右，这是一个很慢的过程。</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a><strong>节流与防抖</strong></h5><h6 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h6><p>比如公交车站等车，每经过30分钟就会发车，不管后面还有没有人都会发车。这就是节流的过程。</p>
<h6 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h6><p>以最后一个乘客为准，再等30分钟，如果30分钟内都没有人上车，就会发车。如果在期间有人上车，那么重新等30分钟。这就是防抖的过程。</p>
<h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><strong>浏览器缓存</strong></h5><p><a href="http://blog.alanwu.site/2020/01/31/navigatorCache/" target="_blank" rel="noopener">查看详情</a></p>
<h6 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h6><ul>
<li>Service Worker</li>
<li>Menory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h6 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h6><ul>
<li>强缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires:Wed, 22 Oct 2018 08:41:00 GMT</span><br><span class="line">Cache-control:Cache-control: max-age&#x3D;30</span><br></pre></td></tr></table></figure>

<ul>
<li>协商缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last-Modified</span><br><span class="line">If-Modified-Since</span><br><span class="line">ETag</span><br><span class="line">If-None-Match</span><br></pre></td></tr></table></figure>



<h5 id="BOM对象模型"><a href="#BOM对象模型" class="headerlink" title="BOM对象模型"></a><strong>BOM对象模型</strong></h5><ul>
<li>screen</li>
<li>window</li>
<li>navigator</li>
<li>location</li>
<li>document</li>
<li>history</li>
</ul>
<h5 id="Location对象属性"><a href="#Location对象属性" class="headerlink" title="Location对象属性"></a><strong>Location对象属性</strong></h5><ul>
<li>hash               设置或返回从#开始的URL </li>
<li>host               设置或返回主机名和当前URL的端口号 </li>
<li>hostname       设置或返回当前URL的主机名 </li>
<li>href                 设置或返回完整的URL </li>
<li>pathname       设置或返回当前URL的路径部分 </li>
<li>port                 设置或返回当前URL的端口号 </li>
<li>search             设置或返回从?开始的URL(查询部分)</li>
</ul>
<h5 id="跨域相关问题"><a href="#跨域相关问题" class="headerlink" title="跨域相关问题"></a><strong>跨域相关问题</strong></h5><p><a href="http://blog.alanwu.site/2020/03/06/crossOrigin/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>JSONP</li>
<li>CORS</li>
<li>document.domain</li>
<li>postMessage</li>
<li>nginx</li>
<li>window.name</li>
</ul>
<h5 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a><strong>cookie与session</strong></h5><ul>
<li>cookie保存在客户端（浏览器）；session保存在服务端（redis）</li>
<li>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间</li>
</ul>
<p>例子：</p>
<p>当客户端第一次请求登录服务器的时候，服务器随机下发一个字符串sessionId给浏览器，以cookie的形式保存在客户端。当下次登录的时候会带上这个cookie，从而识别你是谁。</p>
<p>cookie的优点：</p>
<p>1.极高的扩展性和可用性<br>2.通过良好的编程，控制保存在cookie中的session对象的大小。<br>3.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>4.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>5.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p>
<p>cookie的缺点：</p>
<p>1.cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
<h5 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a><strong>浏览器存储</strong></h5><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">cookie</th>
<th align="center">localStorage</th>
<th align="center">sessionStorage</th>
<th align="center">indexDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据生命周期</td>
<td align="center">一般由服务器生成，可以设置过期时间</td>
<td align="center">除非被清理，否则一直存在</td>
<td align="center">页面关闭就清理</td>
<td align="center">除非被清理，否则一直存在</td>
</tr>
<tr>
<td align="center">数据存储大小</td>
<td align="center">4K</td>
<td align="center">5M</td>
<td align="center">5M</td>
<td align="center">无限</td>
</tr>
<tr>
<td align="center">与服务端通信</td>
<td align="center">每次都会携带在 header 中，对于请求性能影响</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
</tr>
</tbody></table>
<h5 id><a href="#" class="headerlink" title="****"></a>****</h5><h2 id="08-计算机网络"><a href="#08-计算机网络" class="headerlink" title="08 计算机网络"></a>08 计算机网络</h2><hr>
<h5 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a><strong>TCP/UDP协议</strong></h5><p><a href="http://blog.alanwu.site/2020/03/05/tcpAndUdp/" target="_blank" rel="noopener">查看详情</a></p>
<p>TCP是一种面向来连接的、可靠的、基于字节流的传输层通信协议。在计算机网络的OSI模型中，它完成第四层传输层所指定的功能。</p>
<ul>
<li>面向连接</li>
<li>仅支持单播传输</li>
<li>面向字节流</li>
<li>可靠传输</li>
<li>提供全双工通信</li>
</ul>
<p>UDP是一种简单的面向数据报、面向无连接、不可靠的通信协议，位于OSI模型的传输层。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。</p>
<ul>
<li><p>面向无连接</p>
</li>
<li><p>不可靠传输</p>
</li>
<li><p>提供单播、多播和广播</p>
</li>
<li><p>面向报文</p>
</li>
</ul>
<h5 id="TCP如何保证数据传输"><a href="#TCP如何保证数据传输" class="headerlink" title="TCP如何保证数据传输"></a><strong>TCP如何保证数据传输</strong></h5><p><a href="http://blog.alanwu.site/2020/03/07/howToEnsureTcp/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>检验和</li>
<li>序列号/确认应答</li>
<li>超时重传</li>
<li>最大消息长度</li>
<li>滑动窗口控制</li>
<li>拥塞控制</li>
</ul>
<h5 id="GET-POST的本质区别"><a href="#GET-POST的本质区别" class="headerlink" title="GET/POST的本质区别"></a><strong>GET/POST的本质区别</strong></h5><p><a href="http://blog.alanwu.site/2020/03/18/getandpost/" target="_blank" rel="noopener">查看详情</a></p>
<p>GET/POST的最大区别是GET请求有幂等性，但是POST请求没有。什么是幂等性呢？我们知道使用GET方法请求同样的接口，返回来的数据是不会改变的，但是对于POST请求，实现一些增删改查的操作的时候可能会发生重复提交的问题。</p>
<p>也就是说我们如果使用GET请求做增删改查的时候，遇到网络不好可能会多次操作，造成数据库的混乱，这是一个很严重的问题，但是使用POST就不会有这种情况。</p>
<h5 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a><strong>http与https的区别</strong></h5><p><a href="http://blog.alanwu.site/2020/03/08/https/" target="_blank" rel="noopener">查看详情</a></p>
<h6 id="https握手"><a href="#https握手" class="headerlink" title="https握手"></a>https握手</h6><ul>
<li>首先客户端发起请求到服务端，服务端处理后发送一个公钥给客户端</li>
<li>客户端进行验证公钥，看公钥是否有效和是否过期</li>
<li>客户端验证通过会产生随机值key，然后用公钥进行加密回传给服务端</li>
<li>服务端用私钥解密后获得客户端的随机值key</li>
<li>利用随机值key加密数据后传输给客户端</li>
<li>客户端利用key值进行解密数据</li>
<li>客户端获取真正的数据</li>
</ul>
<h5 id="CDN的优化原理"><a href="#CDN的优化原理" class="headerlink" title="CDN的优化原理"></a><strong>CDN的优化原理</strong></h5><p>CDN的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p>
<p>CDN的工作原理就是将您源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/interview/6.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="HTTP-2-0-的新特性"><a href="#HTTP-2-0-的新特性" class="headerlink" title="HTTP 2.0 的新特性"></a><strong>HTTP 2.0 的新特性</strong></h5><p><a href="http://blog.alanwu.site/2020/03/03/http2/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>二进制分帧</li>
<li>多路复用</li>
<li>首部压缩</li>
<li>流量控制</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ul>
<h5 id="常见HTTP首部"><a href="#常见HTTP首部" class="headerlink" title="常见HTTP首部"></a><strong>常见HTTP首部</strong></h5><h6 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h6><ul>
<li>Cache-Control: 控制缓存的行为</li>
<li>Connection：逐跳首部，连接的管理</li>
<li>Date：创建报文的日期时间</li>
<li>Pragma：报文指令</li>
<li>Trailer：报文末端的首部一览</li>
<li>Transfer-Encoding：指定报文主体的传输编码方式</li>
<li>Upgrade：升级为其他协议</li>
</ul>
<h6 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h6><ul>
<li>Accept: 用户代理可处理的媒体类型</li>
<li>Accept-Charset: 优先的字符集</li>
<li>Accept-Encoding: 优先的内容编码</li>
<li>Accept-Language: 优先的语言</li>
<li>Authorization: web 认证信息</li>
<li>From: 用户的电子邮箱地址</li>
<li>Host: 请求资源所在服务器</li>
<li>if-Match: 比较实体标记</li>
<li>if-Modified-Since: 比较资源的更新时间</li>
<li>if-None-Match: 比较实体标记（与if-Match相反）</li>
<li>if-Range: 资源为更新时发送实体Byte的范围请求</li>
<li>if-Unmodified-Since: 比较资源的更新时间</li>
<li>Referer: 对请求中的 Url 的原始获取方法</li>
<li>User-Agent: HTTP 客户端程序的信息</li>
</ul>
<h6 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h6><ul>
<li>Accept-Ranges: 是否接受字节范围请求</li>
<li>Age: 推算资源创建经过时间</li>
<li>ETag: 资源的匹配信息</li>
<li>Location: 令客户端重定向至指定的URL</li>
<li>Proxy-Authenticate: 代理服务器对客户端的认证信息</li>
<li>Rety-After: 对再次发起请求的时机要求</li>
<li>Server: HTTP服务器的安装信息</li>
<li>Vary: 代理服务器缓存的管理信息</li>
<li>WWW-Authenticate: 服务器对客户端的认证信息</li>
</ul>
<h5 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a><strong>Web安全</strong></h5><p><a href="http://blog.alanwu.site/2020/03/18/webSecurity/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>浏览器安全</li>
<li>跨站脚本攻击(XSS)</li>
<li>跨站请求伪造(CSRF)</li>
<li>点击劫持(ClickJacking)</li>
</ul>
<h5 id="扫码登录实现原理"><a href="#扫码登录实现原理" class="headerlink" title="扫码登录实现原理"></a><strong>扫码登录实现原理</strong></h5><p><a href="http://blog.alanwu.site/2020/03/03/scanCodeToLogin/" target="_blank" rel="noopener">查看详情</a></p>
<h6 id="二维码与网页服务器"><a href="#二维码与网页服务器" class="headerlink" title="二维码与网页服务器"></a>二维码与网页服务器</h6><p>当我们打开微信的网页版的时候，查看控制台发现发送了一个请求登录的请求，然后网页服务器就随机产生了一个uuid返回给浏览器，而且这个uuid是和二维码绑定在一起的。服务器会把uuid作为key存进redis缓存服务器里面，类似 uuid：xxxx 的形式。</p>
<h6 id="二维码与手机服务器"><a href="#二维码与手机服务器" class="headerlink" title="二维码与手机服务器"></a>二维码与手机服务器</h6><p>手机进行扫描二维码，然后手机携带uuid和用户信息向手机的服务器发送请求，手机服务器收到之后携带uuid去redis服务器查询用户，并把uuid与用户信息绑定在一起。查询用户成功之后返回一个Token给网页服务器，通过解析这个Token可以拿出用户的信息，然后浏览器就成功登录微信了。</p>
<h5 id="前后端鉴权"><a href="#前后端鉴权" class="headerlink" title="前后端鉴权"></a><strong>前后端鉴权</strong></h5><p><a href="http://blog.alanwu.site/2020/03/04/Authorization/" target="_blank" rel="noopener">查看详情</a></p>
<p>前后之间进行数据交互，当然后端要判断你是否是真正的操作者，只有符合条件的用户才可以操作。也就是说必须要有一个身份证明你是一个好人。通常会有四种方式：</p>
<ul>
<li>HTTP Basic Authentication</li>
<li>session-cookie机制</li>
<li>Token验证</li>
<li>OAuth开放授权</li>
</ul>
<h5 id="单点登录的实现"><a href="#单点登录的实现" class="headerlink" title="单点登录的实现"></a><strong>单点登录的实现</strong></h5><p><a href="http://blog.alanwu.site/2020/03/03/singleSignOn/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>实现一个认证中心，登录并保存用户信息</li>
<li>访问A系统先定向到认证中心</li>
<li>访问B系统先定向到认证中心</li>
<li>则A/B系统就可以间接打通</li>
</ul>
<h5 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a><strong>HTTP请求方法</strong></h5><ul>
<li>head（获取报文首部）</li>
<li>put（传输文件）</li>
<li>delete（删除文件）</li>
<li>options（询问支持方法）</li>
<li>trace（追踪路径）</li>
<li>connect（要求用隧道协议连接代理）</li>
</ul>
<h5 id="ajax-axios-fetch区别"><a href="#ajax-axios-fetch区别" class="headerlink" title="ajax/axios/fetch区别"></a><strong>ajax/axios/fetch区别</strong></h5><h6 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h6><ul>
<li>不符合现在前端MVVM的浪潮</li>
<li>基于原生的XHR开发，XHR本身的架构不清晰</li>
<li>jQuery整个项目太大，单纯使用ajax却要引入整个jQuery</li>
</ul>
<h6 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h6><ul>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>客户端支持防止CSRF</li>
<li>提供了一些并发请求的接口</li>
</ul>
<h6 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h6><ul>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
<li>fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li>
<li>fetch默认不会带cookie，需要添加配置项</li>
<li>fetch没有办法原生监测请求的进度，而XHR可以</li>
</ul>
<h5 id="webSocket通信原理"><a href="#webSocket通信原理" class="headerlink" title="webSocket通信原理"></a><strong>webSocket通信原理</strong></h5><ul>
<li>客户端会先发送一个HTTP请求，包含一个Upgrade请求头来告诉服务端要升级为WebSocket协议</li>
<li>服务器就会返回101状态码并切换为WebSocket协议建立全双工连接，后续信息将会通过这个协议进行传输</li>
</ul>
<p>有几个头信息需要注意一下：</p>
<p>Sec-WebSocket-Key：客户端随机生成的一个base64编码<br>Sec-WebSocket-Accept：服务端经过算法处理后回传给客户端<br>Connection和Upgrade字段告诉服务器，客户端发起的是WebSocket协议请求</p>
<h2 id="09-手写代码"><a href="#09-手写代码" class="headerlink" title="09 手写代码"></a>09 手写代码</h2><hr>
<p>由于手写代码部分需要的篇幅比较多，我就简单列举出来需要熟悉哪一些手写的知识点，大家可以自行谷歌。</p>
<ul>
<li>bind/call/apply</li>
<li>class与原形链实现继承</li>
<li>promise的简单版</li>
<li>深拷贝实现</li>
<li>节流与防抖函数</li>
<li>函数柯里化</li>
<li>new的原理实现</li>
<li>常用算法排序（快排）</li>
<li>常见设计模式</li>
<li>实现水平垂直居中</li>
</ul>
<p><strong>重要的是多刷题，可以看剑指offer，leetcode！</strong></p>
<h2 id="10-Webpack"><a href="#10-Webpack" class="headerlink" title="10 Webpack"></a>10 Webpack</h2><hr>
<p>webpack参考深入浅出webpack的书本内容，里面介绍非常到位，大家可以一看。</p>
<h5 id="webpack作用"><a href="#webpack作用" class="headerlink" title="webpack作用"></a><strong>webpack作用</strong></h5><ul>
<li>代码转换</li>
<li>文件优化</li>
<li>代码分割</li>
<li>模块合并</li>
<li>自动刷新</li>
<li>代码校验</li>
<li>自动发布</li>
</ul>
<h5 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a><strong>打包原理</strong></h5><p>（1）初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>（2）开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译；<br>（3）确定入口：根据配置中的 entry 找出所有入口文件；<br>（4）编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>（5）完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容及它们之间的依赖关系；<br>（6）输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会；<br>（7）输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中；</p>
<h5 id="loader与plugin的区别"><a href="#loader与plugin的区别" class="headerlink" title="loader与plugin的区别"></a><strong>loader与plugin的区别</strong></h5><p>loader，它是一个转换器，文件内容进行翻译，，比如将es6转换为es5，单纯的文件转换过程</p>
<p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后。webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，并且执行相对应的任务</p>
<h5 id="HappyPack的原理"><a href="#HappyPack的原理" class="headerlink" title="HappyPack的原理"></a><strong>HappyPack的原理</strong></h5><p>webpack中最耗时的就是loader的转换过程，转换的流程很长。happypack的原理就是把这部分的任务拆解成多个子进程去并行处理，减少构建时间。</p>
<p>通过new HappyPack()实例化，然后把任务交由实例统一调度分配。核心调度器会将一个个任务分配给空闲的子进程。处理完毕后发送给核心调度器。</p>
<h5 id="如何优化webpack配置"><a href="#如何优化webpack配置" class="headerlink" title="如何优化webpack配置"></a><strong>如何优化webpack配置</strong></h5><h6 id="缩小文件查找范围"><a href="#缩小文件查找范围" class="headerlink" title="缩小文件查找范围"></a>缩小文件查找范围</h6><ul>
<li>优化loader</li>
<li>优化resolve.modules</li>
<li>优化resolve.mainFields</li>
<li>优化resolve.alias</li>
<li>优化resolve.extensions</li>
<li>优化module.noPaese</li>
</ul>
<h6 id="使用DllPlugin"><a href="#使用DllPlugin" class="headerlink" title="使用DllPlugin"></a>使用DllPlugin</h6><ul>
<li>基础模块抽离，打包到动态链接库</li>
<li>需要使用模块，直接去动态链接库查找</li>
</ul>
<h6 id="使用HappyPack"><a href="#使用HappyPack" class="headerlink" title="使用HappyPack"></a>使用HappyPack</h6><ul>
<li>单线程变多进程</li>
</ul>
<h6 id="使用ParallelUglifyPlugin"><a href="#使用ParallelUglifyPlugin" class="headerlink" title="使用ParallelUglifyPlugin"></a>使用ParallelUglifyPlugin</h6><ul>
<li>开启多进程压缩代码，并行执行</li>
</ul>
<h6 id="使用CDN加速"><a href="#使用CDN加速" class="headerlink" title="使用CDN加速"></a>使用CDN加速</h6><ul>
<li>静态资源放到CDN服务器上面</li>
</ul>
<h6 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h6><ul>
<li>剔除无用的代码</li>
</ul>
<h6 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h6><ul>
<li>防止相同资源重复加载</li>
<li>减少网络流量及服务器成本</li>
</ul>
<h6 id="使用prepack"><a href="#使用prepack" class="headerlink" title="使用prepack"></a>使用prepack</h6><ul>
<li>编译代码时提前计算结果放到编译后的结果中，而不是在代码运行才求值</li>
</ul>
<h2 id="11-Node"><a href="#11-Node" class="headerlink" title="11 Node"></a>11 Node</h2><hr>
<h5 id="Node的特点"><a href="#Node的特点" class="headerlink" title="Node的特点"></a><strong>Node的特点</strong></h5><p><a href="http://blog.alanwu.site/2020/03/03/nodeCharator/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>异步IO</li>
<li>事件驱动</li>
<li>单线程</li>
<li>跨平台</li>
</ul>
<h5 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a><strong>V8垃圾回收机制</strong></h5><p><a href="http://blog.alanwu.site/2020/03/03/nodeCollect/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>新生代：Scavenge算法</li>
<li>老生代：Mark-Sweep算法、Mark-Compact算法、Incremental Marking算法</li>
</ul>
<h5 id="PM2进程守候"><a href="#PM2进程守候" class="headerlink" title="PM2进程守候"></a><strong>PM2进程守候</strong></h5><ul>
<li>内建负载均衡（使用 Node cluster 集群模块）</li>
<li>后台运行</li>
<li>0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.</li>
<li>具有 Ubuntu 和 CentOS 的启动脚本</li>
<li>停止不稳定的进程（避免无限循环）</li>
<li>控制台检测</li>
<li>提供 HTTP API</li>
<li>远程控制和实时的接口 API ( Nodejs 模块,允许和 PM2 进程管理器交互 )</li>
</ul>
<h5 id="Buffer对象"><a href="#Buffer对象" class="headerlink" title="Buffer对象"></a><strong>Buffer对象</strong></h5><p><a href="http://blog.alanwu.site/2020/03/04/buffer/" target="_blank" rel="noopener">查看详情</a></p>
<ul>
<li>Buffer是一个像Array的对象，它的元素都是16进制的两位数。是一个典型的JavaScript与C++结合的模块，设计性能的相关部分采用了C++实现，而非性能部分采用了JavaScript实现。<strong>Buffer对象可以用来操作二进制数据流</strong>。</li>
<li>Buffer对象的内存分配不是在V8的堆内存中的，而是由Node的C++层面实现的内存申请的</li>
</ul>
<p>分配机制</p>
<h6 id="小对象"><a href="#小对象" class="headerlink" title="小对象"></a>小对象</h6><p>slab 内存分配机制<strong>。它是一种动态内存管理机制，采用的是</strong>预先申请，事后分配**的方式，简单来说它就是一块申请好的固定大小的内存区域。有如下3种状态：</p>
<ul>
<li>full：完全分配</li>
<li>partial：部分分配</li>
<li>empty：没有被分配</li>
</ul>
<h6 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h6><p>如果这个对象是超过了 slab 的大小，那么就不会占用slab块，直接使用C++层面分配你所需要的大小，这块空间就会被你一直占有</p>
<h2 id="12-ES6"><a href="#12-ES6" class="headerlink" title="12 ES6"></a>12 ES6</h2><hr>
<h5 id="promise"><a href="#promise" class="headerlink" title="promise"></a><strong>promise</strong></h5><p><a href="http://blog.alanwu.site/2020/03/06/promise/" target="_blank" rel="noopener">查看详情</a></p>
<p>在阮一峰老师的ES6入门标准中说到，所谓promise就是一个容器，里面保存着某个未来才会结束的事件（通常是是一个异步事件）。它有两个特点：</p>
<ul>
<li><strong>状态不受外界影响</strong>：拥有三种状态（Pending、Fullfilled、Rejected）。状态只取决于异步执行结果，其他过程无法改变这个状态。</li>
<li><strong>状态改变不会再变</strong>：初始状态为Pending状态，它只可以变成Fullfill或者变成Rejected，但是一旦发生改变就不会再变。</li>
</ul>
<p>promise可以使得异步操作的写法像同步写法一样优雅，代码可读性更高。但是缺点就是中途无法取消promise，一旦新建就会执行，假如没有设置回调函数，Promise内部如果出现错误不会反应到外部。</p>
<h6 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h6><ul>
<li>then()/catch()</li>
<li>all()/race()</li>
<li>resolve()/reject()</li>
<li>done()/finally()</li>
</ul>
<h5 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><strong>proxy</strong></h5><p><a href="http://blog.alanwu.site/2020/03/04/proxy/" target="_blank" rel="noopener">查看详情</a></p>
<p>Proxy可以理解为，当你试图访问一个对象的时候必须先经过一个拦截或者代理，你才可以进行对对象的操作。这种机制的好处就是可以对外界的访问进行过滤和改写。</p>
<ul>
<li>get(target, propKey, receiver) 拦截对象属性读取</li>
<li>set(target, propKey, value, receiver) 拦截对象的属性设置</li>
<li>has(target, propKey) 拦截propkey in proxy</li>
<li>deleteProperty(target, propKey) 拦截delete proxy[propKey]</li>
<li>ownKeys(target)</li>
<li>getOwnPropertyDescriptor(target, propKey) 返回对象属性的描述对象拦截</li>
<li>defineProperty(target, propKey, propDesc)</li>
<li>proventExtensions(target)</li>
<li>getPrototypeOf(target)</li>
<li>isExtensible(target)</li>
<li>setPrototypeOf(target, proto)</li>
<li>apply(target, object, args)</li>
<li>construct(target, args) 拦截 proxy 实例作为构造函数调用的操作</li>
<li>revocable(target, handler) 方法返回 一个可取消 Proxy实例</li>
</ul>
<h6 id="ES6的新特性"><a href="#ES6的新特性" class="headerlink" title="ES6的新特性"></a><strong>ES6的新特性</strong></h6><p><a href="http://blog.alanwu.site/2020/03/11/ES6/" target="_blank" rel="noopener">查看详情</a></p>
<p>ES6新增了很多新特性，这里不可能每一个都详细讲述，面试中我遇到的有以下几个，你把它们都讲述清楚就可以过关了。</p>
<ul>
<li>let、var、const区别</li>
<li>箭头函数</li>
<li>解构赋值</li>
<li>模板字符串</li>
<li>Set、Map数据结构</li>
<li>Promise对象</li>
<li>Proxy</li>
</ul>
<h5 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a><strong>class继承</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="13-推荐书籍"><a href="#13-推荐书籍" class="headerlink" title="13 推荐书籍"></a>13 推荐书籍</h2><hr>
<p>《JavaScript高级程序设计》<br>《ES6标准入门》<br>《深入浅出NodeJS》<br>《深入浅出webpack》<br>《深入浅出vue.js》<br>《JavaScript设计模式与开发实践》<br>《图解HTTP》<br>《图解TCP/IP》<br>《剑指offer》</p>
<h2 id="14-思考与感悟"><a href="#14-思考与感悟" class="headerlink" title="14 思考与感悟"></a>14 思考与感悟</h2><hr>
<p>其实整个备考的过程中，心态也是很重要的一部分，就好像我们当年高考的时候，心态一定要好。可能同学们经过很长的时间备考，然后投递了很多简历却没有面试机会。</p>
<p>首先要看一下是不是简历写得不好，一般没有机会大部分都是因为这个原因，可以找一下师兄姐聊一下如何修改简历。然后重新投递试试。或者有了面试机会却没有下轮面试了，那就是可能因为你的技术不够扎实，好好准备自己的基础，我推荐你：</p>
<h5 id="写技术博客"><a href="#写技术博客" class="headerlink" title="写技术博客"></a><strong>写技术博客</strong></h5><p>不用自己去搭建一个博客（要是可以就更好了），选择一个平台，CSDN或者掘金都是不错的平台，然后就可以开始你的表演了。可以写一些最近的学习心得，面试技巧以及黑科技工具的使用等等。写博客的好处有很多，不仅可以锻炼的表达逻辑，还可以巩固你的知识体系。两全其美，何乐而不为？</p>
<p>另外就是可以多逛一下技术社区，了解前端的动态，多关注最近出了什么新技术、新框架、新八卦等等。试着去帮别人解答一些问题，别人也很愿意去听，但是不要抬杠。乐于分享的心态比技术本身更重要。</p>
<h5 id="写项目"><a href="#写项目" class="headerlink" title="写项目"></a><strong>写项目</strong></h5><p>找一个idea，把之前所学的知识点用一下，或者用新的知识来重构一下旧的项目，都是一种产出的方法。如果你担心知识不够牢固可以上一下github找一些优质开源项目，看别人是怎么写的。项目中要把用到技术的那一块注释出来，不然过一个月都不知道是你写的。</p>
<h5 id="交流心得"><a href="#交流心得" class="headerlink" title="交流心得"></a><strong>交流心得</strong></h5><p>要是可以的话，可以找同学一起交流最近的学习成果。技术学习的路上是枯燥的，找到相同的学习伙伴很重要，能够给你一种学下去的动力，两个相互切磋相互进步也是一种产出的方法。</p>
<p>面试。如果你觉得技术还可以，基础还不错的话就尝试去面试一下，面试官一般比你的层次高很多，知识储备也比你多，所以面试是一个非常重要的过程，还可以查漏补缺，完善自己的知识体系。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a> 常用 Git 命令清单</li>
<li><a href="https://yq.aliyun.com/articles/636314" target="_blank" rel="noopener">https://yq.aliyun.com/articles/636314</a> Mysql四种常见数据库引擎</li>
<li><a href="https://www.nowcoder.com/discuss/258810?type=post&amp;order=time&amp;pos=&amp;page=3" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/258810?type=post&amp;order=time&amp;pos=&amp;page=3</a> 个人秋招经验总结（前端方向）</li>
<li><a href="https://www.jianshu.com/p/2fa55947921d" target="_blank" rel="noopener">https://www.jianshu.com/p/2fa55947921d</a> css四种定位</li>
<li><a href="http://www.nowamagic.net/csszone/css_SeletorPriorityRules.php" target="_blank" rel="noopener">http://www.nowamagic.net/csszone/css_SeletorPriorityRules.php</a> CSS选择器的权重与优先规则</li>
<li><a href="https://www.runoob.com/w3cnote/px-em-rem-different.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/px-em-rem-different.html</a> px、em、rem区别介绍</li>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a> vue官方文档——生命周期</li>
<li><a href="https://zhangmingemma.github.io/2018/10/16/vueRouter-achieve.html" target="_blank" rel="noopener">https://zhangmingemma.github.io/2018/10/16/vueRouter-achieve.html</a> vue-router实现原理</li>
<li><a href="https://juejin.im/post/5d59f2a451882549be53b170" target="_blank" rel="noopener">https://juejin.im/post/5d59f2a451882549be53b170</a> 30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</li>
<li><a href="https://blog.csdn.net/qq_30114149/article/details/73741771" target="_blank" rel="noopener">https://blog.csdn.net/qq_30114149/article/details/73741771</a> cookie，session优缺点</li>
<li><a href="https://blog.fundebug.com/2019/03/22/differences-of-tcp-and-udp/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/03/22/differences-of-tcp-and-udp/</a> 一文搞懂TCP与UDP的区别</li>
<li><a href="https://www.imydl.com/work/4073.html" target="_blank" rel="noopener">https://www.imydl.com/work/4073.html</a>  使用 CDN 的好处和注意事项</li>
<li><a href="https://segmentfault.com/a/1190000012836882" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012836882</a> Jquery ajax, Axios, Fetch区别之我见</li>
<li><a href="https://juejin.im/post/5be406705188256dbb5176f9#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5be406705188256dbb5176f9#heading-14</a> PM2简易使用手册</li>
<li>深入浅出 vue.js</li>
<li>深入浅出 webpack</li>
<li>JavaScript设计模式与开发实践</li>
</ul>
<p><img src="/2020/03/18/interview/2.gif" alt></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>面试</tag>
        <tag>前端</tag>
        <tag>随想录</tag>
        <tag>大厂</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式浅析</title>
    <url>/2020/03/17/designMode/</url>
    <content><![CDATA[<h2 id="JavaScript设计模式浅析"><a href="#JavaScript设计模式浅析" class="headerlink" title="JavaScript设计模式浅析"></a>JavaScript设计模式浅析</h2><blockquote>
<p> 设计模式最早的起源其实是源于建筑学，针对某一个问题而提出的一个解决方案</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/designMode/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>设计模式我们其实听过不少，但是当别人问具体是什么或者有哪些设计模式的时候，我们有可能会不知道或者回答不全。其实我们在开发的过程中可能很少会用到设计模式，因为很多东西别人都帮我们封装好了，我们直接拿过来用即可。</p>
<p>前端的开发经过一遍封装过后变得无比容易，我们在运用的过程中得心应手，只有在源码阅读的过程中才会看到。大概浏览了一下JavaScript设计模式这本书，所以总结一下常用的几种模式，面试也有可能会问到。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/designMode/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-设计模式"><a href="#02-设计模式" class="headerlink" title="02 设计模式"></a>02 设计模式</h2><hr>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h5><p>故名思意，我们从字面上的意思就可以看到，可以想象一座工厂源源不断产出一样的产品，流水线作业。没错，工厂模式就是这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Factory.create(<span class="string">'alanwu'</span>).getName()  <span class="comment">//alanwu</span></span><br></pre></td></tr></table></figure>

<p>我们首先创建一个工厂，我们只要传递参数进去，里面具体的过程我们不用去关心，最后返回一个对象。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/designMode/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h5><p>单例模式就是保证一个类仅有一个实例，并提供一个访问它的全局访问点。其实这有一点像我们vuex当中的实现，也是一个全局的状态管理，并且提供一个接口访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = Singleton.getInstance(<span class="string">'alan1'</span>);</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance(<span class="string">'alan2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a===b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/designMode/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><strong>适配器模式</strong></h5><p>适配器模式就相当于一个转换接口，大家想想我们手机充电器通常是二岔口的，但是电源只有三岔口的。这时候就需要一个适配器把三岔口的转换成二岔口的。</p>
<p>它的作用其实就是解决两个软件实体间的接口不兼容问题，使用之后就可以一起工作了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/designMode/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'googleMap show!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'baiduMap show!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        map.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">renderMap(googleMap);</span><br><span class="line">renderMap(baiduMap);</span><br></pre></td></tr></table></figure>

<p>上面这段程序能够运行是因为百度地图和谷歌地图用的同一种show方法，但是我们在不知道对方使用的函数接口的时候，我们就不能这样用了（可能百度是使用了display方法来显示）。下面的baiduMapAdapter就是我们使用的适配器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'googleMap show!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">    display: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'baiduMap show!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        map.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baiduMapAdapter = &#123;</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baiduMap.display()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">renderMap(googleMap);</span><br><span class="line">renderMap(baiduMapAdapter);</span><br></pre></td></tr></table></figure>



<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><strong>代理模式</strong></h5><p>我们在事件代理的时候其实就是使用了代理模式，通过把监听事件全部交由父节点进行监听，这样你添加节点或者删除节点的时候就不用去改变监听的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;ul&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let ul &#x3D; document.querySelector(&#39;#ul&#39;)</span><br><span class="line">    ul.addEventListener(&#39;click&#39;, (event) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(event.target);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a><strong>发布-订阅模式</strong></h5><p>这种模式在生活中随处可见，比如你订阅了一个网课，开始前10分钟就会提醒你去听课。这里其实就是发布-订阅的模式，你订阅了它的开课信息，但是你不会接收到另一门的开课信息，因为你没有订阅。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"You click me!"</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'wheel'</span>, () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Your wheel!"</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>第一个是监听点击事件，而另一个是监听滚轮事件，会打印出来不一样的内容。</p>
<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><strong>策略模式</strong></h5><p>根据情况进行不一样的方案，比如你想去旅游，明确自己有多少钱然后选择旅游方式。</p>
<ul>
<li>没钱，走路</li>
<li>有钱，飞机</li>
<li>还行，火车</li>
</ul>
<p>这里就涉及到策略的模式了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line">    <span class="string">"rich"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"You can go with plane!"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"poor"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"OH, You can go with your feet!"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"middle"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"You can go with train!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> howShouldGo = <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strategies[money]();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(howShouldGo(<span class="string">"rich"</span>));</span><br></pre></td></tr></table></figure>



<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><strong>迭代器模式</strong></h5><p>迭代器模式是指提供一种按顺序访问的方法。比如说我们经常使用的forEach方法，就是通过顺序访问的模式。我们可以自己去写一下forEach的方法。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/designMode/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myForEach = <span class="function"><span class="keyword">function</span> (<span class="params">arr, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        callback.call(arr[i], i, arr[i]) <span class="comment">//把元素以及下标传递出去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;f</span><br><span class="line"></span><br><span class="line">myForEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span> (<span class="params">item, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([item, n]);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[ 0, 1 ]</span></span><br><span class="line"><span class="comment">//[ 1, 2 ]</span></span><br><span class="line"><span class="comment">//[ 2, 3 ]</span></span><br></pre></td></tr></table></figure>



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>其实设计模式我们用的地方也是有的，只是我们没有注意而已。上面我们说了都是常见的设计模式，还有很多我们没有印象的比如命令模式，享元模式，组合模式，中介模式等等。</p>
<p>如果有兴趣的同学可以去看一下JavaScript设计模式这本书，里面说的都是比较详细的。我大概读了一遍，上面的一些例子也是书本当中的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/designMode/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊程序员如何高效学习与工作</title>
    <url>/2020/03/17/liveYourLife/</url>
    <content><![CDATA[<h2 id="聊聊程序员如何高效学习与工作"><a href="#聊聊程序员如何高效学习与工作" class="headerlink" title="聊聊程序员如何高效学习与工作"></a>聊聊程序员如何高效学习与工作</h2><blockquote>
<p>“不知道大家有没有这样一种想法，今天的人没有完成，但是却安慰自己明天要特早期的想法？”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/liveYourLife/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>今天来和大家聊一下，程序员如何高效安排自己的工作时间，做到学习、生活与工作之间的平衡。其实今天说的无非就是时间的安排问题，在有效安排工作的情况下，你会比别人多出很多的时间。当然，我自己也没有严格执行自己的时间安排，准确来说只是一个大概的安排。</p>
<p>有时候我们明明做好了一天的安排，深圳小本本上面都写着每一条的待办事项，准备大干一场的时候，突然会有一些不可避免的事情要做，这就打乱了你的生活或者学习计划，难免会有些许抱怨。但还是乖乖去做一些其他的优先级比较高的事情。但是我们知道，良好的习惯并不是一天就可以形成的。所以当你准备形成习惯却被打乱就会觉得生活好难，但是一个有长期习惯的人并不会因为偶然的事情改变他，他依然可以安排好所有的事情。</p>
<h2 id="02-早起会上瘾吗"><a href="#02-早起会上瘾吗" class="headerlink" title="02 早起会上瘾吗"></a>02 早起会上瘾吗</h2><hr>
<p>我们可能无法理解一些人老是说早期的好处，因为我们形成了长期的晚睡晚起的习惯，生物钟是相对固定的，难以改变。你如果硬是叫你同学明天一定要早起学习，他一定会混混欲睡，因为他是没有形成长期的习惯，所以他是无法体会到你口中所说的早起到底好在哪。</p>
<p>不知道鸡汤喝多了还是自己决心想改变一下自己的生活方式，我尝试去养成早起的习惯。不是因为别人的强力鸡汤，而是觉得自己早上的思维其实是很活跃的，相对于下午进入正式的高强度工作，以及晚上的劳累状态。我曾经看过很多文章都说早上适合学习，适合阅读与吸收的时间，其实这也取决于每个人的习惯吧，你怎么知道别人早上是不是喜欢做脑力强度比较大的工作而且效率也挺高呢？</p>
<p>这其实是靠自己的摸索，找出自己的学习习惯。上面说的都是大众的看法，并不是所有人都合适。如果不是自己亲身的经历，我们是不会领会到别人口中说的早起到底好在哪。推荐大家试一下早期，真的是会上瘾的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/liveYourLife/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="03-时间就是金钱吗"><a href="#03-时间就是金钱吗" class="headerlink" title="03 时间就是金钱吗"></a>03 时间就是金钱吗</h2><hr>
<p>今天探讨的是关于程序员的时间观念，对于我们来说，时间永远是不够的，而且时间在我们眼中就是稀缺的资源。为什么我们很少按部就班的工作和生活呢？因为时间不允许，有时候可能一个项目在几天之内就要上线完成，时间是很紧迫的。所以我们要想和一些高校工作人士一样，除了工作之余还接几个外包来玩一下，还可以发展自己的副业等，必须要有自己的一套时间管理法则。</p>
<p>当然我们不能直接把别人的时间管理方案搬过来就用，每个人的时间都是一样的，但又是“不一样的”。就像实践是检验真理的唯一标准一样，我们的时间管理方案也是需要实践的，有技巧有方法的，需要在不断地实践中优化自己的方案。</p>
<p>那我们应该如何有效地管理自己的时间呢？</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/liveYourLife/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<ul>
<li>作息习惯</li>
</ul>
<p>研究表明我们不能少于7个小时的睡眠时间，这是专家建议我们这么做的。当然，我们是不可能这么干的，游戏不好玩？还是抖音不好看？不得不说，现在的电子设备已经占据了我们大部分的时间，有时候甚至要把我们的睡觉时间也吞掉。</p>
<p>所以说我们的时间管理第一步是早睡早起。确实对于一些人来说是很困难的，因为他开始肯定放不下手机里的游戏，电脑里面的美剧，还有睡觉前的奶茶。要想突破这一步，必须要狠下决心，每天早一小时睡觉，明天就早一小时起床。或者我们也可以把事情想的容易一点，每天早一分钟睡觉，明天早一分钟起床，这不过分吧？</p>
<ul>
<li>工作安排</li>
</ul>
<p>有同学可以毅力比较好，在某个早晨挣扎着起来了，很开心，离自己的目标又近了一步。但是突然一阵空虚无助的感觉出现了，我这么早起床是为了干嘛呢？是吃早餐还是为了学习阅读？还是为了工作？</p>
<p>所以这里的第二步就是有自己的安排的任务，不用写的很详细，大概花10分钟写一下今天的任务是什么就好。其实有些事情是每天都必做的，像一天总结一样，不会一天过去自己啥也没留下。所以我们花10分钟写一下今天的todolist是很有必要的。有了任务的安排，不会至于自己起床满脸迷茫，这样你就会躲进被窝里继续睡了。</p>
<p>有人可能会说，自己的任务堆着都做不过来，我哪有时间写计划呀？你先别急，你可以把任务进行分类，我们都知道任务是做不完的，每天都有新的任务，自己每天都有选择性地做，所以这里的选择就显得很有作用了。</p>
<p>大家还记得管理学中提到过的SWOT分析吗？其实我们当初学的时候，印象深刻就是这个了，我们这里参考就是类似这种分析法则。我们把任务分成紧急和不紧急，重要与不重要的分类标准。那么我们一天的任务安排自然就出来了，按照优先级最大的开始做起，一切都显得井然有序。</p>
<blockquote>
<p>紧急且重要&gt;紧急但不重要&gt;不紧急但重要&gt;不紧急且不重要</p>
</blockquote>
<ul>
<li>状态管理</li>
</ul>
<p>这里所说的状态管理是管理自己的学习或者工作状态。对于我们来说，当我们很专心做一件事情的时候是不允许别人打断的，你想想假如自己想到了一个非常完美的解决方案，但是突然别人叫你过去查bug，你一定会脸上笑嘻嘻，心里xxx。</p>
<p>我们在时间管理的时候一定要注意分清楚场合，比如你想写代码的，就允许自己有更长的时间用来思考，保证自己的思路不会被别人打断，这样你的工作思维也得到连续，进展也会顺利很多，随之而来的就是效率的提高。但是假如你是阅读或者学习的状态，就可以参考番茄工作法，学习25分钟然后休息5分钟，如此循环重复。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/liveYourLife/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<ul>
<li>学会总结</li>
</ul>
<p>总结也是一个非常重要的步骤，我们要形成自己的学习仓库，学到的知识要进行归类，建立自己的知识体系。我们还要建立自己的思维路线，比如说我们要总结自己写的项目出现问题一般是由什么地方引起的。可以把遇到的知识点，错误点都进行总结，就好像我们高三需要我们做错题本一样的道理。</p>
<p>之前我就有一篇文章说过关于主动学习与被动学习的区别。这里我们学会了总结就相当于我们从被动学习开始逐步向主动学习过渡，自己对知识的掌握程度也是比较高的。</p>
<p>另外我们形成总结的习惯有利于我们资料的查找，以前我们遇到什么问题就先去搜索，搜索完了之后就没有然后了。根据二八法则，我们生活中遇到的80%的困难其实都可以使用常用的20%方法来解决，所以我们形成自己方法库，很容易就可以解决生活的问题。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>好了，今天我们就聊到这里吧。我们可以先养成早起的习惯，接下来的时间管理就是好好运用早期的时间，我们做什么事情都能事半功倍的效果。我们对于时间管理的认识主要有，作息习惯，工作安排，状态管理和学会总结。大家要是做到以上的几点，自然就会对自己满意，也对自己的学习工作满意，更重要的是提升自己。</p>
<p>希望大家都可以对早起上瘾！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/liveYourLife/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
  </entry>
  <entry>
    <title>前端人应该有的工具箱</title>
    <url>/2020/03/17/frontKit/</url>
    <content><![CDATA[<h2 id="前端人应该有的工具箱"><a href="#前端人应该有的工具箱" class="headerlink" title="前端人应该有的工具箱"></a>前端人应该有的工具箱</h2><blockquote>
<p> 曾经看到一句话，说一个伟大的黑客不是因为技术有多强，而是他有多少厉害的工具。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/17/frontKit/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>早在几年前，我们或许还没有接触前端的方向，甚至不知道计算机方向学的是什么。记得计算机组成原理老师说过，计算机的学生是肯定会修计算机的。其实我不知道是不是因为学科名字的概念，一时竟无言以对，因为大学教会我们的知识中，是没有计算机维修这一门课的。</p>
<p>所以在校期间我们唯一能做的就是上课努力听讲，紧跟老师的脚步，认真完成课后作业或者检查的时候一通猛抄，应对了事。本科教育本来就是一个以素质教育为主，以培养学生的计算机基础为导向，并不是教会你要学习哪一种技术来应对将来的工作。举个简单的例子，大部分的大学是没有开设前端程序设计的课程，但是你看一下外面招聘很多都有招人，但是却招不到。</p>
<p>说到这里好像有点偏题了，回归题目本身。我们在学习前端的过程中，肯定会积累自己的一个技术集，也就是你认为好用的有哪些技术。一开始我们接触的信息可能会比较局限，但是感谢互联网平台让我们相遇。所以我接下来会分享一下我在学习的过程中收集的技术。</p>
<h2 id="02-学习网站"><a href="#02-学习网站" class="headerlink" title="02 学习网站"></a>02 学习网站</h2><hr>
<p>可能一开始大家都是看一些比较零星的知识点，没有一个系统的知识来学习。我们可以细想一下假如你要学习一门新的技术，第一时间肯定是谷歌一下这门技术是什么，然后你再搜索一下入门。到此为止你已经入门了，剩下的就是时间的关系了。所以我们很难想象之前没有互联网的时候是怎么学习的。可以看一下的有：</p>
<ul>
<li>慕课网</li>
<li>菜鸟教程</li>
<li></li>
</ul>
<p>这里我学习前端的时候，经常逛的一个网站就是慕课网，上面的视频可以让我们轻松一门一个知识点，但不是全部。而且很多系统的知识都是要收费的，所以我们可以选择看一些简单的、免费的入门视频。</p>
<p>暂无头绪，未完。。。</p>
]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具箱</tag>
        <tag>学习方向</tag>
        <tag>敏捷开发</tag>
        <tag>业务开发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何从零开始学习前端技术</title>
    <url>/2020/03/16/howToLearnFrontEnd/</url>
    <content><![CDATA[<h2 id="如何从零开始学习前端技术"><a href="#如何从零开始学习前端技术" class="headerlink" title="如何从零开始学习前端技术"></a>如何从零开始学习前端技术</h2><blockquote>
<p>没有一种技术是学不会的，10小时可以入门一门新技术，10000小时可以成为一个领域的专家。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>互联网在当今的世界显得异常火爆，每一个人都尝试挤破头脑去学习、去进入这一行业。作为一个前端从零开始学习的过来人，下面我的会详细说一下当初是怎么过来的，希望大家都会从我的这一段经历找到自己的出发点。如果大家对前端是没有一点概念的话，其实这只是一个方向的技术。比如我们看到华丽的网站，打开的一个微信小程序，还有打开的APP，其实都是前端方向的内容。</p>
<p>这时候大家有可能会问了，这么多的技术我们都要去学会吗？其实不然，现在基本上你能够掌握其中的一种技术，你就可以找到一份很好的工作，把每一项的技术都精通的人其实是很少的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-爬坡阶段"><a href="#02-爬坡阶段" class="headerlink" title="02 爬坡阶段"></a>02 爬坡阶段</h2><hr>
<h5 id="青铜阶段"><a href="#青铜阶段" class="headerlink" title="青铜阶段"></a><strong>青铜阶段</strong></h5><p>我们从最基本的前端基础知识开始讲起，这里也是我们最初的出发点。在这个过程当中呢，你会觉得前端的世界是那么的小，做什么事情都是的得心应手的，一度沉浸在自己的世界里不能自拔。你自己想走出去，但是又害怕外面的世界，所以你可能会在这里徘徊一段时间，等你觉得自己可以有信心打怪升级的时候自然会攀越过去。</p>
<p>我自己也是从html和css这两个基本的知识出发，经过编写一些静态的网页能在本地打开运行，能够看到自己的成果。其实这个过程我甚至不知道网页需要部署在服务器上面，也不知道那些所谓的动画和交互是什么出现的。总之你不会太过关注自己的不懂得知识，反而会默默欣赏自己的作品。</p>
<p>其实在这个阶段你也可以找一些网页模板看一下，主要就是学习一些结构方面的知识。也就是说你要知道在哪里放div，在哪里写p或者h1标签，就可以了。结构搭建好了之后你就可以关注一下css这些属性有什么用，到底这一块的红色是哪里来的，这里的蓝色背景哪里设置的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/5.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>这里可以推荐大家去看：</p>
<ul>
<li>菜鸟教程</li>
<li>w3c school</li>
<li>拿别人的页面研究（静态）</li>
</ul>
<h5 id="白银阶段"><a href="#白银阶段" class="headerlink" title="白银阶段"></a><strong>白银阶段</strong></h5><p>在前一个阶段里面，你已经学会了如何去制作一个简单/复杂的静态网页，但是都是一些写死的内容。所以在这个阶段里面你就大可以学习动画的制作，有了JavaScript这门脚本语言，简直就是如虎添翼。我在个阶段的时候，很关心页面是怎么动起来的，只是用到一个定时器的函数，仅此而已。</p>
<p>假如现在，大家一定不会去写这些函数来使页面动起来，有很多现成的组件或者框架等。可能前两年大家不是很关心这些东西，但是现在各种框架层出不穷，我们已经不会去关心底层的原理实现了，只关心开箱即用。</p>
<p>这里推荐大家去看：</p>
<ul>
<li>JavaScript入门经典（书）</li>
<li>JavaScript高级程序设计（第三版）（这本书是有难度的，适合各个阶段的人学习）</li>
</ul>
<h5 id="黄金阶段"><a href="#黄金阶段" class="headerlink" title="黄金阶段"></a><strong>黄金阶段</strong></h5><p>当你掌握了前端的”三件套“，我们就应该可以做点东西出来了，是时候检验自己的学习成果的时候了。但是你先别急，在这个阶段里面有很多可以让你头疼的东西，根本的原因是——你前面两个阶段没有学好。</p>
<p>没错，在这个阶段里面，你主要的任务就是去选择一门比较热门的框架来学习，然后了解这一门框架的周边生态，上手的难度如何，还有是否迎合当前的公司环境。其实现在看来你大可放心去学习vue/react/angular这三大框架，因为很多大公司都基本会使用这些技术。而且基本上都要你掌握其中一门技术。</p>
<p>这里大家可以选择上手难度比较小的vue框架，这个框架一直在维护，现在已经准备要发布3.0版本了，大家又要准备好好去学习了。除此，vue的周边生态非常好，全球都有人使用，官网的文档丰富全面，你可以在上面找到你想要的知识。也正是由于这个原因，基于vue的框架也出了很多，都是支持vue的语法的。比较好的有uniapp，可以变成多种终端，它的目标就是打造多端统一的框架。</p>
<p>你可以使用vue的模板轻松配置出好看的、可以使用的后台管理系统模板以及一些webapp。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/6.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>这里推荐大家去看：</p>
<ul>
<li>框架的官网</li>
<li>vue.js实战（书）</li>
<li>深入浅出vue.js（书）</li>
<li>github关于vue的项目</li>
</ul>
<h5 id="钻石阶段"><a href="#钻石阶段" class="headerlink" title="钻石阶段"></a><strong>钻石阶段</strong></h5><p>当年很庆幸自己已经熬过去了，你以为人生终于走上了巅峰。但是你错了，你的前端人生才刚刚开始，前面所做的各种事情只不过是为了现在能够正式开始而已。这也是为什么很多小伙伴都会觉得前端的水很深，以至于后面越学越怀疑人生，不懂为什么要这样对自己，直接告诉我前端水深就好了不行吗？但是我想说的是，既然路是自己选的，那么就开心地走下去，你会感激的。</p>
<p>在经过前面的阶段后，你已经可以找到一份可以实习的工作了。你可以自己去锻炼一下你之前所学的内容，看是否与自己所学的有出入。但是如果你是去到一个小公司实习，里面的东西也可能不是你自己学的，因为每一个公司都有自己内部的框架，你有可能需要重新学习。所以去之前一定要了解一下公司用的技术栈是什么？</p>
<p>这个阶段一般你要学习前端打包工具，比如webpack的使用，以及前端工程化的内容，代码合并、代码分割、单元测试、性能优化、自动构建、部署上线等内容。这里面也是有很大的学问，思想不是一时能够学会的，必须经过很长一段时间的积累才可以有所领悟。而且这些东西理论学习的作用是不大的，必须亲自体验才会领悟精髓。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/4.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>这里推荐大家去看：</p>
<ul>
<li>深入浅出webpack（书）</li>
<li>前段工程化（书）</li>
</ul>
<hr>
<p>这里小结一下：</p>
<p>能够到达这个阶段是很不容易的，起码要半年左右一直在学习实践，这也是为什么很多的培训机构都会有4~6个月的培训期，但是我可以告诉你们的是培训教会你的只是业务的知识，教你怎么去开发页面而已。如果你想自己学习一定要学习它的理论原理知识，这才是有用的，也是你通过面试的关键部分。总的来说，就好像这下面的图一样，你以为终于出头了，但是仅仅是开始……</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<hr>
<h5 id="王者阶段"><a href="#王者阶段" class="headerlink" title="王者阶段"></a><strong>王者阶段</strong></h5><p>一般来说，当你到达这个阶段的时候，人生就可以熬出头了，如无意外你将可以独立带领一个小团队开发产品，负责某一个生产线的项目，也就是leader级别的人物了，而且很多面试都是你来负责的。</p>
<p>但是这个阶段只有很少一部分人可以到达，有人可能到了上一个阶段就放弃了转而继承家产也不一定。由于没有到达这个阶段，我也不知道该怎么去说，也不知道推荐什么。当我有能力的时候，在来与大家详谈吧，话题保留。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-面试基础"><a href="#03-面试基础" class="headerlink" title="03 面试基础"></a>03 面试基础</h2><hr>
<p>这一部分也是一直贯穿在整个学习的过程当中的，因为你最终还是要进入一家公司工作。但是你要明白只有通过面试才能进去，否则即使你有很强的技术，但是你没有通过面试也是白忙活而已。</p>
<p>这里建议大家一定要多关注一些计算机的基础知识，这些一般在第一轮面试中问的比较多，也是比较基础的。但是我发现很多同学都对这一部分不关注，认为没有必要，将来也不会用到这些很偏的知识。简单一点的就会问你线程与进程的区别，这些就是计算机基础，简单吗？简单。难吗？确实是挺难的。</p>
<p>每一个公司考核的偏重点是不一样的，比如字节跳动比较偏算法方面的知识，每一轮的面试都会叫你手写算法，这样的面试对于不会算法的同学就是找虐的过程。但是比如腾讯公司，他有可能会偏重一部分的知识，比如计算机网络。</p>
<p>无论怎么样，想要通过面试最好的方法就是多看师兄师姐的面经，然后总结一套题库，这样面试自然就不会慌了。但是你要理解里面的原理，还有能够举一反三，靠背答案是不能通过面试的。</p>
<p>这里推荐大家：</p>
<ul>
<li>剑指offer（书）（）面向算法/刷题</li>
<li>图解http（书）</li>
<li>图解tcp/ip（书）</li>
<li>牛客网（看面经）</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/16/howToLearnFrontEnd/7.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>具体比较深入的知识我就不细说了，上面只是前端学习比较大体的方向，而且这也是我本人的学习方向，并不代表前端就应该是这样子的过程。但是一般来说大部分同学都会经历这样的一个过程，学习总归是有一个步骤的，很多事情并不是一蹴而就的，相信大家可以根据自己的自身情况，打造出属于自己的学习路线。</p>
<p>能够有自律的习惯就不要去报名培训机构，能够有钱的情况下多买几本书，现在的投资是对未来的负责。       </p>
<p><img src="/2020/03/16/howToLearnFrontEnd/2.gif" alt=" ">                                                                                                   </p>
]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>前端</tag>
        <tag>学习方法</tag>
        <tag>路线</tag>
        <tag>坚持</tag>
        <tag>随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS与ARP的关系与原理解析</title>
    <url>/2020/03/15/dnsAndArp/</url>
    <content><![CDATA[<h2 id="DNS与ARP的关系与原理解析"><a href="#DNS与ARP的关系与原理解析" class="headerlink" title="DNS与ARP的关系与原理解析"></a>DNS与ARP的关系与原理解析</h2><blockquote>
<p>“计算机之间进行通信的只靠IP地址不能完成吗？”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/15/dnsAndArp/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>我们在上网查询某一个网站的时候，比如谷歌搜索，一般都是输入www .google.com进行查询，但是实际上我们是需要得到它的IP地址才可以与主机进行连接的。这个过程就得益于DNS域名解析了，通过域名与IP地址的一个对应关系就可以得到目标的IP地址，从而进行通信。但是有了IP地址还不行，还需要一个MAC地址才可以完成通信，而要得到MAC地址也得益于ARP地址解析协议，整个过程都是大家的相互合作，接下来就说一下中间到底是怎么工作的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/15/dnsAndArp/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-什么是DNS"><a href="#02-什么是DNS" class="headerlink" title="02 什么是DNS"></a>02 什么是DNS</h2><hr>
<p>通常我们记住一个网站不会去记他的IP地址，因为那样太难记忆了。DNS就是域名解析系统，里面有一个主机名与IP地址的相对应的数据库。它的的作用就是把域名转成IP地址，IP地址是网络上唯一确定的主机名，用以主机的识别。那么它是怎么去解析我们的IP地址的呢？总的来说他有可能经历以下的步骤：</p>
<ul>
<li>查找浏览器时候缓存了IP地址</li>
<li>查找操作系统是否缓存了IP地址</li>
<li>查找路由器是否缓存了IP地址</li>
<li>查找服务运营商时候缓存IP地址</li>
<li>查找跟域名服务器对应IP地址</li>
</ul>
<p>因为网络资源比较宝贵，要是中途没有通过一下缓存的手段，可能会造成网络的阻塞或者网络承受不起中间的庞大请求，所以就必须缓存下来。但是也不是一直都有缓存，过了一定的时间就会消失记录，重新请求然后缓存。</p>
<p>如果浏览器和路由器都没有，一般服务运营商就是中国电信或者中国移动，查找是否缓存了IP地址，如果最后还是没有，就只能去根域名服务器查找了，这一次就一定可以找的到。当IP地址返回的时候，中间的过程会被浏览器，操作系统，运营商等缓存下来，那么下次再进行查找的时候就不会绕这么远的路了。</p>
<p><img src="/2020/03/15/dnsAndArp/2.png" alt></p>
<h2 id="03-什么是域名"><a href="#03-什么是域名" class="headerlink" title="03 什么是域名"></a>03 什么是域名</h2><hr>
<blockquote>
<p>域名指的是为了识别主机名称和组织机构名称的一种具有分层结构的名称。——图解TCP/IP</p>
</blockquote>
<p>域名是有分层结构的，比如有一些域名的后缀是.com/.cn/.org等，都代表了不同的组织机构，也便于域名的管理。域名的分层有点类似于倒挂的树形结构，最顶级就代表了根域名，下面就是二级域名、三级域名等。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/15/dnsAndArp/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>图片来源于网络（侵删）</p>
<p>通过上面这张图可以清楚地看到，顶级域名有一个国家顶级域名，比如中国的是以.cn结尾，英国就以.uk结尾。下面我们可以看到一些教育网站都会以.edu结尾的，大学官网都会以这些结尾。</p>
<h2 id="04-什么是ARP"><a href="#04-什么是ARP" class="headerlink" title="04 什么是ARP"></a>04 什么是ARP</h2><hr>
<p>ARP是地址解析协议，上面我们知道，通过DNS域名系统可以找到对应主机的IP地址，但是有了IP地址还不够，因为在底层的数据链路层在进行实际通信的时候会找每一个IP地址对应的MAC地址。而从IP地址到MAC地址的时候就要依靠ARP协议。</p>
<h5 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a><strong>工作机制</strong></h5><p>我们可以以主机A向主机B发送数据为例子，看一下中间的过程是怎么工作的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/15/dnsAndArp/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>主机A为了获取主机B的MAC地址，会先在当前的数据链路上广播发送一个ARP请求包，里面包含目标IP地址。因为在同一个链路上面的主机都会接收到这个请求包，然后每一个主机就会根据IP地址与自己的IP地址相比较，如果与自己的匹配就会接收这个请求包，然后发送响应包，里面就包含自己的MAC地址。</p>
<p>初此之外，ARP请求包里面也含有主机A的MAC地址。当获取了B的MAC地址后也会缓存一下，防止下一次的请求又要发送请求包，节省流量。这样的MAC地址与IP地址相对应的表就是ARP表，MAC地址缓存也是有一定的时间的，超过时间之后就会吧内容清除，然后重新请求。</p>
<h5 id="IP地址与MAC地址的关系"><a href="#IP地址与MAC地址的关系" class="headerlink" title="IP地址与MAC地址的关系"></a><strong>IP地址与MAC地址的关系</strong></h5><p>其实有一段时间我也一直不太明白为什么有了IP后还要MAC来通信呢？这不是多此一举吗？</p>
<p>首先我们要明白一个很重要的区别，IP地址是会变的，一旦你关机重启之后IP就可能会不一样了，但是MAC地址就不一样，永远都是一样的不会改变。相当于我们的身份证号码一样，但是你搬家之后的住址就可能会改变了。</p>
<p>网络通信很大一部分都是不在同一个网络上的，所以数据会经过很多路由器才可以找到你的主机。比如我们网购东西写的地址就是IP地址，快递的分发机制我们都知道，通过省/市/区一层层分发下来，最终就会找到你的位置。但是除了这个位置还不行，你要知道你的名字是啥才会准确分到你的手上，这就是MAC地址的作用。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/15/dnsAndArp/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a><strong>RARP</strong></h5><p>这个其实就是与ARP相反，作用是把MAC地址对应的IP地址找出来。那么这种协议有什么用呢？我们知道DHCP的作用就是动态分配一个IP地址给当前的主机，通过电脑我们可以自己设置，如果不设置就是由DHCP来给你分配一个IP地址。比如我们打印机联网的时候就会用到这个协议，当我们插上电源的时候，就会发送一条“我的MAC地址是xxx，我对应的IP地址是啥？”的请求信息。</p>
<p>那么对应的RARP服务器就会在上面注册你的MAC地址然后分配一个IP地址给你。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/15/dnsAndArp/6.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>通过上面的解析，我们知道了DNS域名解析系统与IP地址的关系，通过IP地址我们可以利用ARP地址解析协议找到MAC地址。通过IP地址与MAC地址的配合我们就会准确地与目标主机进行通信。这里我们知道ARP就是一个广播的功能，广播的话我们就会用到UDP协议（TCP不支持广播）了，其实各种协议之间也是有一定的联系的。</p>
<p>我们也知道域名之间的层级结构，由顶级域名统一分配，有一定的管理结构，而且域名我们也一般不能随便申请，比如个人就不能申请教育类或者政府类的域名。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/15/dnsAndArp/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>ARP</tag>
        <tag>域名</tag>
        <tag>MAC地址</tag>
        <tag>IP地址</tag>
      </tags>
  </entry>
  <entry>
    <title>产品的思维与技术的思维差异</title>
    <url>/2020/03/14/proManagerMind/</url>
    <content><![CDATA[<h2 id="产品的思维与技术的思维差异"><a href="#产品的思维与技术的思维差异" class="headerlink" title="产品的思维与技术的思维差异"></a><strong>产品的思维与技术的思维差异</strong></h2><blockquote>
<p><strong>“</strong> 同样是为了一个需求服务，产品的思维是怎么想的<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/14/proManagerMind/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>从零开始设计一款全新的产品，其实前期的工作基本上是不用程序员的操心，工作开始由产品经理与客户进行初步的沟通和设计。这里所说的产品经理其实就是一个名称，并非是真正的经理职位。通常来说是由甲方提出初步的需求，然后由产品经理初步设计产品图，如果严谨的话一般会与客户进行再一步的沟通以确定第一版版本。</p>
<p>其实无论是哪一步的动作，沟通就是一个很关键的技能点，通过有效的沟通，能够让双方都在一个可接受的范围内进行产品的设计，才是真正可以让产品顺利落地的方式。产品经理其实是一个设计业务方非常多的一个职位，并非只是我们想象中的只和程序员和甲方打交道，而且你的技能除了沟通高效之外，会一点技术也是非常有必要的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/14/proManagerMind/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-产品思维"><a href="#02-产品思维" class="headerlink" title="02 产品思维"></a>02 产品思维</h2><hr>
<p>我们可能经常会看到产品与研发打架的事情，其实这本可以有效的解决，但是可能是出于某些原因使得出现了无效沟通。接下来我来谈一下为什么会这样。</p>
<p>首先产品经理的出发点就是实现甲方的需求方案，而且会在项目的生命周期之内一直跟踪客户的需求，其实我们可以理解为产品监控方。其实咋一看，这和程序员的出发点也大同小异呀，也不至于打架吧。虽然是一样的，但是产品的出发点是基于产品思维的，那么什么是产品思维呢？总的来说它可以从以下的三点出发：</p>
<ul>
<li>用户价值</li>
<li>使用场景</li>
<li>商业价值</li>
</ul>
<p>首先是用户价值，通俗一点来说就是这款产品研发出来，对用户有哪些有用的地方。也就是产品可以有效地解决用户的痛点所在，如果可以解决用户的痛点，那么你的产品自然是有人使用的，当然还要通过后期的运营与推广的层面。拿我们伟大的产品微信举一下例子，首先微信解决用户的痛点非常之多，比如免费实时聊天、微信转账、娱乐（朋友圈）。这些都是很伟大的想法，你想要是没有了聊天的功能，大家可能会通过发短信/打电话的形式来沟通，而且不方便也不高效。所以当我们解决了用户痛点的时候，自然会有人使用你的产品，你的用户价值自然就实现了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/14/proManagerMind/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>使用场景指的就是这一款产品适合在哪些场景下使用，比如小程序游戏，可以让人们在闲暇的时间或者无聊的时候来消遣，满足人们的日常需求。比如在疫情期间推出的穗康小程序，满足人们预约口罩和上报健康信息，满足特定场景下的使用。所以一款产品的诞生要结合使用场景的方面，定向研发。</p>
<p>商业价值，很多人都可能会认为上面提到的用户价值跟商业价值一样，其实不然。首先用户价值是用户寻找的一种满足自己需要的价值，包括用户的预期需求、质量需求、价格需求等相关的因素。假如有一方面的因素不满足用户的期望，那么你这款产品的用户价值可能会降低，因而导致商业价值也降低。</p>
<p>举个例子来说，早期我们都会使用百度搜索引擎，但是由于它搜索引擎的内容大部分不是我们想要的，以广告居多。所以这里就突出第一个问题就是用户价值缺失，只关注于商业价值大于用户价值。所以我们可能会寻找另外一种替代方案，如必应和谷歌。我们以常识来说，一般用户数量达到一定的时候，产品就会考虑实现它的商业价值，比如投放广告等涉及到商业利益的。首先百度就是一个很典型的例子，再而现在微信朋友圈也开始投放广告了，这也是一种商业价值实现的方式。但是鉴于现在大众可能找不到一种比微信更好的替代方案，所以基本上没有什么影响。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/14/proManagerMind/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-技术思维"><a href="#03-技术思维" class="headerlink" title="03 技术思维"></a>03 技术思维</h2><hr>
<p>与产品思维侧重感性的思维不一样，技术思维更重要的是关注产品本身的实现方式。简单一点来说就是产品偏重的是一个感性思维、商业价值以及用户体验等各方面的工作；而技术思维从技术的底层出发，关注产品的研发，也就是一种理性的思维来驱动的。</p>
<p>所以从程序员的角度来说，主要关注的有以下的几点：</p>
<ul>
<li>技术框架与原理</li>
<li>可行性分析</li>
<li>研发周期</li>
</ul>
<p>技术框架的选择一般是有软件的架构师来选择，通过权衡多方面的考虑，选用的工具也是看一下是否有缺陷或者社区反馈是否合理等因素。比如我们开发一个软件选用的技术大部分是用开源的框架/组件库，以减少我们业务的编写，选型的标准一般看一下这个框架是否能够实现我们的需求，遇到问题是否可以有技术支持（生态/社区是否完善）等。一般来说你一旦选型之后就不要更改了，选型是基础。就好比你建一栋大楼，地基已经打好了更改就难了，所以选型方面是经过讨论之后慎重决定的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/14/proManagerMind/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>产品会有一份需求分析设计书，里面包括了需要实现的预期功能，以及产品的交互功能等，我们需要进行评估时候可以实现。比如让你根据用户手机壳颜色改变主题的需求就不能实现了。程序员通过对每一项的需求进行全面评估，确定可行性之后就反馈给产品。</p>
<p>最后一个就是研发周期，加入产品的研发评估需要一个月的时间，你要一个星期就让我交货怎么行？除非钱到位。</p>
<p><strong>总结：</strong></p>
<p>经过上面的分析，我们知道虽然两者的出发点是一致的，但是思维方式确实不一样的，这就导致了我们交流可能会有一点吃力。产品经理感性评估方面比较多，而程序员则是理性分析，以一种严谨的态度去看待每一个问题和需求。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>上面我们介绍了产品思维与技术思维的差异，我们从宏观方面来看，产品的研发有前期，主要是产品经理与客户进行沟通设计，然后写出一份报告书；中期主要是由技术人员来操作，通过编码方式实现产品；而后期就是运营推广的阶段了，还有维护产品的方面。</p>
<p>了解大家的分工之后，我们就对整个过程有一个清晰的认识，假如出现问题也能够快速定位到底是哪个环节出了问题。总的来说产品思维与技术思维相辅相成，可以高质量地打造一款产品。</p>
<p><img src="/2020/03/14/proManagerMind/2.gif" alt></p>
]]></content>
      <categories>
        <category>产品经理路线</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
        <tag>思维差异</tag>
        <tag>技术实现</tag>
        <tag>用户价值</tag>
        <tag>产品价值</tag>
      </tags>
  </entry>
  <entry>
    <title>入门基于Node的Web框架——Koa</title>
    <url>/2020/03/13/koa-framework/</url>
    <content><![CDATA[<h2 id="入门基于Node的Web框架——Koa"><a href="#入门基于Node的Web框架——Koa" class="headerlink" title="入门基于Node的Web框架——Koa"></a>入门基于Node的Web框架——Koa</h2><blockquote>
<p>“Koa是基于Node.js的web框架，由Express原班人马打造，有健壮、轻量的特点”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/13/koa-framework/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>之前介绍过Node.js的特点就是基于事件还有回掉函数的，由于这个特点，Node适合于高密度IO的场景。传统的数据操作是直接在数据库上面进行数据的增删改查，是精确到数据源本身，这种情况有可能导致性能问题。因为当遇到高并发的场景，数据库可能查询不过来而且还有锁的存在来防止数据冲突。</p>
<p>但是Node是基于事件与回调函数的，Node可以对应用的操作以事件的队列形式，每一次事件都准确记录下来，依次执行。这种方法不会对数据的直接操作，也不会数据产生冲突。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/13/koa-framework/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-Koa介绍"><a href="#02-Koa介绍" class="headerlink" title="02 Koa介绍"></a>02 Koa介绍</h2><hr>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h5><p>首先我们在本地新建一个文件夹用来存放项目的代码。然后再文件夹里面新建app.js文件，这里我们简单地在app.js文件里面写上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa()</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"http service is running at port 3000"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">'&lt;h1&gt;Hello Koa!&lt;/h1&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后安装koa，只需要一句命令即可。在终端输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i koa</span><br></pre></td></tr></table></figure>

<p>我们在运行app.js文件之后，输出上面的那句话就证明我们成功创建了一个http服务器，当你打开localhost:3000你就会看到hello koa了。怎么样，是不是非常简单？</p>
<h5 id="context对象"><a href="#context对象" class="headerlink" title="context对象"></a><strong>context对象</strong></h5><p>大家可以看到上面app.use函数使用了一个ctx的参数，其实就是context对象，这个对象包含了request和response对象的封装。我们可以在控制台打印出来这两个对象到底是什么。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/13/koa-framework/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>可以看到包含了http请求头和响应头的相关信息。其实这是一个上下文的对象，我们在JavaScript中也知道有上下文的概念，就是一个环境。这里的上下文指的就是某次请求包含用户的环境是什么，包括你的状态、Token或者参数等等，来确定你当前所处的请求环境。</p>
<h6 id="request"><a href="#request" class="headerlink" title="request"></a><strong>request</strong></h6><p>我们再来看一下context里面的request对象有哪些属性，我们把上面的代码改一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa()</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"http service is running at port 3000"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx);</span><br><span class="line">    ctx.response.body = &#123;</span><br><span class="line">        url:ctx.request.url,</span><br><span class="line">        query:ctx.request.query,</span><br><span class="line">        querystring:ctx.request.querystring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后启动代码，在浏览器输入http ://localhost:3000/?search=koa&amp;keyword=context，你就会看到相关的属性和属性值。这样一来，我们就可以轻松获取请求参数和请求地址，在以后的接口编写会很有帮助。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"/?search=koa&amp;keyword=context"</span>,</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"search"</span>: <span class="string">"koa"</span>,</span><br><span class="line">        <span class="attr">"keyword"</span>: <span class="string">"context"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"querystring"</span>: <span class="string">"search=koa&amp;keyword=context"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="response"><a href="#response" class="headerlink" title="response"></a><strong>response</strong></h6><p>response对象是用于设置一些响应信息给客户端，这些和http请求的响应字段是一样的。比如说可以设置状态码、响应格式等相关信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    ctx.response.status=<span class="number">200</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.request.accepts(<span class="string">'json'</span>))&#123;</span><br><span class="line">        ctx.response.body=<span class="string">'&lt;h1&gt;Hello json&lt;/h1&gt;'</span></span><br><span class="line">        ctx.response.type = <span class="string">'json'</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ctx.request.accepts(<span class="string">'html'</span>))&#123;</span><br><span class="line">        ctx.response.type=<span class="string">'html'</span></span><br><span class="line">        ctx.response.body=<span class="string">'&lt;h1&gt;Hello html!&lt;/h1&gt;'</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ctx.response.type=<span class="string">'text'</span></span><br><span class="line">        ctx.response.body = <span class="string">'hello text!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h6 id="state"><a href="#state" class="headerlink" title="state"></a><strong>state</strong></h6><blockquote>
<p>The recommended namespace for passing information through middleware and to your frontend views.</p>
</blockquote>
<p>引用<a href="https://koajs.com/" target="_blank" rel="noopener">官网</a>的一句话，state是一个命名空间，用于通过中间件传递信息和前端视图。比如以下的代码可以把user放在state里面，传递给另一个中间件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.state.user = <span class="keyword">yield</span> User.find(id);</span><br></pre></td></tr></table></figure>



<h6 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a><strong>cookies</strong></h6><p>ctx.cookies用于获取和设置cookie。</p>
<ul>
<li><p>设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.cookies.set(name, value, [options])</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.cookies.get(name, [options])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中options就是一些cookie的相关属性，如设置过期时间、路径等。具体如下：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>maxAge</td>
<td>cookie过期时间</td>
</tr>
<tr>
<td>signed</td>
<td>cookie签名值</td>
</tr>
<tr>
<td>expires</td>
<td>过期日期</td>
</tr>
<tr>
<td>path</td>
<td>存储路径</td>
</tr>
<tr>
<td>domain</td>
<td>域名</td>
</tr>
<tr>
<td>secure</td>
<td>只允许https访问</td>
</tr>
<tr>
<td>httpOnly</td>
<td>如果是true，则js无法访问</td>
</tr>
<tr>
<td>overwrite</td>
<td>布尔值，是否允许覆盖以前的同名cookie</td>
</tr>
</tbody></table>
<h6 id="throw"><a href="#throw" class="headerlink" title="throw"></a><strong>throw</strong></h6><p>用于抛出错误，返回错误信息给用户。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">	ctx.throw(<span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="03-Koa中间件"><a href="#03-Koa中间件" class="headerlink" title="03 Koa中间件"></a>03 Koa中间件</h2><hr>
<p>中间件其实可以理解成一个执行函数，函数就是实现某一种功能的方法。可能这么说不太明白。举个例子：比如你购买商品，添加购物是要在登录状态的，下单也是要在登录状态的。这里每进行一次操作都应该判断一下用户是否是登录状态，我们可以把判断是否登录状态的函数抽离出来，形成一个中间件，可以在任何地方进行复用。</p>
<p>中间件有两个参数，第一个就是我们上面提到的ctx，还有一个就是next参数，下面就讲一下next参数到底是怎么用的，我们先来了解一下“洋葱模型”。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/13/koa-framework/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/new'</span>, loginCheck, otherMiddleWare, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = ctx.request.body</span><br><span class="line">    body.author = ctx.session.username</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> newBlog(body)</span><br><span class="line">    ctx.body = <span class="keyword">new</span> SuccessModel(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面这段代码的意思就是新建文章的接口，新建之前就使用了loginCheck（验证是否登录）的中间件，如果还有其他也可以写在otherMiddleWare这里。</p>
<p>所以next的作用就是把中间件的执行权交给下一个中间件，如果没有next的话，otherMiddleWare就不会执行。洋葱模型类似于一种栈的数据结构，遵循先进后出的原则。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/13/koa-framework/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>我们也可以一次性引入，把中间件都以函数的形式定义，然后使用koa-compose引入，效果一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">'koa-compose'</span>);<span class="comment">//增加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">middleWare1</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"first"</span>)</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"first end"</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">middleWare2</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"second"</span>)</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"second end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">middleWare3</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"third"</span>)</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"third end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> all = compose([middleWare1,middleWare2,middleWare3])</span><br><span class="line"></span><br><span class="line">app.use(all)</span><br></pre></td></tr></table></figure>



<h2 id="04-常用中间件"><a href="#04-常用中间件" class="headerlink" title="04 常用中间件"></a>04 常用中间件</h2><hr>
<h5 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a><strong>koa-bodyparser</strong></h5><p>koa-bodyparser这个中间件可以用于解析post方法传递过来的参数，常用于表单的提交信息获取，以一个JSON对象的形式返回，可以很方便地获取数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa()</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">        ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1&gt;登录&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;form method="POST" action="/"&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;用户名&lt;/p&gt;&lt;input name="username"&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;密码&lt;/p&gt;&lt;input name="password"&gt;</span></span><br><span class="line"><span class="string">        &lt;button type="submit"&gt;提交&lt;/button&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> postData = ctx.request.body</span><br><span class="line">        <span class="built_in">console</span>.log(postData); <span class="comment">//&#123; username: '123', password: '456' &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>



<h5 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a><strong>koa-router</strong></h5><p>上面介绍next的时候，代码里面有router的出现，这就是koa-router。使用这个方便获取你是使用哪一种方法，相应的逻辑也可以写在这个router里面。使用之前先安装，<code>npm i koa-router</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.get(&#39;&#x2F;&#39;,(ctx, next)&#x3D;&gt;&#123;</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.post(&#39;&#x2F;&#39;,(ctx, next)&#x3D;&gt;&#123;</span><br><span class="line">	&#x2F;&#x2F;获取json数据</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="koa-compose"><a href="#koa-compose" class="headerlink" title="koa-compose"></a><strong>koa-compose</strong></h5><p>上面我们已经介绍了，使用这个中间件可以把所有的中间件一次性引入，能够提高代码的可读性，中间件也可以单独写在一个js文件里面进行引入。这样就可以使页面更加简洁，耦合性更低，符合软件开发的要求。</p>
<h5 id="koa-jwt"><a href="#koa-jwt" class="headerlink" title="koa-jwt"></a><strong>koa-jwt</strong></h5><p>随着网站前后端分离方案的流行，越来越多的网站从Session Base转为使用Token Base，JWT(Json Web Tokens)作为一个开放的标准被很多网站采用，koa-jwt这个中间件使用JWT认证HTTP请求。</p>
<h5 id="koa-compress"><a href="#koa-compress" class="headerlink" title="koa-compress"></a><strong>koa-compress</strong></h5><p>当响应体比较大时，我们一般会启用类似Gzip的压缩技术减少传输内容，koa-compress提供了这样的功能，可根据需要进行灵活的配置。</p>
<h5 id="koa-logger"><a href="#koa-logger" class="headerlink" title="koa-logger"></a><strong>koa-logger</strong></h5><p>koa-logger提供了输出请求日志的功能，包括请求的url、状态码、响应时间、响应体大小等信息，对于调试和跟踪应用程序特别有帮助，koa-bunyan-logger提供了更丰富的功能。</p>
<h5 id="koa-session"><a href="#koa-session" class="headerlink" title="koa-session"></a><strong>koa-session</strong></h5><p>HTTP是无状态协议，为了保持用户状态，我们一般使用Session会话，koa-session提供了这样的功能，既支持将会话信息存储在本地Cookie，也支持存储在如Redis, MongoDB这样的外部存储设备。</p>
<h5 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a><strong>mysql</strong></h5><p>可以使用mysql中间件更方便地连接数据库，提供了很多数据库相关的操作方法，也可以手动进行配置。而且还有防止数据库注入的预防。</p>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>上面主要介绍了koa的用法以及常用的中间件的作用，koa是一个web框架，依靠强大的中间件可以很方便地实现一些Node.js应用。koa是基于Node的框架，大家学习之前应该先看一下Node的基本语法。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/13/koa-framework/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>Web框架</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Node</tag>
        <tag>JavaScript</tag>
        <tag>Koa</tag>
        <tag>web框架</tag>
      </tags>
  </entry>
  <entry>
    <title>大学四年，如何选择自己的技术栈</title>
    <url>/2020/03/12/chooseYourTech/</url>
    <content><![CDATA[<h2 id="大学四年，如何选择自己的技术栈"><a href="#大学四年，如何选择自己的技术栈" class="headerlink" title="大学四年，如何选择自己的技术栈"></a>大学四年，如何选择自己的技术栈</h2><blockquote>
<p><strong>“</strong> 无论什么样的学校，都会有同样的牛人<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/12/chooseYourTech/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>不知道大家知道程序员最重要的一个技能是什么呢？没错就是CV操作，复制粘贴。作为一个天天被产品压榨的卑微身份，不得不练成了这一本领（其实是与生俱来）。由于产品的更新速度太快了，开发难免会跟不上这个逆天的节奏，老板就只会说我只要结果不要过程，所以就找一些开箱即用的就美滋滋了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/12/chooseYourTech/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>但是不得不说近年来的前端技术发展十分快速，以至于让人觉得CV操作是大家都公认可行的方法，框架技术层出不穷，确实让前端的开发简单快速友好。虽说是简单好用，但是面试却很逆天，例如你知道这个东西是怎么做出来的吗？你知道它的原理是什么吗？         小白：……</p>
<p>所以针对这个问题，我们不得不从零开始看别人造轮子。因为只有这样，以后你来当面试官的时候你就可以翘着二郎腿问对面的小白（有可能是大佬）这里面的原理是啥？但是也有可能被对方碾压，另说。</p>
<h2 id="02-学习方法与技术选择"><a href="#02-学习方法与技术选择" class="headerlink" title="02 学习方法与技术选择"></a>02 学习方法与技术选择</h2><hr>
<p>学习方法与技术选择是基于你的方向来决定的，并不是一个大方向的概念。与其说大学四年怎么选择，不如说大三大四该如何选择你的方向，因为我感觉大部分的同学在学校的头两年是不会怎么学习的，刚从高考放出来你又让我进去？想得美。</p>
<p>所以从社团、学生会、协会等混的风生水起，俨然一个成功大佬的样子。但是我们也要时刻提醒自己，跟你一起玩的小伙伴可能是富二代而不用关心前途，但是你确实要充实自己而不要被大众的思想迷惑了自己。有自己的独立思想和独立思维，才是一个大学生应该有的样子。所以我们结合自身的优势，来决定自己将来适合哪一个方向的发展。</p>
<h5 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a><strong>学习方法</strong></h5><p>学习方法大家都是不一样的，从小白到大牛，中间可谓是困难重重。自身的学习方法不是摸索出来之后就一直适合自己，而是一直在改变。为什么这么说呢？我们从人生两个重要的阶段，大学与工作谈一下。首先大学是一个时间相对工作是比较充裕的，有属于你的自由度比较高的时间。除了上课时间之外，剩下的就全部由你自己来安排，说来愧疚，自己也没有很好地安排时间。现在才知道工作后你很大可能是没有你自己的个人时间。</p>
<p>大学时期可以根据自己的课表安排技术学习，所以这里就有你自己的学习方法和学习规律，也仅限于大学时期。然后工作过后你就只有下班的时间来学习，这就是很大的不同。而且说实在的话，你下班过后很可能也不学习了，这就是为什么大部分人都说程序员35岁都会有的中年危机。</p>
<p><img src="/2020/03/12/chooseYourTech/3.png" alt></p>
<p>摸索出来的学习方法还有一个重要的点就是要坚持。不得不说，选择了技术这一条路，是没有尽头的。为什么呢？因为你看的每一本书，读的每一篇文章，都可能有你不理解的地方或者引发你思考的地方。前期你读的越多，你就会发现你不会的越多，后面读的越多你就会发现其实知识之间也会有联系的，你就会越来越轻松。这就是书越读越厚，阅读越薄的道理。</p>
<p>方法之指引，关键还是看自己的理解。之前看到的一句话我觉得是很对的，计算机基础决定了你能走多远。技术千万种，基础第一种。我个人理解的计算机学科，其实他的精髓所在就是一种思想，而这种思想的形成确实一种不断积累和阅读的过程。这就有了非科班出身与科班出身的差别。</p>
<h5 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a><strong>技术选择</strong></h5><p>我们知道学科的学习是很广泛的，就我的学习过程来说，大学学习了C/C++基础编程，这里其实学习的就是编程思想，后来我们学习了java和.net以及接触了html/javascript语言，而这里学习的其实就是技术的广度。中间的学习过程中穿插着计算机组成原理/数据结构/计算机网络/数据结构等课程，这里学习的就是计算机基础，最重要的核心部分，是一种统筹全局的基础。其他的思想或者技术原理大部分是从这里延伸的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/12/chooseYourTech/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>比如我们学习JavaScript的时候，DOM操作涉及到的线程的概念就是计算机基础的内容。所以无论大家选择的是哪一种技术，必学的确实计算机基础的内容。之前我们可能都已经忽略了这个，上课总是不认真听讲，认为我们的学习时间还不如用来好好学习最新的技术好。其实这也是可以理解的，毕竟我们是在一个浮躁的时代，大部分同学们都有急于求成的心态。</p>
<h2 id="03-如何快速学习"><a href="#03-如何快速学习" class="headerlink" title="03 如何快速学习"></a>03 如何快速学习</h2><hr>
<p>我的学习方法很简单，刚开始决定学技术的时候，就只有看视频这个方法，因为本人开始不喜欢看书，认为这个书讲的很高深且不容易懂，更重要的是看不到效果。所以开始我就跟着一些大佬敲着看不太懂的代码，虽然是很艰难的过程，也有一些地方也跟不上，但最后不得不说视频用来启蒙的效果是不错的。</p>
<p>由于自己的起步比较晚，开始也没有注意到以后要走技术这一条路，便开始了懵懂的学习，也没有人带。所以技术之路比较曲折，也很高兴自己能够坚持下来。一开始对什么都是一种兴趣的驱动，从学习英语到现在转向学习技术的过程，都是很大部分是兴趣驱动，技术的话也有毕业就业的压力在里面。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/12/chooseYourTech/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>上面我是说快速学习，但是学习任何一种技术，从来都是靠一直的积累才可以理解的，只有理论基础支撑着你才能渐渐融会贯通。快速学习只是学习一种思想，但是原理实现或者作者的思维过程你是要慢慢去理解的，思想高度不到的话是很难理解的，你想一下人家工作几年的职场老鸟，而你只是一个应届的菜鸟小白，差距一想就知道。</p>
<p>关于如何才是真正的学懂弄通，我觉得这一张图正好是很好地解释了这个道理。大家也可以参考一下自己到了哪个地步。从被动学习到主动学习是要经过一个漫长的过程的，我觉得大部分应该是在听讲和阅读阶段，正如老师所说，听懂了不代表你会了。</p>
<h5 id="被动学习"><a href="#被动学习" class="headerlink" title="被动学习"></a><strong>被动学习</strong></h5><p>我们平时去上课，看书的过程都是一个被动学习的过程，甚至有时候你上台讲解一个PPT都是被动学习。作为一名刚入门的小白，我相信大家都会经历这里面的每一个步骤。从看书阅读之中，我们所有接收的知识都是跟着作者的思路，而不是你自己的思路。当然你也可以在书上写出你自己的想法，这也和演示的过程一样，都属于被动学习。</p>
<p>我们看到一个被动学习的同学，记住的知识的概率并不高。根据遗忘曲线，我们在不复习的情况之下很快就会忘记了，因为记忆早期是存在于短期记忆中。当然如果你经常复习，记忆就会存储到长期记忆当中，根据个人经验，确实只有通过主动学习才会印象深刻。</p>
<h5 id="主动学习"><a href="#主动学习" class="headerlink" title="主动学习"></a><strong>主动学习</strong></h5><p>当你慢慢学会主动学习之后，你就应该通过小组讨论、然后把结果付诸实践之后你才会形成自己的见解，假如你能够传授给他人，那么证明你是真正学会了这个知识点。这也是为什么课堂教学最好采用小组讨论的形式比较好吧。其实我们也可以进行主动学习，一般来说有两个比较好的方法：</p>
<p>技术分享和博客总结，首先技术分享并不是经常有机会的，环境也有要求，也不是经常技术分享的机会来给到你，所以这个我们就暂时不考虑了。我们知道，阅读听课等都是输入的过程，我们注重的是知识的输出，所以输出的方式有很多种，除了技术分享外还可以写博客的方式，也是一种学习总结的过程，推荐这个方式。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/12/chooseYourTech/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="04-关于方向的思考"><a href="#04-关于方向的思考" class="headerlink" title="04 关于方向的思考"></a>04 关于方向的思考</h2><hr>
<p>其实一开始学习技术的时候，并没有对方向有多大的理解和感悟，只是随着时间的推移，觉得自己做的是正确的选择。正如一开始所说的，人都会有浮躁的时候，如果一开始选择的是后端方向，自己很有可能坚持不下去。因为这是一个看不到效果的东西。</p>
<p>如果给自己的方向定义一个方向的话，大概是这样的情况。有两种情况，一个是走技术的方向，而另一个则是走管理的方向，可能自己很大的概率会走管理的路线。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/12/chooseYourTech/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>通过上面的讲解，我们回顾一下：</p>
<p>首先是学习方法和学习技术，一旦自己可以确定下来，就努力深挖，找到适合自己的路线配以学习方法，一定会有属于你自己的收获。还有就是关于如何学习，这里也提出两个建议，可以以技术博客和技术分享的形式巩固自己的知识点。最后是关于职业的思考，制定长远的路线，然后就开始付诸实践，从不断的总结中找到适合自己的路！</p>
<p>共勉！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/12/chooseYourTech/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>选择</tag>
        <tag>大学</tag>
        <tag>技术栈</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>前端配色设计技巧</title>
    <url>/2020/03/11/colorDesign/</url>
    <content><![CDATA[<h2 id="前端配色设计技巧"><a href="#前端配色设计技巧" class="headerlink" title="前端配色设计技巧"></a>前端配色设计技巧</h2><blockquote>
<p>“ 一日不书，百事荒芜”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>近来忽然看到一篇文章，说的也是关于前端面试的问题，“是否对色彩有研究”。我一看这不是设计师该考虑的问题吗？面试官的问法也是在意料之内，想想前端的任务就是把设计师的设计图用代码实现，配色问题我们也是可以提出意见和看法，这也关乎到用户体验的问题。</p>
<p>从色彩理论上来看，颜色的选择是可以看出一个人的性格，情绪和情感甚至回忆。所以当颜色理论用于网站设计的时候就必须要慎重，特别是一些官网的设计，要符合产品、公司理念或者公司特色。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-颜色来源"><a href="#02-颜色来源" class="headerlink" title="02 颜色来源"></a>02 颜色来源</h2><hr>
<p>所有的颜色基本其实都是来源于三原色，就是前端所熟悉的RGB调色。三原色指的就是红蓝黄。开始解释之前我们先来了解一下以下的信息：</p>
<ul>
<li>原色        间色     三级颜色</li>
<li>互补色      相似色   三角色</li>
<li>分散互补色  四方色   四方补色</li>
<li>明暗色      暖色     冷色</li>
</ul>
<p><strong>原色</strong>：也就是前端熟悉的RGB，所有颜色的源头都是从原色中产生，比如电视屏幕等像素点越多，显示的颜色点就越多，就是分辨率高。</p>
<img src="/2020/03/11/colorDesign/1.webp" alt=" " style="zoom:50%;">

<p><strong>间色：</strong><br>间色其实就是把红蓝、红黄、黄蓝相互混合，就会出现紫色、橙色、绿色。</p>
<img src="/2020/03/11/colorDesign/2.webp" alt=" " style="zoom:50%;">

<p><strong>三级颜色</strong>：</p>
<p>三级颜色就是从原色与间色之间的融合，会产生比较多样的颜色，常见的有蓝绿色、黄绿色等。</p>
<img src="/2020/03/11/colorDesign/3.webp" alt=" " style="zoom:50%;">

<p><strong>互补色</strong>：</p>
<p>我们从色轮上看到的对向的两种颜色，就称为互补色。比如红色和绿色，它的特点就是色彩对比强烈，即有所冲突又有协调的感觉。</p>
<img src="/2020/03/11/colorDesign/4.webp" alt=" " style="zoom:50%;">

<p><strong>相似色</strong>：</p>
<p>就是色轮上面相似的三种颜色。</p>
<img src="/2020/03/11/colorDesign/5.webp" alt=" " style="zoom:50%;">

<p><strong>三角色</strong>：</p>
<p>通过在色轮上面绘画一个等边三角形，所对应的颜色就是三角色。</p>
<img src="/2020/03/11/colorDesign/7.webp" alt=" " style="zoom:50%;">

<p><strong>分散互补色</strong>：</p>
<p>与互补色比，其实就是去互补色的两边颜色。颜色有对比也更丰富。</p>
<img src="/2020/03/11/colorDesign/8.webp" alt=" " style="zoom:50%;">

<p><strong>四方色</strong>：</p>
<p>在色轮上面画一个正方形，所对应的颜色就是四方色。</p>
<img src="/2020/03/11/colorDesign/9.webp" alt=" " style="zoom:50%;">

<p><strong>四方补色</strong>：</p>
<p>四方补色采用一个矩形样子，所对应的就是四方补色。</p>
<img src="/2020/03/11/colorDesign/10.webp" alt=" " style="zoom:50%;">

<p><strong>明暗色：</strong></p>
<p>就是通过对一种颜色进行明暗处理。产生的颜色非常丰富，可用于一些文字或者背景图，但不想太明显的地方。给人一种缓和感。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/11.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<p><strong>暖色</strong>：</p>
<p>给人一种温暖的感觉。比如如果你在夏天穿一件红色的衣服，就会给人一种更加热的感觉。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/12.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>冷色</strong>：</p>
<p>冷色所具有的意义很多，比如悲观，秋天，夜晚。但又可能是一种宁静，安静的感觉。 </p>
<img src="/2020/03/11/colorDesign/11.webp" alt=" " style="zoom:50%;">



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>颜色搭配我们要秉承的是一种和谐稳定的原则。慎用那种比较震撼的色彩，比如海报如果使用红绿对比会让人头晕。所以我们配色以温和优雅为主。</p>
<h5 id="色彩平衡"><a href="#色彩平衡" class="headerlink" title="色彩平衡"></a><strong>色彩平衡</strong></h5><ul>
<li>色彩单一，通过明暗处理</li>
<li>主色周围使用若干辅色配合</li>
<li>高饱和度搭配低饱和度</li>
</ul>
<h5 id="过渡色"><a href="#过渡色" class="headerlink" title="过渡色"></a><strong>过渡色</strong></h5><p>当你一定要使用互补色等有强对比的颜色时，一定要注意运用间色进行缓冲，平衡过渡，给人一种平衡缓冲的感觉。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="相似色搭配"><a href="#相似色搭配" class="headerlink" title="相似色搭配"></a><strong>相似色搭配</strong></h5><p>相似色的运用得当，会使你的页面布局看起来非常和谐，就比如QQ的下载页面，给人一种温和优雅简洁的感觉。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="白色的搭配"><a href="#白色的搭配" class="headerlink" title="白色的搭配"></a><strong>白色的搭配</strong></h5><p>白色给人一种干净，简约的感觉，相信很多人都会喜欢简约的感觉，没有过多的修饰。但是也必须要使用辅色配合，不然会产生一种单调乏味的感觉。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/4.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>案例1</strong>：香港地铁的每一个站点都是不用的颜色，可以看出都是利用了原色与其他颜色相混合形成的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/12.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p><strong>案例2</strong>：德国柏林消防局的颜色是红色，警察局的颜色是绿色。将红绿两种互补色巧妙地融合在一起。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/13.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>颜色搭配也是生活中的内容，比如衣服颜色如何搭配，室内的家居设计、墙纸设计等，这些都是颜色的范围。只有当我们能够对配色有一定的了解，我们就可能丰富我们审美上面的灵感。</p>
<p>对于颜色设计和搭配的问题，可以参考国内一些大公司的官网，从中你会取得一些设计灵感的。毕竟写这篇文章只是问了丰富一下自己的知识，前端只需要了解一下即可，并不用细心研究，剩下的你大可以交给UI部门的设计师，很多大公司的分工很明确。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/colorDesign/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

]]></content>
      <categories>
        <category>前端设计</category>
      </categories>
      <tags>
        <tag>配色</tag>
        <tag>视觉设计</tag>
        <tag>体验</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器按下回车发生了什么</title>
    <url>/2020/03/11/enterProcess/</url>
    <content><![CDATA[<h2 id="浏览器按下回车发生了什么"><a href="#浏览器按下回车发生了什么" class="headerlink" title="浏览器按下回车发生了什么"></a>浏览器按下回车发生了什么</h2><blockquote>
<p>“立身以立学为先，立学以读书为本”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/enterProcess/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>这一篇文章是其实就是讲述浏览器的渲染原理，普通用户虽然操作浏览器只会关注页面是否能够显示出来，但是作为前端程序员是要去关注要是显示异常该如何排查问题。</p>
<p>其实当你深入研究的时候，你会发现中间过程比我们想象的还要复杂。其中包括IP地址的解析、DNS服务器查询，服务器响应等一系列过程，下面我就解析一下浏览器到底是怎么工作的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/enterProcess/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-响应过程"><a href="#02-响应过程" class="headerlink" title="02 响应过程"></a>02 响应过程</h2><hr>
<p>从我自己的总结来看，它可以分为以下几个流程：</p>
<ul>
<li>IP地址查询</li>
<li>建立TCP连接</li>
<li>服务器处理</li>
<li>响应返回</li>
<li>页面渲染</li>
</ul>
<h5 id="IP地址查询"><a href="#IP地址查询" class="headerlink" title="IP地址查询"></a><strong>IP地址查询</strong></h5><p>假设我们在页面上输入 www . baidu . com ，那么我们是如何得到百度的IP地址呢？我先来插个小插曲，其实百度服务器的IP地址是有多个的，因为对于搜索引擎来说每天都有巨大的访问量，必须有负载均衡的处理，否则就会崩溃挂机。</p>
<p>IP地址的查询其实也通过几个步骤来得到的</p>
<ul>
<li>首先浏览器查询自己的DNS缓存</li>
<li>如没有就会去操作系统中进行查找，也会查找一下本机的host是否有缓存</li>
<li>如没有就会去路由器中查找</li>
<li>再没有就去本地域名服务器中查找，一般是本地的服务运营商，如中国电信</li>
<li>操作系统会得到IP地址，并且缓存起来</li>
<li>浏览器得到操作系统返回的IP地址，同样也缓存</li>
</ul>
<p>到了这里浏览器就会得到www . baidu . com 的IP地址了，接下来就会进行地址的访问和连接。</p>
<h5 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a><strong>建立TCP连接</strong></h5><p>建立TCP连接最重要的就是要进行三次握手</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/enterProcess/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>当进行数据发送之前，会把数据经过网络协议的层层封装，经过应用层、传输层、网络层、链路层。当服务器接收数据时会对数据进行拆封，最后才会得到HTTP数据。我们知道TCP/IP分层模型一般会分成以下几层（图），每一层都有不同的协议对应着，保证了数据的传输。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/enterProcess/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>那么每一层对应哪些协议呢？</p>
<p><strong>应用层</strong>：决定了向用户提供应用服务时通讯的活动。比如FTP（文件传输协议），DNS（域名系统），HTTP（超文本传输协议），Telnet（网络远程访问协议）等。</p>
<p><strong>传输层</strong>：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。提供TCP（传输控制协议）和 UDP（用户数据报协议）两种协议，主要是对数据格式化、数据确认和数据丢失重传。</p>
<p><strong>网络层</strong>：用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。规定了通过怎么样的途径来到达对方的计算机，并传输数据给它。网络层中通过IP协议把数据包传输给对方。IP地址指明结点被分配到的地址，而MAC地址指网卡所属地址（一般不会改）。在IP层中，会通过ARP（地址解析协议）得到相应的MAC地址。</p>
<p><strong>链路层</strong>：处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、网卡以及光纤的物理可见部分。涉及硬件部分就依赖于MAC地址。</p>
<h5 id="服务器处理"><a href="#服务器处理" class="headerlink" title="服务器处理"></a><strong>服务器处理</strong></h5><p>当数据到达服务器就会进行解析处理。处理结果会返回一个状态码，常见的状态码有如下几种：</p>
<ul>
<li>200 OK ：客户端请求成功</li>
<li>400 Bad Request ：客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized ：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li>403 Forbidden ：服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found ：请求资源不存在</li>
<li>500 Internal Server Error ：服务器发生不可预期的错误</li>
<li>503 Server Unavailable ：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h5 id="响应返回"><a href="#响应返回" class="headerlink" title="响应返回"></a><strong>响应返回</strong></h5><p>当浏览器接收到服务器返回的数据，会对数据进行预处理，根据状态码来进行不同的处理。比如403状态码，就会允许浏览器使用缓存而无需重新请求。如果是200状态码，可能就是一次新的请求，浏览器可能会对资源进行解压缩、缓存资源等操作。最后一步才是解析资源，渲染页面。</p>
<h5 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a><strong>页面渲染</strong></h5><p>浏览器接收到数据，会进行以下步骤的操作：</p>
<ul>
<li>解析HTML文件，转换成DOM树</li>
<li>解析CSS文件，转换成CSSOM树</li>
<li>生产渲染树</li>
<li>将信息发送给GPU，合成渲染</li>
</ul>
<p>我们知道，计算机的传输都是以0101的数据进行传输，所以说我们接收到的数据也是这种格式，我们必须要进行解析。首先将字节数据转换成字符串，也就是我们的代码。然后对字符串进行词法分析转换成token（标记），这一过程就是标记化。下一步就把标记转换成Node，最后根据不同的联系构建出一棵DOM树。</p>
<p>解析CSS的原理一样，两棵树的解析是并行的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/enterProcess/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>最后就是合并两棵树的操作，注意渲染树会忽略那些不需要显示的节点，比如节点的样式设置为：display:none;</p>
<h2 id="03-重绘与回流"><a href="#03-重绘与回流" class="headerlink" title="03 重绘与回流"></a>03 重绘与回流</h2><hr>
<p>重绘与回流影响的是两棵树的解析过程，那么什么是重绘和回流呢？</p>
<ul>
<li>重绘</li>
</ul>
<p>当我们修改了DOM的一些样式，比如修改文字颜色或者背景色，这些浏览器是不需要重新计算几何属性的，直接绘制新的样式。</p>
<ul>
<li>回流</li>
</ul>
<p>当我们修改DOM的几何属性，一般有修改元素的宽高等，浏览器就会重新计算位置，然后再进行重新绘制。</p>
<p>那么我们该如何避免呢？</p>
<ul>
<li>减少使用绝对定位，使用transform代替</li>
<li>减少使用display，使用visibility代替</li>
<li>css样式避免节点嵌套过多，匹配规则是从右往左</li>
</ul>
<h2 id="04-阻塞渲染"><a href="#04-阻塞渲染" class="headerlink" title="04 阻塞渲染"></a>04 阻塞渲染</h2><hr>
<p>因为JS运行是单线程的，所以当我们解析HTML代码和JS代码就会有冲突。我们的期望是先把页面渲染出来，然后再执行JS代码。所以我们就要注意以下几个事情：</p>
<ol>
<li>把&lt; script &gt;标签放在底部</li>
<li>把样式文件放在顶部，防止页面“裸奔”</li>
</ol>
<p>DOM解析和CSS解析是两个并行的进程，CSS加载不会阻塞DOM的解析</p>
<p>由于渲染树是依赖于DOM树和CSSOM树的，必须等待到CSSOM树构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞DOM的渲染的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/enterProcess/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>对于浏览器渲染原理这一部分，面试也是经常考到的，前端必须对这一块非常熟悉。这一块很有深度，对于项目的优化都可以参照以上的过程，只有当每一个过程都达到最优的状态，性能才是最佳。</p>
<p>其实还有很多知识点没有讲解出来，读者可以根据需要去自行查找，总体方向就是以上的过程。</p>
<p><img src="/2020/03/11/enterProcess/2.gif" alt></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>浏览器</tag>
        <tag>线程</tag>
        <tag>三次握手</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>开始面试，我该准备什么</title>
    <url>/2020/03/11/interviewTip/</url>
    <content><![CDATA[<h2 id="开始面试，我该准备什么"><a href="#开始面试，我该准备什么" class="headerlink" title="开始面试，我该准备什么"></a>开始面试，我该准备什么</h2><blockquote>
<p>“别人怀宝剑，我有笔如刀”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/interviewTip/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>临近毕业，相信大家都会忙着找工作，面试等，即使大三的小伙伴也会想着出去找一份实习单位，增加自己的工作经历，为来年的毕业做准备。那么我们找工作之前必须要清楚几件事情，否则找工作可能不会怎么顺利。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/interviewTip/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-面试准备"><a href="#02-面试准备" class="headerlink" title="02 面试准备"></a>02 面试准备</h2><hr>
<p>我们找工作要注意以下几件事情：</p>
<ul>
<li>如何写一封好简历</li>
<li>什么时候投简历</li>
<li>如何判断公司是否靠谱</li>
<li>面试该如何准备</li>
<li>面试被问倒了怎么办</li>
<li>如何跟HR谈钱</li>
</ul>
<h5 id="如何写一封好简历"><a href="#如何写一封好简历" class="headerlink" title="如何写一封好简历"></a><strong>如何写一封好简历</strong></h5><p>简历是我们面试的敲门砖，如果一开始你的简历写不好，往往就可能错过这份工作的机会。简历投递后，一般公司都会有专门的HR进行预筛选。我们要接受的现实是，学历和学校我们是改变不了的，对于公司只收研究生学历或者985/211大学的，我们就根据自己的情况进行投递。</p>
<p>还有非常重要的一点就是简历不能作假，一旦发现作假可能就会被公司列入黑名单。这个可不是开玩笑，可能你以后在互联网的圈子也混的不太好。所谓立人以立德为先，必须诚实守信。对于自己的学历和学校要如实填写，没有工作经验不要紧，一般应届生都很少有工作经验，你只要好好把基础掌握，写上几个有深度的项目即可。</p>
<p>那么我们该注意什么呢？</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/interviewTip/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<ul>
<li>简历基本模块</li>
<li>丰富项目经历</li>
<li>丰富在校经历</li>
<li>工作经历(加分)</li>
</ul>
<h6 id="简历基本模块"><a href="#简历基本模块" class="headerlink" title="简历基本模块"></a><strong>简历基本模块</strong></h6><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/interviewTip/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>简历遵循的应该是简洁美观，不要搞那些花里胡哨的页面，突出重点即可。让HR第一眼看到你应聘的岗位，你的学历学校等信息，HR应该不会过多关注你的技术点的，那是面试官的事情。首先你得过第一关，简历不会被筛。</p>
<h6 id="丰富项目经历"><a href="#丰富项目经历" class="headerlink" title="丰富项目经历"></a><strong>丰富项目经历</strong></h6><p>我们应届毕业生都有这样的感觉，不知道项目写什么，造成了没东西可写的尴尬局面。但是仔细想想，大学四年好像也没做什么有用的项目，是不是就没办法了呢？</p>
<p>其实我们可以对应自己的岗位特点，看一下网上公司的招聘需求，然后制定相应的计划。一般项目不需要太大，涵盖基本的知识点即可，面试官也会知道应届生是不会写出很厉害的项目的。我们可以在网上(github)看几个项目实战，比如vue项目实战或者小程序等，跟着学习一遍，把里面的知识点学懂弄通，拓展开来，就可以写在你的项目经历上面。</p>
<h5 id="丰富在校经历"><a href="#丰富在校经历" class="headerlink" title="丰富在校经历"></a><strong>丰富在校经历</strong></h5><p>一般每个学校都会有类似科技园的地方，都是有老师到头建立的实验室，那里才是真正学习的地方。我们建议，每个学习计算机的同学都要抓住机会去学习，不要待在宿舍或者图书馆等你认为学习很好的地方。尽早选择你的方向，前端后台移动端等，然后加入团队，以项目驱动来学习，一年下来肯定比你在课堂上和自学上收获的还要多。</p>
<p>然后要抓住每一年的创新创业比赛，科技比赛等，积极参加，这都是为了以后你写简历有东西可写，参加越多越好，获奖几率就会高。一般面试官也会注意这一部分的内容，说明你是一个动手能力强的人，都会受到面试官的青睐。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/interviewTip/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h6 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a><strong>工作经历</strong></h6><p>建议大家都尽可能在大三的时候去面试找工作，提前熟悉面试流程，给自己一个缓冲的阶段。我认为在大三找工作有很多的好处，特别是对于个人技术的提升是有很大作用的，你会在这一段时间慢慢建立自己的知识体系，把知识框架都建立起来，后期就是慢慢填充知识的阶段。</p>
<p>这里工作其实是互联网公司很青睐那些有工作经验的同学，你想想每个人简历上都有至少一个的工作经历，但是你没有，你就失去了和别人竞争的资本。互联网公司的简历一般都会有评分系统的，简单来说简历的最终得分是会影响到你的薪资的。比如可能有工作经历和没有的就会相差一个等级，面试的几率也会降低。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/interviewTip/4.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="什么时候投简历"><a href="#什么时候投简历" class="headerlink" title="什么时候投简历"></a><strong>什么时候投简历</strong></h5><p>投简历的时机也非常重要，一般我们都推荐在提前批的时候就应该把自己的简历投出去，因为这个时候面试的机会很大，比正常流程的校招渠道要快，拿到的结果也快。所以说抓住提前批，你的面试通过几率也很大，一般公司会有sp offer，都会在提前批发出，所以好好准备，不要以为我还没准备好就不投了。</p>
<p>如果你有师兄师姐在某个公司里面，你也可以找他们进行内推，这个面试的机会也非常大，可以让你的简历免筛选。而且还可以找你的师兄师姐询问面试进度，不会让你一直都不知道自己的状态。他们也会很乐意帮你的，因为你过了他们有奖金。</p>
<p>如果你错失了提前批那也没关系，好好准备校招的流程，在官网上面投递简历或者找人内推，都是一样的，重要的是自身知识硬。</p>
<p>如果实在不幸，校招也没机会了，别担心还有补招阶段。一般如果春招5月左右到6月都会有补招的机会，只要你留意一下牛客网上面的信息就好。秋招的话一般到12月都还有机会，这时候千万不要慌，机会还有，一直准备面试就好，坚持就是胜利，这不是吹的，一定要坚持。</p>
<p><img src="/2020/03/11/interviewTip/5.webp" alt></p>
<h5 id="如何判断公司是否靠谱"><a href="#如何判断公司是否靠谱" class="headerlink" title="如何判断公司是否靠谱"></a><strong>如何判断公司是否靠谱</strong></h5><p>判断公司是否靠谱，我们的第一感觉就是大公司，BAT级别的肯定不会错。但是一般不是每个同学都有机会进入大公司工作，很大一部分还是在小公司的。第一个一般我们看公司的规模多大，在职员工多少；公司融资情况怎么样；公司涉及的行业未来方向怎么样；公司福利待遇如何等。</p>
<p>第二个我们看公司用的技术怎么样，技术团队如何。这关乎你以后技术的成长，是否可以在里面学到真正的东西，如果上述的都符合你的要求，那么你就可以进行简历的投递。</p>
<h5 id="面试该如何准备"><a href="#面试该如何准备" class="headerlink" title="面试该如何准备"></a><strong>面试该如何准备</strong></h5><p>技术面试一般是分为2~3轮，每一轮的侧重点是不一样的。建议同学们先准备一下基础的知识点，建立自己的基础知识体系，然后找相应的资料或者书籍进行查漏补缺。然后把每一次面试的题目都要记录下来，面试之后进行复盘，找出自己存在的问题，总结面试经验。当你面试多了，自然就懂得其中的道理。</p>
<p>多看一下面试经验，看一下别人的面试题，一般都大同小异。把每一道题背后涉及的知识原理都弄懂，拓展这一道题的深度。牛客网上面都有一些互联网公司的面试笔试题，我们可以多做总结。</p>
<h5 id="面试被问倒了怎么办"><a href="#面试被问倒了怎么办" class="headerlink" title="面试被问倒了怎么办"></a><strong>面试被问倒了怎么办</strong></h5><p>面试其实就是一个知识碰撞的过程，遇到不会的题很正常，也无需惊慌，不懂装懂反而会降低面试官对自己的印象。一般我们遇到不会的题目直接说不会，但是你遇到哪个哪个类似的问题，你是如何解决它的，这样回答也没问题。</p>
<p>但是我们不要不说话，半天在那里沉默。遇到不会也好，也要说一点其他沾边的知识点出来，这也是一种应对方法。很多情况下的知识宽度和深度都不会比面试官高，甚至都没有他要求的基础高。所以好好总结自己，即使不过也为下一次打基础。</p>
<h5 id="如何跟HR谈钱"><a href="#如何跟HR谈钱" class="headerlink" title="如何跟HR谈钱"></a><strong>如何跟HR谈钱</strong></h5><p>我们对于这个问题不用回避，毕竟你也是为了生活才和公司工作，人家给你报酬也是理所当然的。钱不到位就没有存在的价值了。</p>
<p>我们谈薪资不是随便说的，一般都参照一下别人发的工资多少。可以看一下offershow上面给的多少，然后直接说那个就好，上面的都是别人已经到手的工资情况，一般也就是那个价。问薪资的同时，一般也要注意一下：</p>
<ul>
<li>是否996</li>
<li>加班情况如何</li>
<li>上班时间如何</li>
<li>福利情况</li>
</ul>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>简历投递找工作是大部分学生都会经历的事情，坦然面对就好。找工作过程中遇到的问题慢慢解决就好，不要放弃自己当初的希望。</p>
<p>找工作越早进行越好，个人觉得应该从大一就开始准备，因为你要写相关的在校经历，从大一开始就应该参加比赛多一点，丰富你的简历内容。</p>
<p>预祝大家都可以拿到心仪的offer！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/interviewTip/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>面试</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6到底有哪些特性值得我们学习</title>
    <url>/2020/03/11/ES6/</url>
    <content><![CDATA[<h2 id="ES6到底有哪些特性值得我们学习"><a href="#ES6到底有哪些特性值得我们学习" class="headerlink" title="ES6到底有哪些特性值得我们学习"></a>ES6到底有哪些特性值得我们学习</h2><blockquote>
<p> 业精于勤，荒于嬉</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/ES6/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>ES6现在已经是下一代的语言标准了，前端的学习已经来到了一个新的阶段，我们的JavaScript语言已经可以用来编写复杂的大型应用程序，成为企业级开发语言。而现在前端开发岗已经是企业中很重要的岗位之一，所以说学习新技术，以技术驱动产品是理所当然的事情。</p>
<p>对于ES6的学习，我们建议去看一下阮一峰老师的教程，里面详细讲述了每一个知识点，很好理解。接下来我就讲一下ES6到底新增了哪一些比较重要的特性，是可以运用到我们的项目当中，并且面试常考的题目。</p>
<h2 id="02-新特性"><a href="#02-新特性" class="headerlink" title="02 新特性"></a>02 新特性</h2><hr>
<p>ES6新增了很多新特性，这里不可能每一个都详细讲述，面试中我遇到的有以下几个，你把它们都讲述清楚就可以过关了。</p>
<ul>
<li>let、var、const区别</li>
<li>箭头函数</li>
<li>解构赋值</li>
<li>模板字符串</li>
<li>Set、Map数据结构</li>
<li>Promise对象</li>
<li>Proxy</li>
</ul>
<h5 id="let-、var、const的区别"><a href="#let-、var、const的区别" class="headerlink" title="let 、var、const的区别"></a><strong>let 、var、const的区别</strong></h5><p>这几个都是用于声明变量/常量的关键字，以前我们一般都是用var来进行声明，但是有一些缺点而且还容易出错。</p>
<p>我们先了解一个变量提升和作用域的问题。</p>
<p>变量提升：是指当你用var进行声明的时候，可以不用声明就使用。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>那么函数会不会提升呢？函数和变量哪一个的优先级更高呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//f (a)&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>我们得出来的结果是函数提升的优先级比变量高。那么作用域又是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br></pre></td></tr></table></figure>

<p>执行这段代码我们就会得到结果为2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var a = 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br></pre></td></tr></table></figure>



<p>但是当我们把代码注释之后，我们就会发现结果变成了1。</p>
<p>作用域：当你在当前作业域找不到声明就会到父级的作用域去找，这样层层递进查找，最终形成了一个链，这就是作用域链。</p>
<p>let、var都是可用于声明变量的操作符，但是他们的区别就是var 存在作用域提升，而let仅限于当前作用域的使用，否则会报错。声明之前使用也会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">let</span> a</span><br></pre></td></tr></table></figure>

<p>就会说 a is not defined</p>
<p>const用于声明常量，声明之后不可改，也不存在变量提升的问题，修改或声明前使用会报错。我们还要注意一点就是let和const声明之后不会挂在到window上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>. c) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>常考的面试题是，以下代码输出什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5 5 5 5 5</span></span><br></pre></td></tr></table></figure>

<p>这就是块级作用域的问题，换成let声明就会输出0 1 2 3 4</p>
<p>总结一下：</p>
<ul>
<li>var存在变量提升，能在声明前使用。其他两个存在暂时性死区，不能声明前使用</li>
<li>let 和 const基本一致，后者不能再次赋值</li>
<li>函数提升由于变量提升</li>
</ul>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a><strong>箭头函数</strong></h5><p>箭头函数是ES6新增的一种函数写法，下面两种写法其实是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>它和普通函数有什么区别呢？</p>
<ul>
<li>不可用作构造函数，没有原型</li>
<li>this指向继承而来且不会改变</li>
</ul>
<h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><strong>解构赋值</strong></h5><p>解构赋值就是一种模式匹配的写法，之前我们赋值的时候一般都要分别来赋值，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>但是解构赋值允许我们这样赋值，左右两边都对应复制，如果解构不成功就会赋值undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c); <span class="comment">//1, 2, undefined</span></span><br></pre></td></tr></table></figure>

<p>我们比较常用的一般有两种方面，一个是JSON字符串的解构，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;name,age,number&#125; = &#123;<span class="attr">name</span>:<span class="string">'rose'</span>,<span class="attr">age</span>:<span class="number">12</span>,<span class="attr">number</span>:<span class="number">123</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name,age,number);  <span class="comment">//rose 12 123</span></span><br></pre></td></tr></table></figure>

<p>还有一种我们可以用来数据的交换操作，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a&#x3D;1;</span><br><span class="line">let b&#x3D;2;</span><br><span class="line"></span><br><span class="line">[a,b]&#x3D;[b,a];</span><br><span class="line"></span><br><span class="line">console.log(a,b);  &#x2F;&#x2F;2, 1</span><br></pre></td></tr></table></figure>

<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a><strong>模板字符串</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">  <span class="string">'items in your basket, '</span> +</span><br><span class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>

<p>相比于之前使用+拼接简洁许多，并且可读性比较强。语法就是使用反引号``来声明，然后变量使用${variable}。</p>
<h5 id="Set、Map数据结构"><a href="#Set、Map数据结构" class="headerlink" title="Set、Map数据结构"></a><strong>Set、Map数据结构</strong></h5><p>Set它是一个构造函数，用来生成Set数据结构。类似于数组，但是跟数组不同的是它的每一项都不会重复。作用也可以用于数组去重的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>

<p>数组去重，比较简单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map是一个类似于对象，是键值对的集合，但是键的范围不限于字符串，各种类型的值都可以作为键，包括object。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>作为构造函数，Map也可以接受一个数组作为参数，数组的成员也是一个个表示键值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure>

<h5 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a><strong>Promise对象</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><strong>Proxy</strong></h5><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy的拦截有以下13种，具体用法可以查找我之前写的Proxy。</p>
<ul>
<li>get(target, propKey, receiver) 拦截对象属性读取</li>
<li>set(target, propKey, value, receiver) 拦截对象的属性设置</li>
<li>has(target, propKey) 拦截propkey in proxy</li>
<li>deleteProperty(target, propKey) 拦截delete proxy[propKey]</li>
<li>ownKeys(target)</li>
<li>getOwnPropertyDescriptor(target, propKey) 返回对象属性的描述对象拦截</li>
<li>defineProperty(target, propKey, propDesc)</li>
<li>proventExtensions(target)</li>
<li>getPrototypeOf(target)</li>
<li>isExtensible(target)</li>
<li>setPrototypeOf(target, proto)</li>
<li>apply(target, object, args)</li>
<li>construct(target, args) 拦截 proxy 实例作为构造函数调用的操作</li>
</ul>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>ES6的很多新特性都可以让我们的变成更加简单，但是我们需要深入理解其中的每一个细节，写法不当可能会是我们的程序产生不一样的运行效果。如果读者想了解更多的细节，推荐阅读阮一峰的ES6入门标准第三版，定会收获良多。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/ES6/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
        <tag>proxy</tag>
        <tag>解构赋值</tag>
        <tag>模板字符串</tag>
        <tag>变量提升</tag>
      </tags>
  </entry>
  <entry>
    <title>关于服务端渲染（SSR）的问题总结</title>
    <url>/2020/03/11/SSR/</url>
    <content><![CDATA[<h2 id="关于服务端渲染（SSR）的问题总结"><a href="#关于服务端渲染（SSR）的问题总结" class="headerlink" title="关于服务端渲染（SSR）的问题总结"></a>关于服务端渲染（SSR）的问题总结</h2><blockquote>
<p>“ 自从有了SSR，客户就会乐哈哈 “</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/SSR/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>近几年服务端渲染的的技术却火了起来，关于历史上的问题我也不知道，所以就查阅一些资料来了解一下为什么会出现服务端渲染。从字面上的意思就是，服务端就可以渲染而不用浏览器渲染（CSR）。我们都知道请求服务器之后，会返回html代码，然后浏览器跑一遍JS和HTML等，形成DOM树渲染页面。而服务端渲染就免去了这一步骤，浏览器拿到返回的数据后直接渲染。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/SSR/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-历史原因"><a href="#02-历史原因" class="headerlink" title="02 历史原因"></a>02 历史原因</h2><hr>
<p>关于历史原因，查看了两位阿里的博客。</p>
<p>其实一开始html代码就是由后端渲染的，但是后端程序员发现其中含有一些javascript代码，与他们自己写的不太一样而且难以维护。所以索性找几个人把代码分离出来专职维护，这就是前端的概念。相对于后端来说前端是没有什么技术含量的，只是切图和写js代码。</p>
<p>但是近几年来，前端的项目越来越庞大，涉及到很多方面的内容，特别是前端框架vue和react出来之后。所以写之前js的那些人员就开始探索前端的方面，逐渐形成前端开发的概念。这一方面就是前端代码变得越来越多，后端变得臃肿，所以后端就只返回数据给你，别的就不愿意去弄了。（前端卑微，任人鱼肉）</p>
<p>但是后来人们对网站体验的要求高了，产品经理就出来说你们的网站太卡了，用户体验不好。总归SSR出现的原因就是有两点：</p>
<ul>
<li>首屏渲染慢</li>
<li>不利于搜索引擎（SEO）</li>
</ul>
<h5 id="首屏渲染慢"><a href="#首屏渲染慢" class="headerlink" title="首屏渲染慢"></a><strong>首屏渲染慢</strong></h5><p>我们都知道当我们请求网页的html代码的时候，服务器原封不动地返回而且不带数据（生气），我们还要手动去请求一下通过各种方式渲染在页面上，放在现在也是慢了更何况是以前的时候。如果一旦遇到网络不好的时候，可能就会出现白屏持续一段时间等页面渲染，客户极有可能会烦躁。这就就是客户端渲染（CSR）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/SSR/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>但是如果采用服务端渲染就不会这样了，浏览器做的工作就是直接渲染，通俗一点来说就是你给我啥我就画啥，不用去构图设计等繁琐的操作（对应DOM解析和js解析）。而且这时候客户可以很快就看到页面长什么样，觉得这个网站不错，很流畅。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/11/SSR/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="不利于搜索引擎"><a href="#不利于搜索引擎" class="headerlink" title="不利于搜索引擎"></a><strong>不利于搜索引擎</strong></h5><p>如果是采用客户端渲染的话，搜索引擎是找不到我们文章或者网站的内容的，那么如果你是一个主打社交或者广告的网站，那么这一方面就很重要了，一定要使用SSR渲染，这样网站才有流量和访问量，性能却在其次。</p>
<p>其实前后端的渲染本质是一样的，都是字符串的拼接，将数据渲染进一些固定格式的html代码中形成最终的html展示在用户页面上。  因为字符串的拼接必然会损耗一些性能资源。 如果在服务器端渲染，那么消耗的就是server端的性能。 如果是在客户端渲染，常见的手段，比如是直接生成DOM插入到html 中，或者是使用一些前端的模板引擎等。他们初次渲染的原理大多是将原html中的数据标记（例如）替换。</p>
<h2 id="03-应用场景"><a href="#03-应用场景" class="headerlink" title="03 应用场景"></a>03 应用场景</h2><hr>
<p>针对上述两种情况，网站流量如果是比较大的话，首屏的加载一定要做好，因为这样可以给客户留下一个好的印象，只有用户体验好了别人才会愿意用你的产品。像一般的官网，或者电商网站等都可以使用SSR。</p>
<p>但是SSR利用的是服务器的资源，服务器资源是很昂贵的，所以并不是每个网站都适合做服务端渲染。vue全家桶或者react全家桶，都是推荐通过服务端渲染来实现路由的。</p>
<p>其实如果不使用SSR，之前我写过前端性能优化的文章，可以让首屏减少网络请求或者压缩请求等方式提高加载速度，并非一定要使用SSR，只是在有条件的情况之下可以使用SSR来提高加载速度。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>其实SSR的出现也是一个必然的局面，因为近年来Node.js的出现，使得JavaScript语言可以在服务端运行。前端工程师都愿意去使用js来实现SSR，更何况前端框架Vue都是用SSR来实现路由的。</p>
<p>作为一种解决方案，前端也应该去了解一下是怎么操作的，毕竟现在也说“大前端”的时代，每个人都是web开发者，就更应该去实践一下，顺便以后帮后端分担一下压力。</p>
<p><font color="green">参考文章：</font></p>
<ul>
<li>服务端渲染（SSR）</li>
<li>为什么现在又流行服务器端渲染html</li>
</ul>
<p><img src="/2020/03/11/SSR/2.gif" alt></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>SSR</tag>
        <tag>服务端渲染</tag>
        <tag>首屏加载</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>总结Vuex如何在项目中的使用</title>
    <url>/2020/03/10/vuex/</url>
    <content><![CDATA[<h2 id="总结Vuex如何在项目中的使用"><a href="#总结Vuex如何在项目中的使用" class="headerlink" title="总结Vuex如何在项目中的使用"></a><strong>总结Vuex如何在项目中的使用</strong></h2><blockquote>
<p><strong>“</strong> 使用全局的数据管理，让我们更方便地处理数据？<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/10/vuex/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>作为vue框架中的一个重要部分，vuex到底是什么呢？</p>
<p>vuex是一种<strong>状态管理模式</strong>，它保存着组件的公用的状态，并且以相应的规则保证状态变化。vuex的核心就是一个store，它相当于是一个容器，其中state包含了我们组件所有的状态，除了有state还有action,mutation,getter,modules。</p>
<ul>
<li>state：用于数据的存储，是store中的唯一数据源</li>
<li>getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li>
<li>mutation：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</li>
<li>action：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作</li>
<li>modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li>
</ul>
<p>它与全局的对象有两点不同：</p>
<ol>
<li>Vuex的状态是响应式的。当vue组件从store中读取状态时，若state中的状态发生变化，那么相应引用的组件就会得到更新。</li>
<li>不能直接改变store的状态。唯一的方法就是通过显示提交（commit）mutation。</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/10/vuex/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-简单的例子"><a href="#02-简单的例子" class="headerlink" title="02 简单的例子"></a>02 简单的例子</h2><hr>
<h5 id="安装vuex"><a href="#安装vuex" class="headerlink" title="安装vuex"></a><strong>安装vuex</strong></h5><p>一般我们都会通过NPM或者Yarn来进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br><span class="line">//或者</span><br><span class="line">yarn add vuex</span><br></pre></td></tr></table></figure>

<p>然后当你需要使用的时候就注册安装一下vuex即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的例子中，state中存储的就是我们的数据源，而mutation就用用来改变数据源的操作，也是唯一的方式。当我们改变count的时候，我们就可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure>



<h2 id="03-核心概念"><a href="#03-核心概念" class="headerlink" title="03 核心概念"></a>03 核心概念</h2><hr>
<p>vuex中有几个核心的概念，我们先来认识一下：</p>
<ul>
<li>State</li>
<li>Getter</li>
<li>Mutation</li>
<li>Action</li>
<li>Module</li>
</ul>
<h5 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h5><p>首先State我们知道，就是一个大仓库，存储着很多变量的值，任何人都不可以直接去改变里面的值，必须要经过一个信任的人（mutation）来改变。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/10/vuex/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>通过把vuex挂载到根组件，就不用每一次使用都要Vue.use(vuex)了，挂载之后就可以使用this.$store获取store实例了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Banker 组件</span></span><br><span class="line"><span class="keyword">const</span> Banker = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;My bank account have&#123;&#123; money &#125;&#125;$&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，要是组件里面有多种状态，你总不能都声明为计算属性吧</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`, 这样html代码里面的变量可以写成 countAlias</span></span><br><span class="line">    countAlias: <span class="string">'count'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者如果变量与state相同，可以直接传递一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>



<h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a><strong>Getter</strong></h5><p>通俗一点来讲，就是在获取数据的时候先做一遍处理。而且这个处理是全实例通用的，比如以下的例子，获取符合条件的数据，就不用把函数复制放在每一个的computed中，直接从store中拿来用就好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么当我们的组件需要的时候就直接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br></pre></td></tr></table></figure>

<p>如果你有多个Getter，那也可以像上面mapState一样，有同样的方法mapGetters可以用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodos'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a><strong>Mutation</strong></h5><p>我们前面提到过，要想改变状态就必须要提交mutation。值得注意的是，mutation必须是同步函数，因为异步的回调函数在状态的改变上是不可以跟踪的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里的mutation是定义了数据是怎么改变的，但是还没有变的，因为没有去触发它。当你想数据改变的时候必须手动去触发，你可以在组件中使用如下的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure>

<p>当然你也可以传入一个参数，比如像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>除了是单一的参数，还支持对象的形式（大部分是对象）:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a><strong>Action</strong></h5><p>Action与mutation是类似的，不同的是：</p>
<ul>
<li>Action提交的是mutation，而不是直接改变状态</li>
<li>Action可以包含异步操作，而Mutation是不可以的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>大家可能发现了，increment的参数是一个context，这个其实就是与store实例具有相同方法和属性的对象。你可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">context.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="comment">//你也可以使用以下的方式获取state/getters</span></span><br><span class="line"><span class="comment">//context.state</span></span><br><span class="line"><span class="comment">//context.getters</span></span><br></pre></td></tr></table></figure>

<p>来提交一个mutation。</p>
<p>前面我们定义mutation的时候，只是定义而已，实际触发还需要commit的方式。所以这里也是一样的，需要dispatch来触发action。像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure>

<p>上面我们提到可以异步操作的，类似这样来定义action：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以传递参数，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#39;incrementAsync&#39;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以对象形式分发</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: &#39;incrementAsync&#39;,</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a><strong>Module</strong></h5><p>我们知道，当项目非常大的时候，把所有的mutation或action都写在一起，难免会显得很臃肿，变得难以维护。所以我们就有了module模块的概念，把内容进行不同的分类，每一个模块都有自己的mutation或者getter等。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>



<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。</p>
<p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 <a href="https://cn.vuejs.org/v2/guide/state-management.html#简单状态管理起步使用" target="_blank" rel="noopener">store 模式</a>就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p>
<p><img src="/2020/03/10/vuex/2.gif" alt></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Vue内部模板编译和解析</title>
    <url>/2020/03/08/vueTemplate/</url>
    <content><![CDATA[<h2 id="浅析Vue内部模板编译和解析"><a href="#浅析Vue内部模板编译和解析" class="headerlink" title="浅析Vue内部模板编译和解析"></a><strong>浅析Vue内部模板编译和解析</strong></h2><blockquote>
<p><strong>“</strong> 我们写在组件里面的HTML代码，最后是怎么渲染到页面的？<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/vueTemplate/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>由于Vue框架是大多数人都会用的，因此也成为了前端面试的必问内容。我们平时在组件里面编写的HTML代码，最后神奇地渲染在页面上，中间怎么做的过程我们从来也没有过多关心。但是这往往也成了我们的弱点，面试遇到可能就是直接跳过了。所以本着有时间（面试），就好好总结一下这其中神奇的内容吧。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/vueTemplate/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-模板编译"><a href="#02-模板编译" class="headerlink" title="02 模板编译"></a>02 模板编译</h2><hr>
<p>我们知道最终的页面渲染时通过patch函数来进行的，把新的vdom与旧的vdom对比后，重新渲染页面。那么在此过程之前，vdom是怎么出现的呢？它是怎么生成的呢？最就涉及到模板编译的一系列过程了，而这个过程的总体流程如下图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/vueTemplate/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>我们所写的HTML代码，里面可能会有一些变量，有一些for循环等各种指令，或者还有一些静态节点等等。不管有什么，只要是template里面的内容，都是模板的部分。</p>
<p>中间模板编译部分就是我们要详细讲解的部分，输出之后就会转成渲染函数，渲染函数里面通过一些函数就可以生成虚拟节点树，也就是vdom树。</p>
<h2 id="03-渲染函数"><a href="#03-渲染函数" class="headerlink" title="03 渲染函数"></a>03 渲染函数</h2><hr>
<p>变成渲染函数是经过AST（抽象语法树）来形成的。但是HTML代码当中可能会存在一些静态节点，没有变量或者其他的操作，那么这个静态节点就不需要每一次都编译。所以为了提高一点点的性能，通常会在生成渲染函数之前，遍历一遍AST找出静态节点，打上静态节点的标签，假如更新虚拟DOM的时候就不会重新渲染它。</p>
<p>所以总结一下，变成渲染函数需要通过三部分：</p>
<ul>
<li>模板变成AST</li>
<li>AST遍历静态节点</li>
<li>生成渲染函数</li>
</ul>
<p>而这三部分中也对应着三个模块，在其中起着重要的作用：</p>
<ul>
<li>解析器</li>
<li>优化器</li>
<li>代码生成器</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/vueTemplate/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/vueTemplate/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a><strong>解析器</strong></h5><p>解析器的主要过程就是把模板变成AST，目标很明确，但是解析器内部又可以分成多个解析器，比如HTML解析器、文本解析器等；其中HTML解析器就是核心模块。当解析到HTML标签的时候，会识别标签的开始、结束位置以及文本等，都会触发一系列的钩子函数，然后数据通过参数的形式传递出来。</p>
<h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a><strong>优化器</strong></h5><p>我们之前说了会遍历静态节点，然后打上标签。这里的优化器就是遍历作用，检测静态节点。这种节点比较特殊，一旦渲染完成之后以后都不会重新渲染了，而是直接克隆已有的虚拟节点。通过解析器的操作，可以来提升一下性能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是静态节点，快给我打上标签吧<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a><strong>代码生成器</strong></h5><p>通过前面的几个步骤，我们就可以得到抽象语法树（AST）了，那么代码生成器的作用就是将AST通过函数的作用变成虚拟DOM节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">"alanwu"</span> @<span class="attr">click</span>=<span class="string">"go"</span>&gt;</span>冲冲冲<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;with(this)&#123;</span><br><span class="line">	return _c(</span><br><span class="line">		&#39;p&#39;,</span><br><span class="line">		&#123;</span><br><span class="line">			attrs:&#123;&quot;title&quot;:&quot;alanwu&quot;&#125;,</span><br><span class="line">			on:&#123;&quot;click&quot;:go&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		[_v(&quot;冲冲冲&quot;)]</span><br><span class="line">	)</span><br><span class="line">&#125;&#96;</span><br></pre></td></tr></table></figure>

<p>上面一段话经过处理过后会生成代码字符串，然后代码字符串经过导出之后，会把这段代码字符串以参数形式放到渲染函数里面。至此模板编译就完成了。</p>
<p>上面的 _ c 和 _ v 函数的作用分别是创建元素类型的vnode和创建文本类型的vnode。由于vnode有多种类型，所以除了这两个函数以外，虚拟DOM提供了很多种创建vnode的方法。vnode的类型有以下几种：</p>
<ul>
<li>注释节点</li>
<li>文本节点</li>
<li>元素节点</li>
<li>组件节点</li>
<li>函数式组件</li>
<li>克隆节点</li>
</ul>
<p>每一种不同的节点，虚拟DOM都提供了不一样的方法来创建vnode。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>通过对模板编译的大概解析，我们可以知道其中的过程有几个部分，其一是模板变成AST，其二是AST遍历静态节点，其三是AST变成代码字符串给渲染函数用。中间对应的三个重要部分是解析器、优化器以及代码生成器。</p>
<p><img src="/2020/03/08/vueTemplate/2.gif" alt></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>框架原理</tag>
        <tag>模板编译</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能该如何做优化</title>
    <url>/2020/03/08/optimize/</url>
    <content><![CDATA[<h2 id="前端性能该如何做优化"><a href="#前端性能该如何做优化" class="headerlink" title="前端性能该如何做优化"></a>前端性能该如何做优化</h2><blockquote>
<p>“学与思，琢与磨，知与行，相交错”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/optimize/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>当我们打开一个网页的时候，要是运行流畅，体验良好，我们很大程度会经常访问，这就有了用户。相反，如果网站卡顿，内容迟迟没有加载出来，即使你的网站质量很好，也有可能失去用户。前端如今越来越偏向于用户体验方面来，正如winter所说，前端仍然是一个比较新的岗位，有很多可以开发的地方。</p>
<p>那么我们如何让用户觉得这是一个运行流畅的网站呢？你想像淘宝那样航母级的移动应用，性能首先是放在很重要的位置，如果每一次打开都是卡顿，我想人们会变得急躁，也不愿意去用这个软件，当然有替代品的情况下。接下来我会总结一下前端到底可以在哪些方面可以做优化，其中有一些我也没有实践过。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/optimize/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-首屏与白屏"><a href="#02-首屏与白屏" class="headerlink" title="02 首屏与白屏"></a>02 首屏与白屏</h2><hr>
<p>我从用户体验上面，我讲一下如何让别人觉得你的网站性能不错，即使是一个假象。有两个方面，一个是首屏，一个是白屏。</p>
<ul>
<li><p>首屏：首屏其实是页面从开始到完全显示出来所花费的时间，这个时间越短越好，会让人觉得你的网站性能不错，短时间就加载出来。因为用户想要他所需要的信息，一秒都不愿意多等。</p>
</li>
<li><p>白屏：白屏就是网站从一个空白页面，到第一张图片或者某一部分内容开始显示的时间，这个时间也是越短越好，基本上要做到一下子就可以显示出所有内容最好。</p>
</li>
</ul>
<p>那么有哪些因素会影响这个时间呢？</p>
<ul>
<li>网络速度</li>
<li>首屏的内容比较复杂</li>
<li>浏览器没有做缓存</li>
<li>初始化加载网站所有资源</li>
</ul>
<p>首先第一个网络速度是我们的问题，假如网络速度很慢难免会出现这个问题，所以这一部分也需要网站的配合，把数据返回尽量减少，这样即使网络很慢也可以较快显示出来。</p>
<p>第二是页面内容不应该很复杂，一般打开某个官网都是介绍页面，尽量做得简洁明了，如果有图片尽量无损压缩一下或者使用svg格式的。页面也无需过于复杂，有三屏长度即可。比如Ant Design的官网就是比较简洁的，没有冗余部分，图片也是大多数是使用svg的格式。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/optimize/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/optimize/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>关于浏览器缓存部分一定要做好，因为一般首屏都会固定的页面，没有过多的交互，一般也是静态的页面，浏览器可以直接缓存下来，用户再次打开就不用重新请求资源。</p>
<p>初始化加载一部分资源即可，从用户的角度来说，一般用户不会上来就把每一个按钮的点击一遍或者每条信息都打开。所以我们只需要加载首屏信息即可，后面点击后再加载，不要占用首屏的带宽。</p>
<h2 id="03-优化方法"><a href="#03-优化方法" class="headerlink" title="03 优化方法"></a>03 优化方法</h2><hr>
<p>优化方法是多方面的内容，主要有以下几个方面：</p>
<ul>
<li>加载优化</li>
<li>CSS优化</li>
<li>图片优化</li>
<li>脚本优化</li>
<li>渲染优化</li>
</ul>
<h5 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a><strong>加载优化</strong></h5><p>加载无非也是发送HTTP请求，那么我们减少请求的发送或者压缩请求的大小即可达到效果。常见的做法有：</p>
<ol>
<li>合并CSS、JavaScript内容、图片（雪碧图）</li>
<li>启用Gzip、压缩HTML、JavaScript和CSS资源</li>
<li>异步加载第三方资源</li>
<li>使用缓存</li>
<li>避免重定向</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/optimize/4.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="CSS优化"><a href="#CSS优化" class="headerlink" title="CSS优化"></a><strong>CSS优化</strong></h5><p>常见优化做法：</p>
<ol>
<li>正确使用CSS选择符，避免嵌套</li>
<li>减少使用display属性，可用visibility代替</li>
<li>不要声明过多的font-size</li>
<li>尽量避免写内部样式</li>
<li>减少设置图片的大小</li>
</ol>
<h5 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a><strong>图片优化</strong></h5><p>图片是占用比较多的带宽资源，图片到了今天也依旧是比较大的，所以建议大家使用CSS3或者svg格式来代替传统图片，使用Webp和png类型的图片。HTTP-Archive这个网站会定期分析网络上的图片资源请求情况，我们可以看到图片的依旧是比较大的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/optimize/5.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="脚本优化"><a href="#脚本优化" class="headerlink" title="脚本优化"></a><strong>脚本优化</strong></h5><p>我们知道DOM的操作是昂贵的，因为这涉及到浏览器的解析线程和渲染线程的通信，频繁操作很产生比较大的线程通信消耗。我们常有以下方法：</p>
<ol>
<li>减少使用DOM操作</li>
<li>使用事件代理，减少事件的批量绑定</li>
<li>减少重绘和回流</li>
</ol>
<h5 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a><strong>渲染优化</strong></h5><ol>
<li>减少DOM节点的使用</li>
<li>使用css3来制作动画</li>
<li>HTML使用Viewport</li>
</ol>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>优化做好之后，我们就可以提升用户体验，留住用户。其实优化的方案远不及以上的策略，还有很多可以使用的，比如现在前端离不开的webpack打包方案，也是可以优化的，只要配置好规则即可，剩下的交给webpack来做。</p>
<p>以上只是一些原理性的建议，还要好好实践一下才可以知道哪种方法适合我们的网站，利用谷歌浏览器F12调试可以查看到底是哪一个请求消耗的时间比较多，我们就可以具体优化。</p>
<p><img src="/2020/03/08/optimize/2.gif" alt></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端性能</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：讲一下 https 和 http 的区别</title>
    <url>/2020/03/08/https/</url>
    <content><![CDATA[<h2 id="面试官：讲一下-https-和-http-的区别"><a href="#面试官：讲一下-https-和-http-的区别" class="headerlink" title="面试官：讲一下 https 和 http 的区别"></a>面试官：讲一下 https 和 http 的区别</h2><blockquote>
<p>“时无重至，华不再阳”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/https/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>因为http协议传输的数据都是以明文的形式传输的，内容没有经过加密操作，这就造成了传输不安全的情况。如果传输的数据中存在着银行卡，身份证等敏感信息，容易被他人盗取，实施诈骗。</p>
<p>所以人们就想出了一种能够安全传输的协议，https协议。该协议可以在信息传输前进行加密，加密之后接收方需要解密才可以得到信息，否则即使你截获了传输数据也无济于事。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/https/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-区别"><a href="#02-区别" class="headerlink" title="02 区别"></a>02 区别</h2><hr>
<p>那么https相比于http有哪些区别呢？是不是一种新的协议呢？其实https只是在http的基础上建立的，我们知道http协议在数据传输之前会进行TCP的三次握手，然后才会传输数据。其实https同样也会进行三次握手操作，只是在应用层和传输层之间添加了SSL/TLS层而已。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/https/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>首先我们来看一下https是怎么连接的？</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/https/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<ol>
<li>首先客户端发起请求到服务端，服务端处理后发送一个公钥给客户端</li>
<li>客户端进行验证公钥，看公钥是否有效和是否过期</li>
<li>客户端验证通过会产生随机值key，然后用公钥进行加密回传给服务端</li>
<li>服务端用私钥解密后获得客户端的随机值key</li>
<li>利用随机值key加密数据后传输给客户端</li>
<li>客户端利用key值进行解密数据</li>
<li>客户端获取真正的数据</li>
</ol>
<p>通过上图我们就应该了解了https握手阶段，其实上面不仅是SSL握手，还包括建立连接的TCP三次握手。</p>
<p>既然https能够保证安全传输，是不是所有网站都使用https协议呢？</p>
<p>其实现在最关键的就是证书问题，用于证明你的网站是安全的而不是危险的。这就需要第三方信任度高的权威机构来对网站进行证书颁发，就好比给你授权一样。比如国内我们会相信支付宝，所以愿意把钱都存进余额宝一样的道理。</p>
<p>一般来说免费的证书是比较少的，很多都要收费，而且价格不菲。只有那些大型的公司或者安保系数比较高的电商网站等需要使用，一般个人的就不需要了。所以总结一下https的不足之处：</p>
<ul>
<li>证书问题，价格高</li>
<li>握手阶段会额外消耗时间</li>
<li>SEO搜索响应慢</li>
<li>加密范围比较有限</li>
<li>若权威公司的证书泄露，一样是不安全的</li>
</ul>
<p><img src="/2020/03/08/https/1.jpg" alt></p>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>对于加密的流程，无非就是一个算法的问题，利用算法对随机值进行一个加密的操作，假如你的算法强度高，复杂性也比较高，那么没有解密方法的情况下是很难破解的。</p>
<p>算法这一块就不是我们考虑的范围了，我们只要好好理解这个过程就好了，前端工程师无需深究其中的细节部分。只要你面试的时候能够说出以上的流程，那么就没有问题了。</p>
<p><img src="/2020/03/08/https/2.gif" alt></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket 协议系统解析</title>
    <url>/2020/03/08/websocket/</url>
    <content><![CDATA[<h2 id="WebSocket-协议系统解析"><a href="#WebSocket-协议系统解析" class="headerlink" title="WebSocket 协议系统解析"></a>WebSocket 协议系统解析</h2><blockquote>
<p><strong>“</strong>读书之法, 在循序而渐进, 熟读而精思<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/websocket/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>早期的网站使用的是轮询技术，用来实现定时请求资源，由客户端发送HTTP请求。但是这种请求可能存在很长的http请求头，真正的数据可能很少，这就造成了带宽的消耗。现在比较新的技术是Comet，可以实现全双工通信，但也需要反复发出请求，而且HTTP长连接在Comet中是普遍使用的，也会消耗服务器资源。</p>
<p>所以为了解决上面的情况，HTML5定义了WebSocket协议，能够更好地节约服务器资源和带宽，并且能够实现实时通讯。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/websocket/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-webSocket"><a href="#02-webSocket" class="headerlink" title="02 webSocket"></a>02 webSocket</h2><hr>
<p>WebSocket与HTTP和HTTPS使用的是相同的TCP端口，由于这个的原因，可以绕过大多数的防火墙限制。默认是使用80端口，但是在TLS协议的时候会使用443端口。具体实现上是通过http协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以WebSocket协议和http协议是有一定的交叉关系的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/08/websocket/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>该协议最大的特点是实现了服务端推送，以往获取资源只能由客户端发起，现在服务端可以主动发起了。实现了真正的全双工通信。它有以下的优点：</p>
<ul>
<li>较少的控制开销</li>
<li>更强的实时性</li>
<li>能够保持长连接</li>
<li>更好的二进制支持</li>
<li>可以支持扩展</li>
<li>能够压缩数据提高效率</li>
<li>没有同源限制</li>
</ul>
<h2 id="03-通信原理"><a href="#03-通信原理" class="headerlink" title="03 通信原理"></a>03 通信原理</h2><hr>
<p>当客户端与服务端建立WebSocket连接，在客户端与服务端的握手过程中，客户端会先发送一个HTTP请求，包含一个Upgrade请求头来告诉服务端要升级为WebSocket协议。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9000'</span>);<span class="comment">//建立连接</span></span><br></pre></td></tr></table></figure>



<p>发送请求头：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Host: localhost:<span class="number">9000</span></span><br><span class="line">Origin: http:<span class="comment">//localhost:9000</span></span><br><span class="line">Pragma: no-cache</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Key: <span class="number">5</span>fTJ1LTuh3RKjSJxydyifQ== <span class="comment">// 与响应头 Sec-WebSocket-Accept 相对应</span></span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span>    <span class="comment">// 表示 websocket 协议的版本</span></span><br><span class="line">Upgrade: websocket    <span class="comment">// 表示要升级到 websocket 协议</span></span><br></pre></td></tr></table></figure>

<p>响应头：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: ZUip34t+bCjhkvxxwhmdEOyx9hE=</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>此时如果正常，服务器就会返回101状态码并切换为WebSocket协议建立全双工连接，后续信息将会通过这个协议进行传输。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GUID = <span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>; <span class="comment">//  一个固定的字符串</span></span><br><span class="line">accept = base64(sha1(key + GUID));    </span><br><span class="line"><span class="comment">// key 就是 Sec-WebSocket-Key 值，</span></span><br><span class="line"><span class="comment">//accept 就是 Sec-WebSocket-Accept 值</span></span><br></pre></td></tr></table></figure>

<p>Sec-WebSocket-Key：客户端随机生成的一个base64编码</p>
<p>Sec-WebSocket-Accept：服务端经过算法处理后回传给客户端</p>
<p>Connection和Upgrade字段告诉服务器，客户端发起的是WebSocket协议请求</p>
<p>最后一步客户端拿到服务端的值之后使用相同算法进行解码之后，跟服务端的进行对比，如果一致则成功连接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectWebsocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9000'</span>);</span><br><span class="line">    <span class="comment">// 监听连接成功</span></span><br><span class="line">    ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接服务端WebSocket成功'</span>);</span><br><span class="line">        <span class="comment">// send 方法给服务端发送消息</span></span><br><span class="line">        ws.send(<span class="built_in">JSON</span>.stringify(msgData));    </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务端消息(接收消息)</span></span><br><span class="line">    ws.onmessage = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> message = <span class="built_in">JSON</span>.parse(msg.data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'收到的消息：'</span>, message)</span><br><span class="line">        elUl.innerHTML += <span class="string">`&lt;li class="b"&gt;小秋：<span class="subst">$&#123;message.content&#125;</span>&lt;/li&gt;`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接失败</span></span><br><span class="line">    ws.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接失败，正在重连...'</span>);</span><br><span class="line">        connectWebsocket();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接关闭</span></span><br><span class="line">    ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接关闭'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">connectWebsocket();</span><br></pre></td></tr></table></figure>



<h2 id="04-心跳包"><a href="#04-心跳包" class="headerlink" title="04 心跳包"></a>04 心跳包</h2><hr>
<p>当连接后长时间不进行通信就可能会出现连接不稳定的情况，那么就会影响数据的传输，比如在聊天室的信息可能出现不同步的情况。所以客户端会定时发送一个包告诉服务器我连接正常，服务器也会回应正常。称之为心跳包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;    ws.send(<span class="string">'这是一条心跳包消息'</span>);&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>



<h2 id="05-应用场景"><a href="#05-应用场景" class="headerlink" title="05 应用场景"></a>05 应用场景</h2><hr>
<p>WebSocket协议多用于实时通讯方面的场景，对实时数据要求比较高的，可以应用于以下的场景：</p>
<ul>
<li>即时聊天通信</li>
<li>多玩家游戏</li>
<li>在线协同编辑/编辑</li>
<li>实时数据流的拉取与推送</li>
<li>体育/游戏实况</li>
<li>实时地图位置</li>
</ul>
<h2 id="06-与HTTP的异同"><a href="#06-与HTTP的异同" class="headerlink" title="06 与HTTP的异同"></a>06 与HTTP的异同</h2><hr>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><strong>相同点</strong></h5><ul>
<li>都是基于TCP的应用层协议；</li>
<li>都使用Request/Response模型进行连接的建立；</li>
<li>在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码；</li>
<li>都可以在网络中传输数据。</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h5><ul>
<li>WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用；</li>
<li>WS的连接不能通过中间人来转发，它必须是一个直接连接；</li>
<li>WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据；</li>
<li>WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息；</li>
<li>WS的数据帧有序。</li>
</ul>
<h2 id="07-小结"><a href="#07-小结" class="headerlink" title="07 小结"></a>07 小结</h2><hr>
<p>WebSocket可写的东西还挺多，比如WebSocket扩展。客户端、服务端之间是如何协商、使用扩展的。WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。理论还是要联系实际才可以。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li>WebSocket教程 阮一峰博客</li>
<li>深入剖析WebSocket的原理</li>
<li>WebSocket详解（四）：刨根问底HTTP与WebSocket的关系</li>
<li>维基百科 WebSocket</li>
<li>WebSocket 原理浅析与实现简单聊</li>
</ul>
<p><img src="/2020/03/08/websocket/2.gif" alt></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>网络协议</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>带你一文玩转CSS滤镜</title>
    <url>/2020/03/07/cssFilter/</url>
    <content><![CDATA[<h2 id="带你一文玩转CSS滤镜"><a href="#带你一文玩转CSS滤镜" class="headerlink" title="带你一文玩转CSS滤镜"></a>带你一文玩转CSS滤镜</h2><blockquote>
<p> 给背景图披上不一样的衣服</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/cssFilter/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>随着新技术的发展，越来越多的css属性被浏览器所支持，而且更新速度也十分地快。css属性的增多，可以使网页的颜色多样化，更加的丰富。对用户体验上来说都是一件好事，用户的接受度会普遍增加。</p>
<p>在2014年底，css滤镜已经被列入W3C的滤镜效果模块工作草案。接下来介绍不同的滤镜会有什么样的效果：</p>
<ul>
<li>blur</li>
<li>brightness</li>
<li>contrast</li>
<li>grayscale</li>
<li>hue-rotate</li>
<li>invert</li>
<li>opacity</li>
<li>saturate</li>
<li>sepia</li>
</ul>
<h2 id="02-属性效果"><a href="#02-属性效果" class="headerlink" title="02 属性效果"></a>02 属性效果</h2><hr>
<p>我们使用两个不一样的图片，来验证属性的效果。这是一开始的未经过处理的图片和背景图。</p>
<img src="/2020/03/07/cssFilter/1.jpg" style="zoom:50%;">



<h5 id="blur"><a href="#blur" class="headerlink" title="blur"></a><strong>blur</strong></h5><p>blur可以给元素添加高斯模糊，只要写入模糊半径参数即可。半径可以使用css的任何单位，可以使用px、em、rem甚至cm。半径越大，滤镜效果就会强，但是不能使用百分比来表示，不然浏览器会认为是无效值，默认应用none。</p>
<img src="/2020/03/07/cssFilter/2.jpg" style="zoom:50%;">



<h5 id="brightness"><a href="#brightness" class="headerlink" title="brightness"></a><strong>brightness</strong></h5><p>亮度brightness滤镜接受百分比值。当亮度为100%时就会是原来未经处理的颜色，属性值可以在0%~100%之间调整，减少到0就会变成黑色。</p>
<img src="/2020/03/07/cssFilter/3.jpg" style="zoom:50%;">



<h5 id="contrast"><a href="#contrast" class="headerlink" title="contrast"></a><strong>contrast</strong></h5><p>对比度contrast可以使用百分比单位，当对比度为0时，高亮部分和阴影部分的对比就比较弱，当对比度超过100%时就会比较强烈。</p>
<img src="/2020/03/07/cssFilter/1.webp" style="zoom:50%;">



<h5 id="grayscale"><a href="#grayscale" class="headerlink" title="grayscale"></a><strong>grayscale</strong></h5><p>灰度滤镜可以给背景蒙上一层灰色，当灰度值达到100%时，整个元素就会变成灰色。当国家纪念日比如南京大屠杀纪念日，很多网站都会变成灰色，就是把背景加上100%的灰度值即可。</p>
<img src="/2020/03/07/cssFilter/4.jpg" style="zoom:50%;">



<h5 id="hue-rotate"><a href="#hue-rotate" class="headerlink" title="hue-rotate"></a><strong>hue-rotate</strong></h5><p>色调旋转可以使颜色发生旋转，参数为旋转度数。</p>
<img src="/2020/03/07/cssFilter/5.jpg" style="zoom:50%;">



<h5 id="invert"><a href="#invert" class="headerlink" title="invert"></a><strong>invert</strong></h5><p>反色invert可以使颜色发生反转。当你从0开始到50%，颜色会慢慢变暗。从50%到100%颜色反转并逐渐加深。</p>
<img src="/2020/03/07/cssFilter/6.jpg" style="zoom:50%;">



<h5 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a><strong>opacity</strong></h5><p>透明度，我们已经用的比较多了，元素参数可以使用数字或者百分比来表示。</p>
<img src="/2020/03/07/cssFilter/7.jpg" style="zoom:50%;">

<h5 id="saturate"><a href="#saturate" class="headerlink" title="saturate"></a><strong>saturate</strong></h5><p>饱和度滤镜，参数使用百分比来表示，超过100%会让饱和度过高。</p>
<img src="/2020/03/07/cssFilter/8.jpg" style="zoom:50%;">

<h5 id="sepia"><a href="#sepia" class="headerlink" title="sepia"></a><strong>sepia</strong></h5><p>褐色。可以使元素蒙上一层褐色，与其他元素类似都是使用百分比来表示。</p>
<img src="/2020/03/07/cssFilter/9.jpg" style="zoom:50%;">



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>如今CSS可以用来做更多的事情了，而且渲染效率也是非常高的。比如我们之前实现动画都会使用JS来写，现在就可以使用css动画来做了，关于这一块下次再写。大家可以自行实现一下上面的滤镜效果。</p>
<p><img src="/2020/03/07/cssFilter/2.gif" alt></p>
]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>滤镜</tag>
        <tag>HTML/CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的可靠性传输是如何保证的</title>
    <url>/2020/03/07/howToEnsureTcp/</url>
    <content><![CDATA[<h2 id="TCP的可靠性传输是如何保证的"><a href="#TCP的可靠性传输是如何保证的" class="headerlink" title="TCP的可靠性传输是如何保证的"></a>TCP的可靠性传输是如何保证的</h2><blockquote>
<p>系统总结TCP连接中，它是如何保证数据的传输</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>我们之前介绍过TCP的连接比UDP连接复杂，也比较安全，但是我们想知道它是如何保证这些数据的安全的？数据的发送先后有什么秘诀呢？接下来我就一一去总结这些细节性的问题。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-保证数据安全的方法"><a href="#02-保证数据安全的方法" class="headerlink" title="02 保证数据安全的方法"></a>02 保证数据安全的方法</h2><hr>
<p>TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。</p>
<h5 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a><strong>检验和</strong></h5><p>通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="序列号-确认应答"><a href="#序列号-确认应答" class="headerlink" title="序列号/确认应答"></a><strong>序列号/确认应答</strong></h5><p>这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>上述过程中，只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。</p>
<h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a><strong>超时重传</strong></h5><p>超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。那么我们该如何确认这个时间值呢？</p>
<p>我们知道，一来一回的时间总是差不多的，都会有一个类似于平均值的概念。比如发送一个包到接收端收到这个包一共是0.5s，然后接收端回发一个确认包给发送端也要0.5s，这样的两个时间就是RTT（往返时间）。然后可能由于网络原因的问题，时间会有偏差，称为抖动（方差）。</p>
<p>从上面的介绍来看，超时重传的时间大概是比往返时间+抖动值还要稍大的时间。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>但是在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。</p>
<h5 id="最大消息长度"><a href="#最大消息长度" class="headerlink" title="最大消息长度"></a><strong>最大消息长度</strong></h5><p>在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a><strong>滑动窗口控制</strong></h5><p>我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。所以我们就想着能不能不用等待确认包就发送下一个数据包呢？这就提出了一个滑动窗口的概念。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/6.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。这个机制的实现就是使用了大量的缓冲区，通过对多个段进行确认应答的功能。通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了就从缓冲区里面删除数据。</p>
<p>在窗口之外的数据就是还未发送的和对端已经收到的数据。那么发送端是怎么样判断接收端有没有接收到数据呢？或者怎么知道需要重发的数据有哪些呢？通过下面这个图就知道了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/7.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>如上图，接收端在没有收到自己所期望的序列号数据之前，会对之前的数据进行重复确认。发送端在收到某个应答包之后，又连续3次收到同样的应答包，则数据已经丢失了，需要重发。</p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h5><p>窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。</p>
<p>此处引入一个拥塞窗口：</p>
<p>发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。</p>
<p>慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。</p>
<p><img src="/2020/03/07/howToEnsureTcp/8.png" alt></p>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>其实上面所说的知识在学校也学过，但是重来不会认真对待这些看似没有用的知识，所以现在就好好总结一下了。对于网络优化的部分可以参照上面的方法来进行优化，可以利用这些方法提供高速、可靠的通信服务。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li>图解TCP/IP</li>
<li>TCP是如何保证数据的传输</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/07/howToEnsureTcp/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>系统总结ES6的promise对象</title>
    <url>/2020/03/06/promise/</url>
    <content><![CDATA[<h2 id="系统总结ES6的promise对象"><a href="#系统总结ES6的promise对象" class="headerlink" title="系统总结ES6的promise对象"></a><strong>系统总结ES6的promise对象</strong></h2><blockquote>
<p><strong>“</strong> ES6的异步解决方案，面试必考题之一<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/promise/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>由于同步的写法造成很多的问题，我们最早使用的异步解决方案可能就是jQuery的Ajax的请求函数了，其中提供了同步和异步的写法，但是我们还是会觉得诸多不便，例如一不小心就可能会造成回调地狱的问题，所以ES6就提出来一种更为优雅的写法——promise对象。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/promise/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-promise"><a href="#02-promise" class="headerlink" title="02 promise"></a>02 promise</h2><hr>
<p>在阮一峰老师的ES6入门标准中说到，所谓promise就是一个容器，里面保存着某个未来才会结束的事件（通常是是一个异步事件）。它有两个特点：</p>
<ul>
<li><strong><font color="orange">状态不受外界影响</font></strong>：拥有三种状态（Pending、Fullfilled、Rejected）。状态只取决于异步执行结果，其他过程无法改变这个状态。</li>
<li><strong><font color="orange">状态改变不会再变</font></strong>：初始状态为Pending状态，它只可以变成Fullfill或者变成Rejected，但是一旦发生改变就不会再变。</li>
</ul>
<p>promise可以使得异步操作的写法像同步写法一样优雅，代码可读性更高。但是缺点就是中途无法取消promise，一旦新建就会执行，假如没有设置回调函数，Promise内部如果出现错误不会反应到外部。</p>
<h5 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span>(success)&#123;</span><br><span class="line">		resolve(value);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		reject(error)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>Promise构造函数可以接收两个参数，分别是<strong><font color="orange">resolve和reject</font></strong>，这两个函数有JavaScript内部提供。异步操作成功的时候就会走resolve这边，失败的话就走reject这边。除此之外，可以使用then方法分别对resolved或者rejected状态的结果进行回调操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//success</span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">	<span class="comment">//error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="03-then-和catch方法"><a href="#03-then-和catch方法" class="headerlink" title="03 then()和catch方法"></a>03 then()和catch方法</h2><hr>
<h5 id="then"><a href="#then" class="headerlink" title="then()"></a><strong>then()</strong></h5><p>then方法可以接收两个函数参数，第一个是异步操作结果变成resolved的时候调用，第二个是结果变成rejected的时候使用。那有同学可能会问，第二个函数参数与catch错误捕获函数有什么区别呢？</p>
<p>我们首先来区别几个重要的概念，reject是异步结果错误的时候抛出的，但是catch是用来捕获异常的。跟传统的（try/catch）不同的是，如果没有使用catch方法指定错误处理测回调函数，那么Promise对象抛出的错误不会传递到外层代码，不会有任何反应。</p>
<p><strong><font color="orange">Promise对象的错误具有“冒泡”的性质，会一直向后传递，直到被catch捕获为止</font></strong>。错误总会被下一个catch语句捕获。举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(’ oh  no ’, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(’ carry  on ’);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码由于异步操作结果变成了resolve状态，那么就不会走catch那里，而是直接走then函数了，但是一旦then函数里面有错误抛出，那么该错误就永远不会被捕获，也没有处理。</p>
<h5 id="catch"><a href="#catch" class="headerlink" title="catch()"></a><strong>catch()</strong></h5><p>then的第二个参数和catch捕获错误信息的时候会就近原则，如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/promise/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/promise/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>通过上述代码可知，promise对象里面抛出的错误，then的第二个函数参数是可以捕获的。<strong><font color="orange">但是then的第一个函数参数抛出的错误，第二个函数参数是捕获不了的，只能通过catch函数来捕获</font></strong>。</p>
<h2 id="04-all-race-方法"><a href="#04-all-race-方法" class="headerlink" title="04 all()/race()方法"></a>04 all()/race()方法</h2><hr>
<h5 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a><strong>all方法</strong></h5><p>Promise.all方法用于接收多个promise对象包装成一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p &#x3D; Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>Promise.all方法有两种情况：</p>
<ul>
<li>p最终的状态由p1，p2，p3共同决定，只有三个promise实例的状态变成Fullfill，整个p才会变成Fullfill。然后p1，p2，p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要其中一个变成rejected，p的状态就变成rejected，此时第一个rejected的实例的返回值就会传递给p的回调函数。</li>
</ul>
<h5 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a><strong>race方法</strong></h5><p>Promise.race方法同样也是接收多个promise实例，然后将多个promise实例包装成新的Promise实例。但是与all方法不同的是：</p>
<ul>
<li>只要p1，p2，p3中有一个实例率先改变状态，那么真个p的状态的就跟着改变。</li>
</ul>
<h2 id="05-resolve-reject-方法"><a href="#05-resolve-reject-方法" class="headerlink" title="05 resolve()/reject()方法"></a>05 resolve()/reject()方法</h2><hr>
<h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a><strong>Promise.resolve()</strong></h5><p>Promise.resolve()方法可以把对象转成Promise对象。该方法可以传入的参数类型有四种：</p>
<ul>
<li>Pormise实例：不做修改，直接返回实例</li>
<li>thenable对象：转成promise实例，并执行相应的方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  thenable  = &#123;</span><br><span class="line">	then : <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">	resolve (<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span>  p1=  <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)  </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log ( value );  <span class="comment">//  42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>不具有then方法的对象或者不是对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  p = <span class="built_in">Promise</span>.resolve(’Hello’);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不带有任何参数：直接返回一个Resolved状态的Promise对象。</li>
</ul>
<h5 id="Promise-rejected"><a href="#Promise-rejected" class="headerlink" title="Promise.rejected()"></a><strong>Promise.rejected()</strong></h5><p>该方法返回一个promise实例，状态为Rejected。下面的代码中，Promise.reject()方法的参数会原封不动地作为reject的理由变成后续方法的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  thenable  = &#123;</span><br><span class="line">	then  (resolve,  reject)  &#123;</span><br><span class="line">		reject(<span class="string">"Error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Promsie.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e===thenable) <span class="comment">//true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="06-done-和finally"><a href="#06-done-和finally" class="headerlink" title="06 done()和finally()"></a>06 done()和finally()</h2><hr>
<h5 id="done"><a href="#done" class="headerlink" title="done()"></a><strong>done()</strong></h5><p>上面我们说到Promsie的实例抛出的错误，catch()方法可以进行捕获，但是大家有没有想过假如catch方法抛出了错误会怎么样呢？假如最后一个catch()方法抛出错误的话，理论上是无法捕获的。但是done方法出来了，它在回调链的尾端，保证抛出任何可能出现的错误。</p>
<p>done方法可以像then方法那样使用，提供了Fullfill和Rejected状态的回调函数，可以捕获可能出现的任何错误并向全局抛出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled, onRejected</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.then(onFullfilled, onRejected)</span><br><span class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">throw</span> reason&#125;, <span class="number">0</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="finally"><a href="#finally" class="headerlink" title="finally()"></a><strong>finally()</strong></h5><p>finally()方法用于指定不管Promise对象最后状态如何都会去执行这个方法。但是与done()不一样的是，它接受一个普通的回调函数作为参数。</p>
<h2 id="07-小结"><a href="#07-小结" class="headerlink" title="07 小结"></a>07 小结</h2><hr>
<p>Promise对象是ES6中很重要的内容，前端工程师是必须掌握的。它解决了异步回调的问题，使得异步执行的代码像同步一样写法，可读性更高。实例提供的多种方法在实际的业务中非常常见，也很方便使用。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li>阮一峰 ES6入门标准（第三版）</li>
</ul>
<p><img src="/2020/03/06/promise/2.gif" alt></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
        <tag>promise</tag>
        <tag>异步解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现浏览器不同Tab页面通信</title>
    <url>/2020/03/06/tabOrigin/</url>
    <content><![CDATA[<h2 id="如何实现浏览器不同Tab页面通信"><a href="#如何实现浏览器不同Tab页面通信" class="headerlink" title="如何实现浏览器不同Tab页面通信"></a>如何实现浏览器不同Tab页面通信</h2><blockquote>
<p> 闻道有先后，术业有专攻</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/tabOrigin/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>我们知道，浏览器打开一个Tab页面就会打开一个进程，同时会开启若干个线程，这就涉及到进程之间通信的问题。一般来说单纯使用HTML5的相关特性是无法完成的，我们需要其他的方法来实现。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/tabOrigin/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-通信方法"><a href="#02-通信方法" class="headerlink" title="02 通信方法"></a>02 通信方法</h2><hr>
<p>我们可以分几种情况来讨论这个问题。</p>
<p><strong>1、postMessage</strong></p>
<p>页面A通过window.open方法打开另一个页面B，或者B页面通过iframe的形式嵌入A页面，这种情况比较简单，可以使用HTML5的API来完成通信。我们知道window是一个全局对象，前提是页面A或者页面B可以获取另一个页面的window对象，完成单向通信。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//B页面</span></span><br><span class="line"><span class="built_in">window</span>.addEventListner(<span class="string">'message'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;data,source,origin&#125; = e;</span><br><span class="line">    source.postMessage(<span class="string">'message echo'</span>,<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>postMessage的第一个参数为消息实体，它是一个结构化对象，即可以通过“JSON.stringify和JSON.parse”函数还原的对象；第二个参数为消息发送范围选择器，设置为“/”意味着只发送消息给同源的页面，设置为“*”则发送全部页面。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/tabOrigin/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>2、localStorage</strong></p>
<p>此方法适用于同源范围的通信，因此可以通过共享localStorage的方式进行通信，通过约定localStorage的某一个名，然后共享方式通信。通过window对象侦听storage事件，会侦听localStorage对象的变化事件（包括item的添加、修改和删除）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A 页面</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"storage"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.key == <span class="string">'message'</span>) &#123;</span><br><span class="line">        <span class="comment">// removeItem同样触发storage事件，此时ev.newValue为空</span></span><br><span class="line">        <span class="keyword">if</span>(!ev.newValue)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(ev.newValue);</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'message'</span>,<span class="built_in">JSON</span>.stringify(message));</span><br><span class="line">    localStorage.removeItem(<span class="string">'message'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送消息给B页面</span></span><br><span class="line">sendMessage(<span class="string">'this is message from A'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//B 页面</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"storage"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.key == <span class="string">'message'</span>) &#123;</span><br><span class="line">        <span class="comment">// removeItem同样触发storage事件，此时ev.newValue为空</span></span><br><span class="line">        <span class="keyword">if</span>(!ev.newValue)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(ev.newValue);</span><br><span class="line">        <span class="comment">// 发送消息给A页面</span></span><br><span class="line">        sendMessage(<span class="string">'message echo from B'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'message'</span>,<span class="built_in">JSON</span>.stringify(message));</span><br><span class="line">    localStorage.removeItem(<span class="string">'message'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/tabOrigin/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p><strong>3、BroadcastChannel</strong></p>
<p>这种方法与localStorage的思想一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.html</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> BroadcastChannel(<span class="string">'tabs'</span>)</span><br><span class="line">channel.onmessage = <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// evt.data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.html</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> BroadcastChannel(<span class="string">'tabs'</span>)</span><br><span class="line">channel.postMessage(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>



<p><strong>4、WebSocket</strong></p>
<p>WebSocket可以实现全双工通信，自然可以实现多个标签页之间的通信的问题。</p>
<p>WebSocket连接必须由浏览器发起，特点：</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信。</p>
<p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p>
<p><strong>5、cookie+setInterval</strong></p>
<p>在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。</p>
<p>由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优雅。</p>
<p><strong>6、sharedWorker</strong></p>
<p>SharedWorker本身并不是为了解决通讯需求的，它的设计初衷应该是类似总控，将一些通用逻辑放在SharedWorker中处理，不过因为也能实现通讯。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.html</span></span><br><span class="line"><span class="keyword">var</span> sharedworker = <span class="keyword">new</span> SharedWorker(<span class="string">'worker.js'</span>)</span><br><span class="line">sharedworker.port.start()</span><br><span class="line">sharedworker.port.onmessage = <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// evt.data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.html</span></span><br><span class="line"><span class="keyword">var</span> sharedworker = <span class="keyword">new</span> SharedWorker(<span class="string">'worker.js'</span>)</span><br><span class="line">sharedworker.port.start()</span><br><span class="line">sharedworker.port.postMessage(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> ports = []</span><br><span class="line">onconnect = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> port = e.ports[<span class="number">0</span>]</span><br><span class="line">  ports.push(port)</span><br><span class="line">  port.onmessage = <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">    ports.filter(<span class="function"><span class="params">v</span> =&gt;</span> v!== port) <span class="comment">// 此处为了贴近其他方案的实现，剔除自己</span></span><br><span class="line">    .forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.postMessage(evt.data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>其实页面之间的通信用的不是很多，但是在技术发展的同时我们都要关注一下，特别是为什么能够进行通信，每一个Tab背后都是由什么组成的，这些了解清楚最好。还有关于进程和线程的区别，知道这些才会更好的理解。</p>
<p><strong><font color="green">参考文章</font></strong>：</p>
<ul>
<li>Communication between tabs or windows</li>
<li>跨浏览器tab页面的通信解决方案尝试</li>
<li>浏览器多个标签页之间的通信</li>
<li>跨页面通信的各种姿势</li>
</ul>
<p><img src="/2020/03/06/tabOrigin/2.gif" alt></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>跨域</tag>
        <tag>通信</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>解读进程与线程区别、进程间通信</title>
    <url>/2020/03/06/process/</url>
    <content><![CDATA[<h2 id="解读进程与线程区别、进程间通信"><a href="#解读进程与线程区别、进程间通信" class="headerlink" title="解读进程与线程区别、进程间通信"></a>解读进程与线程区别、进程间通信</h2><blockquote>
<p> 把简单的问题回答得不简单，谓之深度</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>记得大学学习操作系统的时候，心里就想着这是啥子东西，然后面试的时候我们就想着为啥我没有学过这东西。当你确定好方向之后一般就很少去关注方向之外的东西，就比如我选择了前端开发，就很少关注操作系统和计算机基础的东西，但是面试却常考这些似乎比较偏僻的知识点。</p>
<p>我们常说一面面试会考你基础，这个基础可不是你方向的基础知识，而是接近底层的计算机基础。我记得第一次面试的时候就是百度的面试官，没有过多问我前端方向的知识，而是问我计算机的寻址方式，操作系统的I/O操作。说实话那些没有好好复习真的不会。所以我们对基础的东西一定要好好准备，说不定哪一天的用上了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-进程与线程"><a href="#02-进程与线程" class="headerlink" title="02 进程与线程"></a>02 进程与线程</h2><hr>
<p>进程是系统进行资源分配和调度的一个单位，是操作系统结构的基础；线程是CPU调度和分配的基本单位，它包含于进程中，是进程中实际运作的单位。一个进程可以包含多个线程，分别执行不同的任务。</p>
<p><strong><font color="orange">进程和线程的区别</font></strong>：</p>
<ul>
<li>定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。（进程可以创建多个线程）</li>
<li>角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位。</li>
<li>资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。</li>
<li>独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。</li>
<li>开销方面。进程切换的开销较大。线程相对较小。</li>
</ul>
<p>阮一峰老师在博客中写到：计算机就是一个巨大的工厂，工厂内有很多车间，但是电力只能每次供给一个车间。也就是说单个CPU一次只能执行一个任务。而进程就是一个车间，里面有很多工人负责不同的任务，就是线程。</p>
<p>车间的空间是工人共享的，这就表明了线程共享所在进程的地址空间和资源。但是进程中某些资源是不能同时共享的，比如卫生间一次只能进一个人，当该资源正在使用时其他线程就不能使用。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>为什么要引入线程呢？</p>
<ul>
<li><strong>应用的需要：</strong>比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。</li>
<li><strong>开销的考虑：</strong>在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件）</li>
<li><strong>性能的考虑：</strong>多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。</li>
</ul>
<h2 id="03-进程通信"><a href="#03-进程通信" class="headerlink" title="03 进程通信"></a>03 进程通信</h2><hr>
<p>既然计算机是一个巨大的工厂，那么车间之间肯定要产生通信的情况。依照这种想法，那在车间之间开辟一个通道即可，这就是管道通信。</p>
<p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。管道通信是半双工通信，数据只能单向流动。</p>
<p><strong>1、管道通信</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>2、共享内存通信</strong></p>
<p>共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。</p>
<p>进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址。但是并未提供同步机制，需要借助信号量来限制访问，不然会导致数据混乱。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p><strong>3、消息队列通信</strong></p>
<p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>4、信号量通信</strong></p>
<p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。</p>
<p>临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来协调进程对共享资源的访问的。</p>
<p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：</p>
<p>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行。</p>
<p>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1。</p>
<p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>5、Socket通信</strong></p>
<p>在同一台计算机，进程之间上面提到的通信，如果是不同的计算机呢？网络上不同的计算机，也可以通信，那么就得使用网络套接字（socket）。socket就是在不同计算机之间进行通信的一个抽象。它工作于TCP/IP协议中应用层和传输层之间的一个抽象。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/process/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>客户端的过程比较简单，创建 Socket，连接服务器，将 Socket 与远程主机连接，发送数据，读取响应数据，直到数据交换完毕，关闭连接，结束 TCP 对话。</p>
<p>服务端先初始化 Socket，建立流式套接字，与本机地址及端口进行绑定，然后通知 TCP，等待来自客户端的连接。如果这时客户端与服务器建立了连接，客户端发送数据请求，服务器接收请求并处理请求，然后把响应数据发送给客户端，客户端读取数据，直到数据交换完毕。最后关闭连接，交互结束。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>作为前端很有必要了解一下网络方面的知识，这也是计算机通用的基础。无论互联网还是内网，通信都是要经过连接后才能进行通信。对每一个知识背后的原理了解清楚，解决问题的能力就多一点。</p>
<p><strong><font color="green">参考文章</font></strong>：</p>
<ul>
<li>阮一峰 进程与线程的一个简单解释</li>
<li>Socket通信原理</li>
<li>进程间通信8种方式详解</li>
<li>进程与线程的区别</li>
</ul>
<p><img src="/2020/03/06/process/2.gif" alt></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>线程</tag>
        <tag>计算机基础</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>一次看懂如何解决跨域</title>
    <url>/2020/03/06/crossOrigin/</url>
    <content><![CDATA[<h2 id="一次看懂如何解决跨域"><a href="#一次看懂如何解决跨域" class="headerlink" title="一次看懂如何解决跨域"></a><strong>一次看懂如何解决跨域</strong></h2><blockquote>
<p> 人生如逆旅，我亦是行人</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/crossOrigin/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端在调试的过程中，难免会出现跨域的问题，由于前后端分离的开发模式，前端开发部署的代码与服务器后端代码有可能不在同一个域上，不同域之间访问是会被浏览器拦截的。我们要明白一个点就是，浏览器是可以发起请求，但是结果被浏览器拦截，此谓跨域。接下来我就总结一下如何解决这一问题。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/crossOrigin/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-跨域方法"><a href="#02-跨域方法" class="headerlink" title="02 跨域方法"></a>02 跨域方法</h2><hr>
<p>了解了跨域的产生情况之后，我们就可以联合客户端和服务端来进行解决。跨域解决主要有以下几种：</p>
<ul>
<li>JSONP</li>
<li>CORS</li>
<li>Nginx代理</li>
<li>document.domain</li>
<li>window.name</li>
<li>postMessage+iframe</li>
</ul>
<p><strong>1、JSONP</strong></p>
<p>我们知道写HTML代码的时候，加入图片链接就不会有获取不到图片的问题。这是因为图片资源并没有进行ajax请求，而且script标签是没有同源策略的，可以进行资源请求，可以说是一个前端设计的漏洞。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.动态创建 script </span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://test.com/json?callback=handleResponse'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script,<span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>

<p>利用script标签立即下载并执行的特性，我们就可以在回调函数中拿到返回来的数据。那么是不是所有的情况都可以呢？显然不是的。虽然实现是比较简单的操作，但是有缺点：</p>
<ol>
<li>仅限于GET请求</li>
<li>有安全问题，万一有恶意代码返回，前端无法阻止</li>
<li>无法检测请求是否成功</li>
</ol>
<p><strong>2、CORS</strong></p>
<p>CORS是跨域资源共享(Cross-origin resource sharing)</p>
<p>要想利用这个技术关键是在于服务端，设置返回的Access-Control-Allow-Origin响应头允许跨域操作，发送请求时有两种情况：</p>
<ul>
<li>简单请求</li>
<li>复杂请求</li>
</ul>
<p>①简单请求</p>
<p>当使用以下方法之一：</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
<p>Content-Type的值为以下之一：</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>才会发起简单请求，浏览器判断是简单请求的话就会在请求头添加origin字段，值是发起请求的所在的源。服务端收到请求后会判断origin是否在自己的许可范围，如果不在就拒绝，如果在就会有以下的响应头添加：</p>
<ul>
<li>Access-Control-Allow-Origin（必选）：告诉客户端我接受请求，值为origin的值，若允许所有源请求就会返回 *。</li>
<li>Access-Control-Allow-Credentials（可选）：告诉浏览器发送请求时携带Cookie，true表示允许false表示禁止。</li>
<li>Access-Control-Expose-Headers（可选）：额外给客户端返回的头部字段。</li>
</ul>
<p>②复杂请求</p>
<p>复杂请求会有两次，第一次是发送一个预检请求，使用的方法是options，询问服务器是否允许我进行跨域请求资源。并且允许客户端自定义请求头的类型，询问服务器是否允许。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//test.com</span></span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: Custom-Header1,Custom-Header2</span><br><span class="line">Host: target.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>然后服务器会进行验证，还会在响应头进行说明允许你的请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span><span class="number">.61</span>（Unix）</span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//test.com</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: Custom-Header1,Custom-Header2</span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br><span class="line">Content-type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>

<ul>
<li>Access-Control-Allow-Origin：告诉客户端，允许你这个源的请求</li>
<li>Access-Control-Allow-Methods：告诉客户端，服务端允许的跨域 AJAX 请求的类型，也可进行 GET 或者 POST 请求</li>
<li>Access-Control-Allow-Headers：告诉客户端，服务端允许的发送请求时的自定义请求头</li>
<li>Access-Control-Max-Age: 告诉客户端预检请求的有效期，省去了多次的预检请求。也就是说，1728000 秒内你可以直接发送真正的 AJAX 请求，不用每次询问</li>
</ul>
<p><strong>3、Nginx代理</strong></p>
<p>将nginx目录下的nginx.conf修改，通过反向代理的方式来实现跨域请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># /所有以apis开头发起的请求会被分发到myserver</span><br><span class="line">location ^~ <span class="regexp">/apis/</span> &#123;</span><br><span class="line">     proxy_pass http:<span class="comment">//myserver; # 负载均衡名，写你请求的服务器地址</span></span><br><span class="line">     proxy_set_header X-real-ip $remote_addr;</span><br><span class="line">     proxy_set_header Host $http_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>4、document.domain</strong></p>
<p>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</p>
<p>只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域</p>
<p><strong>5、window.name</strong></p>
<p>window.name有一个奇妙的性质，页面如果设置了window.name，那么在不关闭页面的情况下，即使进行了页面跳转location.href=…，这个window.name还是会保留。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开必应 https://www.bing.com/</span></span><br><span class="line"><span class="comment">// 打开控制台</span></span><br><span class="line">&gt; <span class="built_in">window</span>.name</span><br><span class="line"><span class="string">""</span></span><br><span class="line">&gt; <span class="built_in">window</span>.name=<span class="string">'test'</span>;</span><br><span class="line"><span class="string">"test"</span></span><br><span class="line">&gt; location.href=<span class="string">'http://www.google.com'</span>;</span><br><span class="line"><span class="string">"http://www.google.com"</span></span><br><span class="line">Navigated to https:<span class="comment">//www.google.com/</span></span><br><span class="line">&gt; <span class="built_in">window</span>.name</span><br><span class="line"><span class="string">"test"</span></span><br></pre></td></tr></table></figure>



<p><strong>6、postMessage+iframe</strong></p>
<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">   &lt;div id=<span class="string">"color"</span>&gt;Frame Color&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">   &lt;iframe id=<span class="string">"child"</span> src=<span class="string">"http://b.com/b.html"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'getcolor'</span>,<span class="string">'http://b.com'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<p>postMessage(data,origin)方法接受两个参数：</p>
<ul>
<li>data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化</li>
<li>origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以把参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ul>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>前端跨域方法其实还有很多种，但是常用的就这么一两种，个人觉得Nginx代理还很不错，配置简单还不用考虑很多事情。能够总结多种方法，遇到问题就可以考虑多一种解决方法，可能在面试中就可以多一次机会，懂得多没有什么不好，共勉。</p>
<p><strong><font color="green">参考文章</font></strong>：</p>
<ul>
<li>掘金小册前端面试之道</li>
<li>知乎《JSONP的工作原理》</li>
<li>AJAX与跨域通信</li>
</ul>
<p><img src="/2020/03/06/crossOrigin/2.gif" alt></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>跨域</tag>
        <tag>JavaScript</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript事件循环机制</title>
    <url>/2020/03/06/eventLoop/</url>
    <content><![CDATA[<h2 id="JavaScript事件循环机制"><a href="#JavaScript事件循环机制" class="headerlink" title="JavaScript事件循环机制"></a>JavaScript事件循环机制</h2><blockquote>
<p> 菩提本无树，明镜亦非台</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/eventLoop/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>事件循环机制在前端的面试中可谓是必问的一道题目，这道题目涉及JS的执行顺序问题，可能有些同学执行JS代码的时候老是会出错，执行顺序不对的情况。所以我就借这一篇文章好好深入了解一下。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/eventLoop/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-事件循环"><a href="#02-事件循环" class="headerlink" title="02 事件循环"></a>02 事件循环</h2><hr>
<p>我们知道JavaScript是单线程的，意思就是一个时间只能做一件事情。就比如车站过安检一样，都会一个个通过，这就是单线程。那么这样问题就来了，假如程序中有一个很慢的http请求，用户必须要等待响应才可以继续后续的操作，这样就不妥了。所以我们就让长时间请求的程序代码挂起，让用户先操作其他事情。</p>
<p>在JavaScript中，我们把任务分为同步任务和异步任务。首先我们看一段代码的执行顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：script start=&gt;script end=&gt;promise1 =&gt;promise2=&gt;setTimeout</span></span><br></pre></td></tr></table></figure>



<p>为什么会是这样的结果，因为任务进入执行栈之后会判断一下是否是同步任务，若是同步任务就会进入主线程执行；异步任务就会到事件表里面注册回调函数到事件队列。</p>
<ul>
<li><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</p>
</li>
<li><p>当指定的事情完成时，Event Table会将这个函数移入Event Queue</p>
</li>
<li><p>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
</li>
<li><p>上述过程会不断重复，也就是常说的Event Loop(事件循环)</p>
</li>
</ul>
<p><img src="/2020/03/06/eventLoop/1.jpg" alt></p>
<h2 id="03-宏任务和微任务"><a href="#03-宏任务和微任务" class="headerlink" title="03 宏任务和微任务"></a>03 宏任务和微任务</h2><hr>
<p>上面我们知道有同步任务和异步任务，那么异步任务里面到底是如何分类呢？其实异步任务是包含宏任务和微任务，他们会加在同一个队列里面，只是执行顺序不一样而已。</p>
<p><img src="/2020/03/06/eventLoop/2.jpg" alt></p>
<p><strong><font color="orange">宏任务</font></strong>：整体代码script、setTimeout、setInterval、setImmediate</p>
<p><strong><font color="orange">微任务</font></strong>：原生Promise中then方法、process.nextTick、MutationObserver</p>
<p>对于宏任务和微任务我们只要记住以上几种就好。</p>
<p>我们重点来了解一下setTimeout的执行过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行console'</span>);</span><br></pre></td></tr></table></figure>

<p>根据事件循环的过程我们知道程序先执行打印操作然后再执行定时器，但是我们稍微修改一下函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="comment">//假设此处同步任务执行时间10秒</span></span><br></pre></td></tr></table></figure>



<p>这时候我们就发现并不会在3秒后执行task()回调函数，而是会等待10秒时间执行完毕后再执行task()任务。我们来分析一下：</p>
<ul>
<li>task()异步任务进入到 <strong><font color="orange">Event Table</font></strong> 并注册回调事件，开始计时</li>
<li>执行同步任务</li>
<li>经过3秒，task()进入事件队列（此时task并不能立刻执行）</li>
<li>经过10秒后，task()从事件队列中取出放到主线程执行</li>
</ul>
<p>关于setTimeout要补充的是，即便主线程为空，<strong><font color="orange">setTimeout(fn,0)</font></strong>，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。关于setInterval( fn , ms )来说并不是每隔ms就会执行一遍，而是经过ms后<strong><font color="orange">回调函数</font></strong>加入事件队列，所以setInterval未必准确。</p>
<p>最后放一道综合的题目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ul>
<li>整体以script1作为宏任务进入主线程，输出1</li>
<li>遇到setTimeout，回调函数分到<strong><font color="orange">宏任务队列</font></strong>中，记为s1</li>
<li>遇到process.nextTick()，回调函数分到<strong><font color="orange">微任务队列</font></strong>中，记为p1</li>
<li>遇到promise，直接输出7，then回调函数放置到<strong><font color="orange">微任务队列</font></strong>，记为t1</li>
<li>遇到setTimeout，回调函数分配到<strong><font color="orange">宏任务队列</font></strong>，记为s2</li>
<li>结束第一轮事件循环</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/eventLoop/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>由于微任务先于宏任务执行，此时输出 1 7 6 8，然后开启第二轮事件循环。从setTimeout1开始。</p>
<ul>
<li>遇到同步任务，打印 2</li>
<li>遇到process，放到<strong><font color="orange">微任务队列</font></strong>，记为p2</li>
<li>遇到promise，打印同步任务输出 4</li>
<li>遇到then任务，放到<strong><font color="orange">微任务队列</font></strong>，记为t2</li>
</ul>
<p><img src="/2020/03/06/eventLoop/2.png" alt></p>
<p>第二轮宏任务结束，执行微任务p2，t2。输出 3 、5。然后开启第三轮事件循环，从setTimeout2开始。</p>
<ul>
<li>遇到同步任务，打印 9</li>
<li>遇到process，放到微任务队列，记为 p3</li>
<li>遇到promise，打印同步任务输出 11</li>
<li>遇到then任务，放到<strong><font color="orange">微任务队列</font></strong>，记为 t3</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/06/eventLoop/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>第三轮宏任务结束，执行微任务p3，t3，输出 10 、12。到此，三轮事件循环结束。输出顺序为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1，7，6，8，2，4，3，5，9，11，10，12</span></span><br></pre></td></tr></table></figure>



<h2 id="04-Node中的事件循环"><a href="#04-Node中的事件循环" class="headerlink" title="04 Node中的事件循环"></a>04 Node中的事件循环</h2><hr>
<p><img src="/2020/03/06/eventLoop/node.png" alt></p>
<p>不过，在外部输入数据到来时，是从poll阶段开始的，即：</p>
<blockquote>
<p>外部数据 -&gt; poll -&gt; check -&gt; close callbacks -&gt; timer -&gt; I/O callbacks<br>-&gt; idle,prepare -&gt; poll …</p>
</blockquote>
<p>而这些阶段的功能大致如下：</p>
<ul>
<li>timer：执行定时器队列中的回调（如setTimeout、setInterval）</li>
<li>I/O callbacks：执行除了close事件、定时器、setImmediate之外的所有的回调</li>
<li>idel,prepare：仅内部使用，无需理会</li>
<li>poll：等待新的I/O事件，在一些特殊情况下，会阻塞在这里</li>
<li>check：专门执行setImmediate中的回调</li>
<li>close callbacks：执行close事件的回调，如socket.on(‘close’, …)</li>
</ul>
<h5 id="1、各个阶段详解"><a href="#1、各个阶段详解" class="headerlink" title="1、各个阶段详解"></a><strong>1、各个阶段详解</strong></h5><p><strong><font color="orange">timer阶段</font></strong><br>这个阶段会以先进先出的顺序执行所有到期后加入到timer queue里的回调（这些回调是通过setTimeout或者setInterval设置的）</p>
<p><strong><font color="orange">I/O callback阶段</font></strong><br>这个阶段主要执行大部分的I/O事件回调，包括为操作系统执行的一些回调（如TCP连接出错时，通过callback拿到错误信息）</p>
<p><strong><font color="orange">poll阶段</font></strong><br>V8引擎将JS代码解析后传入libuv，循环首先进入poll阶段，此后：</p>
<ul>
<li>检查poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调</li>
<li>poll queue为空时，检查是否有setImmediate的callback，有则进入check阶段执行setImmediate的回调</li>
<li>检查是否有到期的timer，如果有，按timer的到期顺序放到timer queue中，此后进入到timer阶段时，执行timer queue中的回调</li>
<li>如果setImmediate和timer的队列都是空的，则事件循环停留在poll阶段，直到有I/O事件返回，事件循环才立即进入I/O callbacks阶段，并且立即执行回调</li>
</ul>
<p><strong><font color="orange">check阶段</font></strong><br>本阶段专门用来执行setImmediate()的回调，当poll进入空闲状态，且setImmediate queue不为空时，事件循环会进入该阶段</p>
<p><strong><font color="orange">close阶段</font></strong><br>当一个socket连接或一个handle被突然关闭时（如调用了socket.destroy()），close事件会被发送到这个阶段执行回调，否则事件会用process.nextTick()方法发送出去</p>
<h5 id="2、process-nextTick"><a href="#2、process-nextTick" class="headerlink" title="2、process.nextTick"></a><strong>2、process.nextTick</strong></h5><p>虽然没有专门一个阶段来执行nextTick，但是存在一个nextTick queue，在事件循环 准备进入下一个阶段 前会先检查nextTick queue是否为空，不为空则需要等执行清空。<br>所以，如果错误地使用process.nextTick，会导致node进入死循环</p>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>在Node方面可能会有一些情况与JavaScript中不同，我们要注意区分这些情况。通过总结这一次的事件循环，我们应该会彻底了解事件的执行顺序，下次遇到这一类的题目就会迎刃而解。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li><p>JS事件循环机制（Event loop）之宏任务/微任务</p>
</li>
<li><p>彻底理解JavaScript中的Event loop</p>
</li>
</ul>
<p><img src="/2020/03/06/eventLoop/2.gif" alt></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>JavaScript</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Object.create()函数浅析</title>
    <url>/2020/03/05/createNull/</url>
    <content><![CDATA[<h2 id="Object-create-函数浅析"><a href="#Object-create-函数浅析" class="headerlink" title="Object.create()函数浅析"></a>Object.create()函数浅析</h2><blockquote>
<p>“ 创建对象的方式，里面的窍门你知道吗”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/createNull/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>不知道大家是否知道创建对象有多少种方法呢？我们通常创建对象都是以字面量的形式，以 var o = { } 的方式创建的对象是会连接到Object的原型上面，但是我们要是想创建一个我们自定义的对象怎么办呢？这就要使用到我们接下来讲解的 Object.create()方法了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/createNull/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-Object-create"><a href="#02-Object-create" class="headerlink" title="02 Object.create()"></a>02 Object.create()</h2><hr>
<p>在MDN上面的定义是：</p>
<blockquote>
<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__ proto __</p>
</blockquote>
<p>该方法可以接收两个参数：</p>
<ul>
<li><p>proto：新创建对象的原型对象</p>
</li>
<li><p>propertiesObject：自身定义的属性，具体如下</p>
<ol>
<li><p><code>configurable</code></p>
<p><code>true</code> 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 <strong>默认为 <code>false</code></strong></p>
</li>
<li><p><code>enumerable</code></p>
<p><code>true</code> 当且仅当在枚举相应对象上的属性时该属性显现。 <strong>默认为 <code>false</code></strong></p>
</li>
</ol>
<ul>
<li><p><code>value</code></p>
<p>与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 <strong>默认为 <a href><code>undefined</code></a>.</strong></p>
</li>
<li><p><code>writable</code></p>
<p><code>true</code>当且仅当与该属性相关联的值可以用<a href>赋值运算符</a>改变时。 <strong>默认为 <code>false</code></strong></p>
</li>
<li><p><code>get</code></p>
<p>作为该属性的 getter 函数，如果没有 getter 则为<a href><code>undefined</code></a>。函数返回值将被用作属性的值。 <strong>默认为 <a href><code>undefined</code></a></strong></p>
</li>
<li><p><code>set</code></p>
<p>作为属性的 setter 函数，如果没有 setter 则为<a href><code>undefined</code></a>。函数将仅接受参数赋值给该属性的新值。 <strong>默认为 <a href><code>undefined</code></a></strong></p>
</li>
</ul>
</li>
</ul>
<p>我们通过使用对象字面量和Object.create()方法看一下有什么区别，下面是普通字面量的形式创建的空对象，可见对象本身是继承了Object的，可以调用类似 toString()等相关方法。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/createNull/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>那么如果我们创建的对象不去继承属性怎么办呢？当我们创建的时候发现对象显示 No properties ，也就是说这是一个什么也没有的干净对象，我们是可以自定义toString等相关方法的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/createNull/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>使用null作为参数就等于切断了与Object的原型链了，这样创建出来的对象是没有继承关系的。我们都知道Object的原型最终是指向 Null 的，所以一开始创建的原型就直接指向 null ，没有经过层层的原型链。我们来看一下原型与原型链的关系就知道了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/createNull/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>所以我们知道这是一个高度可定制的对象，你可以用它来做数据字典，但是如果是对对象本身没有什么要求的话就使用普通字面量的形式创建即可。从一个小的知识点可以引申出JavaScript庞大的知识体系，不论是什么都要好好总结基础的东西。</p>
<p><strong><font color="green">参考文章</font></strong>：</p>
<ul>
<li>详解Object.create(null)</li>
<li>MDN Object.create()</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/createNull/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>函数</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>一文读懂TCP和UDP的区别</title>
    <url>/2020/03/05/tcpAndUdp/</url>
    <content><![CDATA[<h2 id="网络协议TCP和UDP的区别"><a href="#网络协议TCP和UDP的区别" class="headerlink" title="网络协议TCP和UDP的区别"></a>网络协议TCP和UDP的区别</h2><blockquote>
<p>“ 读懂此文，从此又少一个问题”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/tcpAndUdp/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端工程师跟网络打交道的时间不比网络工程师的少，浏览器就是我们天天都要用的，发送请求/响应数据其中的过程都要通过网络协议，所以网络协议已经成为前端的必要掌握知识了。而TCP和UDP协议是最关键也是最常见的两个协议，下面我们就来好好总结一下。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/tcpAndUdp/tcp_upd-featured.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-协议介绍"><a href="#02-协议介绍" class="headerlink" title="02 协议介绍"></a>02 协议介绍</h2><hr>
<h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h5><p>TCP是一种面向来连接的、可靠的、基于字节流的传输层通信协议。在计算机网络的OSI模型中，它完成第四层传输层所指定的功能。</p>
<p><strong>面向连接</strong>：数据在发送之前必须在两端建立连接，方法就是我们熟知的三次握手连接。</p>
<p><strong>可靠传输</strong>：通过多种机制来保证数据的正确传输，比如序列号/确认应答机制、检验和机制、超时重传机制、流量控制、拥塞避免机制等。</p>
<p><strong>基于字节流</strong>：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<p><strong><font color="red">特点</font></strong>：</p>
<ul>
<li>面向连接</li>
<li>仅支持单播传输</li>
<li>面向字节流</li>
<li>可靠传输</li>
<li>提供全双工通信</li>
</ul>
<h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h5><p>UDP是一种简单的面向数据报、面向无连接、不可靠的通信协议，位于OSI模型的传输层。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。</p>
<p><strong>面向无连接</strong>：UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p><strong>不可靠</strong>：不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p><strong>面向报文</strong>：面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，照样发送。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><strong><font color="red">特点</font></strong>：</p>
<ul>
<li>面向无连接</li>
<li>不可靠传输</li>
<li>提供单播、多播和广播</li>
<li>面向报文</li>
</ul>
<h2 id="03-协议比较"><a href="#03-协议比较" class="headerlink" title="03 协议比较"></a>03 协议比较</h2><hr>
<p><strong><font color="green">01 图解过程</font></strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/tcpAndUdp/tcp.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/tcpAndUdp/udp.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong><font color="green">02 特性比较</font></strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/tcpAndUdp/diff.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong><font color="green">03 头部比较</font></strong></p>
<p><img src="/2020/03/05/tcpAndUdp/tcp_head.png" alt></p>
<ul>
<li><p>来源连接端口（16位长）－识别发送连接端口</p>
</li>
<li><p>目的连接端口（16位长）－识别接收连接端口</p>
</li>
<li><p>序列号（seq，32位长）</p>
<ul>
<li>如果含有同步化旗标（SYN），则此为最初的序列号；第一个数据比特的序列码为本序列号加一。</li>
<li>如果没有同步化旗标（SYN），则此为第一个数据比特的序列码。</li>
</ul>
</li>
<li><p>确认号（ack，32位长）—期望收到的数据的开始序列号。也即已经收到的数据的字节长度加1。</p>
</li>
<li><p>数据偏移（4位长）—表示数据部分应该从TCP包的哪个部分开始计算，也可看作TCP首部长度。</p>
</li>
<li><p>保留（3比特长）—须置0，但如果收到的包在该字段，此包也不会丢弃。</p>
</li>
<li><p>标志符（9比特长）</p>
<ul>
<li>NS—ECN-nonce。ECN显式拥塞通知（Explicit Congestion Notification）是对TCP的扩展，定义于RFC 3540（2003）。ECN允许拥塞控制的端对端通知而避免丢包。ECN为一项可选功能，如果底层网络设施支持，则可能被启用ECN的两个端点使用。在ECN成功协商的情况下，ECN感知路由器可以在IP头中设置一个标记来代替丢弃数据包，以标明阻塞即将发生。数据包的接收端回应发送端的表示，降低其传输速率，就如同在往常中检测到包丢失那样。</li>
<li>CWR—与ECE标志都用于IP首部的ECN字段，当ECE标志为1时，通知对方已将拥塞窗口缩小。</li>
<li>ECE—置为1时通知对方到这边的网络有拥塞。</li>
<li>URG—为1表示高优先级数据包，紧急指针字段有效。</li>
<li>ACK—为1表示确认应答有效</li>
<li>PSH—为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li>
<li>RST—为1表示出现严重差错，必须强制断开连接。</li>
<li>SYN—为1表示希望建立连接。</li>
<li>FIN—为1表示发送方没有数据要传输了，要求释放连接。</li>
</ul>
</li>
<li><p>窗口（WIN，16位长）—表示从确认号开始，本报文的发送方可以接收的字节数，即接收窗口大小。用于流量控制。</p>
</li>
<li><p>校验和（Checksum，16位长）—对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。这是一个强制性的字段。</p>
</li>
<li><p>紧急指针（16位长）—本报文段中的紧急数据的最后一个字节的序号。</p>
</li>
<li><p>选项字段—用于提高TCP传输性能，最大长度40字节。</p>
<hr>
</li>
</ul>
<p><img src="/2020/03/05/tcpAndUdp/udp_head.png" alt></p>
<ul>
<li>来源连接端口（16位长）－识别发送连接端口</li>
<li>目的连接端口（16位长）－识别接收连接端口</li>
<li>报文长度：保存了UDP首部和数据的长度之和</li>
<li>检验和：为了提供可靠的UDP传输而设计的</li>
</ul>
<h2 id="04-应用场景"><a href="#04-应用场景" class="headerlink" title="04 应用场景"></a>04 应用场景</h2><hr>
<p>由于TCP保证数据的可靠传输，所以互联网上的很多场景都会使用TCP协议，比如网页浏览、信息发送、文件传输等，可以保证了数据的完整性。</p>
<p>相比于TCP，UDP更适用于实时通信的场景，因为丢了几个包对整体的影响不大，比如视频会议，直播等。</p>
<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>我们通过讲解TCP和UDP的区别，也知道它们对应的应用场景以及他们的关系。其实两者都是属于传输层的协议，为的就是传输数据是以何种方式而已。TCP的头部有20字节，协议传输会消耗更多的资源，但是保证数据的传输；而UDP头部只有8个字节，传输相对消耗较少，但是不保证数据的传输。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li>维基百科 TCP/UDP</li>
<li>fundebug 一文TCP与UDP的区别</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/05/tcpAndUdp/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
        <tag>tcp/udp</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之Buffer对象浅析</title>
    <url>/2020/03/04/buffer/</url>
    <content><![CDATA[<h2 id="Node-js之Buffer对象浅析"><a href="#Node-js之Buffer对象浅析" class="headerlink" title="Node.js之Buffer对象浅析"></a>Node.js之Buffer对象浅析</h2><blockquote>
<p><strong>“</strong> 前端开发的盲点，Node开发的基础<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/buffer/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端的开发人员一般是不会去关注Buffer的对象的，在大多数人看来前端就是写页面的程序员，但现在随着Node的发展，越来越多的前端工程师关注一些后端的开发流程。撇开前端的业务开发，我们来了解一下Node的工作都和哪些知识点打交道。</p>
<p>与应用型的场景不一样，Node中需要处理网络协议、操作数据库、处理图片、接受上传文件等。我们知道在网络当中，数据都是以二进制的形式传播，现有的JavaScript已经不能满足要求了，所以Buffer应运而生。</p>
<h2 id="02-Buffer"><a href="#02-Buffer" class="headerlink" title="02 Buffer"></a>02 Buffer</h2><hr>
<p>Buffer是一个像Array的对象，它的元素都是16进制的两位数。是一个典型的JavaScript与C++结合的模块，设计性能的相关部分采用了C++实现，而非性能部分采用了JavaScript实现。<strong><font color="orange">Buffer对象可以用来操作二进制数据流</font></strong>。</p>
<p>由于Buffer经常用于字符串以及大文件等操作，我们知道Node有垃圾收集机制，大对象不太可能存放在堆中，不然内存很快就会满了。buffer所占用的内存其实不是堆中的，而是堆外内存。Node在加载的时候就已经加载这个对象，并把它放在了全局对象上面。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/buffer/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-内存管理模型"><a href="#03-内存管理模型" class="headerlink" title="03 内存管理模型"></a>03 内存管理模型</h2><hr>
<p>Node程序在运行过程中，此进程占据的所有内存成为常驻内存。它由以下几个部分组成：</p>
<ul>
<li>代码区</li>
<li>栈</li>
<li>堆</li>
<li>堆外内存</li>
</ul>
<p>他们之间的关系如下图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/buffer/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="04-Buffer内存分配"><a href="#04-Buffer内存分配" class="headerlink" title="04 Buffer内存分配"></a>04 Buffer内存分配</h2><hr>
<p>我们知道，<strong><font color="orange">Buffer对象的内存分配不是在V8的堆内存中的，而是由Node的C++层面实现的内存申请的</font></strong>。由于大对象的存储空间是不确定的，不可能向操作系统申请，会对操作系统造成压力。所以Node在内存的使用上面应用的是C++层面申请内存，在JavaScript中分配内存的策略。</p>
<p>那么它的具体分配策略是怎么样的呢？大对象和小对象的分配方式采用的算法是否是一样的呢？</p>
<p>首先来介绍一下 <strong><font color="orange">slab 内存分配机制</font></strong>。它是一种动态内存管理机制，采用的是<strong><font color="orange">预先申请，事后分配</font></strong>的方式，简单来说它就是一块申请好的固定大小的内存区域。有如下3种状态：</p>
<ul>
<li>full：完全分配</li>
<li>partial：部分分配</li>
<li>empty：没有被分配</li>
</ul>
<p>这种机制是以 <strong><font color="orange">8KB为界限</font></strong>来决定当前分配的对象是大对象还是小对象，也就是每一个slab的值。在JavaScript层面以它作为单位单元进行内存的分配。</p>
<h5 id="①小对象内存分配"><a href="#①小对象内存分配" class="headerlink" title="①小对象内存分配"></a><strong>①小对象内存分配</strong></h5><p>我们在这里引入一个pool局部对象，Buffer在小对象的分配过程中会使用pool作为中间处理对象。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/buffer/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>上图这个是刚申请的slab内存块的状态是 empty 状态，等待被分配，而下图是被两个小对象分配后的状态，为partial状态。值得注意的是，在一个小对象分配之前会判断这个 pool 空间是否还够，如果不够的话就会重新申请一块新的8KB内存来分配。</p>
<p>所以一块 slab 可以被多个对象占有，加入第一次分配了1KB，但是下一个内存则要8KB，那么就造成了内存的浪费。这个1KB的小对象就占据了一整块内存。而且内存的释放规则是所有的对象释放之后，这块8KB的slab才会回收。</p>
<p>V8 GC 对其不直接起作用，Buffer 对象被 GC 的时候会触发一个回调（C++ 层面的回调），而 Node.js 源码中定义的那个回调里面做的事就是释放那块内存。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/buffer/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="②大对象内存分配"><a href="#②大对象内存分配" class="headerlink" title="②大对象内存分配"></a><strong>②大对象内存分配</strong></h5><p>如果这个对象是超过了 slab 的大小，那么就不会占用slab块，直接使用C++层面分配你所需要的大小，这块空间就会被你一直占有。举个简单的例子就是：</p>
<p>就像银行办理普通业务的客人一样，都规矩地在前台办理，但是VIP客户可以直接找银行行长。这里每一位银行业务员都是一个个slab，都是预先分配好的，然后VIP客人的需求可能更大，那么就直接找行长办理，无需繁杂的手续。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/buffer/6.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>这里我们总结一下，<strong><font color="orange">Buffer对象都是在JavaScript层面的，能够被V8的垃圾回收机制标记回收的</font></strong>。但是Buffer操作的字节真正的内存是在Node的C++层面提供的，JavaScript层面只是使用它。不论是小 Buffer 对象还是大 Buffer 对象，内存分配是在 C++ 层面完成，内存管理在 JavaScript 层面。如果解除两者的引用，Buffer对象最终还是可以被 V8 的垃圾回收标记所回收。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/buffer/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><p>Buffer对象是Node服务端的一个重要的概念，占据着很重要的位置。不论我们读写文件还是网络请求都会用到这个对象，可能前端的开发人员不会过多关注这个东西。</p>
<p>通过对buffer对象的内存分配，我们在以后的编程当中应该时刻关注着变量的分配，因为如果内存一旦泄露，1G的服务器内存也会很快地被占用完，严重的话会造成服务器的崩溃。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li>深入浅出Node.js</li>
<li>探究不在V8堆内存中存储得Buffer对象</li>
</ul>
<p><img src="/2020/03/04/buffer/2.gif" alt></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Buffer</tag>
        <tag>Node</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>关于前后端鉴权的几种方式</title>
    <url>/2020/03/04/Authorization/</url>
    <content><![CDATA[<h2 id="关于前后端鉴权的几种方式"><a href="#关于前后端鉴权的几种方式" class="headerlink" title="关于前后端鉴权的几种方式"></a>关于前后端鉴权的几种方式</h2><blockquote>
<p><strong>“</strong> 人生亦有命，安能行叹复坐愁<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/Authorization/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>最近看的比较多的方面都是关于计算机网络的内容，不得不说这个方面是真的很广泛，然后花了一些时间来了解一下如何实现前后端鉴权的方式，查阅了一下文章，也顺便写一下总结。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/Authorization/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-鉴权方式"><a href="#02-鉴权方式" class="headerlink" title="02 鉴权方式"></a>02 鉴权方式</h2><hr>
<p>前后之间进行数据交互，当然后端要判断你是否是真正的操作者，只有符合条件的用户才可以操作。也就是说必须要有一个身份证明你是一个好人。通常会有四种方式：</p>
<ul>
<li>HTTP Basic Authentication</li>
<li>session-cookie机制</li>
<li>Token验证</li>
<li>OAuth开放授权</li>
</ul>
<p><strong><font color="orange">1、HTTP Basic Authentication</font></strong></p>
<p>在HTTP中，基本认证是允许http用户代理（浏览器）在请求时，提供用户名和密码的一种方式。是一种十分简单的技术，使用的是HTTP头部字段强制用户访问网络资源，而不是通过cookie、sessionId、登陆页面等非获取访问控制的手段。</p>
<p>很多网页浏览器都支持这个，但是很少可以在公网上使用，因为他并没有为传送凭证提供数据保护，使用简单的base64编码后直接发送，编码可逆且安全性低。还有一个缺点就是用户在打开浏览器的情况下用户无法登出，也就是无法注销你已登录。解决方法一般是服务器准备一个注销的账号，当服务器接收到的账号密码是注销账号时就会注销。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/Authorization/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>如果用户在没有验证的情况下会返回401状态码提示用户进行授权，上图中的Authorization字段就是加密用户名和密码后的base64字符串，服务端解密比对验证后会将用户请求数据返回。基本上就是一种密码机制，中间可能会被截取和修改字段，所以是很不安全的机制。</p>
<p><strong><font color="orange">2、session-cookie机制</font></strong></p>
<p>利用服务端的session和浏览器的cookie来实现前后端鉴权，我们知道http是一种无状态的请求，用户请求完成就会关闭。如果要维持状态就需要浏览器第一次请求的时候在服务端创建一个session，session有一个唯一的标识就是sessionId。一般生产sessionId之后经过加密（可不用加密）返回给客户端，以cookie的形式保存在浏览器中。</p>
<p>当下一次请求时就会在请求头中加入cookie信息，服务器取出sessionId与之前生成的sessionId比对是否一致，来判断请求是否合法。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/Authorization/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>这种方法一般用在老版本的web系统，因为信息也是存储在cookie当中，也有不安全的成分在里面，一般现在的系统也不会采用这种形式的鉴权。</p>
<p><strong><font color="orange">3、Token验证</font></strong></p>
<p>Token又称为一个令牌，比如我们熟悉的QQ都有一个令牌，而且这个令牌隔一段时间是会变化的，上一种利用cookie的形式是不会变的。所以Token的鉴权方式更为安全也用的比较多。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/Authorization/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>就拿我们一个网站举例，当我们输入用户名和密码点击登陆的时候，加入网站是以Token进行鉴权的话，会有以下的步骤产生：</p>
<ul>
<li>用户名和密码请求登陆</li>
<li>服务端验证是否为数据库用户</li>
<li>成功，下发令牌Token给客户端</li>
<li>客户端以后每次请求都会带上令牌</li>
<li>服务端每次都会验证令牌</li>
</ul>
<p>其实看起来和上一个的验证方法差不多呀，到底有哪些区别呢？</p>
<p>session和cookie机制是在客户端与服务端之间保持一个状态，服务端创建session对象也是需要开辟一定的内存空间来保存登陆状态的，但是利用Token的话就不会保持状态，只需比对令牌是否有效即可。</p>
<p>也就是说Token是不存储在服务器的，这个Token本身就保存着登陆状态，服务器根据事先定义好的规则进行解密就可以知道该Token是否合理。初次之外，我们知道不只是浏览器是代理客户端，手机APP也是，在手机上面cookie是不起作用的，那么久限制了客户端类型，Token验证就不会有这个问题。</p>
<p><strong><font color="orange">4、OAuth开放授权</font></strong></p>
<p>这种方法用的是最多的，我们常见的一些网站比如CSDN、掘金等都可以利用微信和QQ进行登陆的，无须使用其他的用户名和密码。这种方式就可以省略了很多步骤，使得用户体验良好。</p>
<p>那么它是怎么操作的呢？</p>
<ul>
<li>向用户请求授权</li>
<li>用户授权，返回凭证code给第三方（CSDN/掘金）</li>
<li>利用code向授权服务器请求Access Token</li>
<li>返回Access Token</li>
<li>利用Access Token向资源服务器请求用户资源</li>
<li>获取用户资源，登陆成功</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/Authorization/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>用户鉴权在前端安全方面起着至关重要的作用，企业或者大型应用都会有自己独特的鉴权方法，但是原理还是离不开以上的步骤，而以上都是比较经典也是有代表性的鉴权方式，大家可以多了解多观察其他企业的做法。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li>前后端鉴权方式总结</li>
<li>维基百科 HTTP Basic Authentication</li>
<li>维基百科 安全令牌</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/Authorization/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>前后端鉴权</tag>
        <tag>安全</tag>
        <tag>session/cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>函数作用域、闭包与this指向问题</title>
    <url>/2020/03/04/this/</url>
    <content><![CDATA[<h2 id="函数作用域、闭包与this指向问题"><a href="#函数作用域、闭包与this指向问题" class="headerlink" title="函数作用域、闭包与this指向问题"></a><strong>函数作用域、闭包与this指向问题</strong></h2><blockquote>
<p><strong>“</strong> 纸上得来终觉浅，绝知此事要躬行<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/this/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>之前学习C语言的时候基本语法还好理解，但是后来出了一个this的东西，然后我的脑子就卡壳了，总觉得指针这东西让人琢磨不透，心想以后肯定不搞这个。现在学习了JavaScript之后发现原来也有this这玩意，想着这次逃不过了，那就好好总结一下吧，彻底把它弄懂就好。</p>
<p><img src="/2020/03/04/this/1.webp" alt=" "></p>
<h2 id="02-作用域"><a href="#02-作用域" class="headerlink" title="02 作用域"></a>02 作用域</h2><hr>
<p>作用域是可访问变量的集合，在JavaScript中对象和函数同样是变量，作用域为可访问变量，对象，函数的集合。作用域可以分为全局作用域和局部作用域。</p>
<p><strong><font color="orange">全局作用域</font></strong>： 变量在函数外定义，即为全局变量，全局变量有全局作用域，网页中所有脚本和函数都可以使用。如果变量在函数内没有声明，也是全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"hello World"</span>;</span><br><span class="line"><span class="comment">// 此处可调用 name 变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数内可调用 name 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处可调用 name 变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    name = <span class="string">"hello World"</span>;</span><br><span class="line">    <span class="comment">// 此处可调用 name 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="orange">局部作用域</font></strong>：变量在函数内声明，变量为局部作用域，只能在函数内部访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处不能调用 name 变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"hello World"</span>;</span><br><span class="line">    <span class="comment">// 函数内可调用 name 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。局部变量在函数执行时创建，函数执行完毕后局部变量就会自动销毁。</p>
<p>JavaScript变量生命周期，局部变量函数执行完毕后销毁，全局变量在页面关闭后销毁。函数参数只在函数内起作用，属于局部变量。</p>
<h2 id="03-闭包"><a href="#03-闭包" class="headerlink" title="03 闭包"></a>03 闭包</h2><hr>
<p><strong><font color="orange">闭包</font></strong>：函数A内部有函数B，函数B可以访问函数A的变量，那么函数B就是闭包。本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a) <span class="comment">//123</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B()</span><br><span class="line">&#125;</span><br><span class="line">A()();</span><br></pre></td></tr></table></figure>

<p><strong><font color="orange">闭包有3大特性：</font></strong></p>
<ul>
<li>函数嵌套函数</li>
<li>函数内部可以引用函数外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
<hr>
<p><strong><font color="orange">闭包优点：</font></strong></p>
<ol>
<li>可读取函数内部的变量</li>
<li>局部变量可以保存在内存中，实现数据共享</li>
<li>执行过程所有变量都匿名在函数内部</li>
</ol>
<hr>
<p><strong><font color="orange">闭包缺点：</font></strong></p>
<ol>
<li>使函数内部变量存在内存中，内存消耗大</li>
<li>滥用闭包可能会导致内存泄漏</li>
<li>闭包可以在父函数外部改变父函数内部的值，慎操作</li>
</ol>
<hr>
<p><strong><font color="orange">使用场景：</font></strong></p>
<ol>
<li>模拟私有方法</li>
<li>setTimeout的循环</li>
<li>匿名自执行函数</li>
<li>结果要缓存场景</li>
<li>实现类和继承</li>
</ol>
<h2 id="04-this指向"><a href="#04-this指向" class="headerlink" title="04 this指向"></a>04 this指向</h2><hr>
<p>this是在函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。通过捣鼓这么多代码，无非就是几种情况，在不同的环境下会有不同的值。发现网上很多关于this的文章都会让人觉得很难以理解，讲解一大堆例子但是没有讲到点上。</p>
<p>首先我们来看一下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> a: <span class="number">2</span>,</span><br><span class="line"> foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo()</span><br></pre></td></tr></table></figure>

<ul>
<li>对于直接调用函数来说，不管foo函数被放在了什么地方，this的指向一定是window</li>
<li>对于obj.foo()来说，谁调用了函数那么谁就是this</li>
<li>对于new操作实例化来说，this就会绑定在实例化对象上面且不会被改变</li>
<li>箭头函数this只取决于包裹箭头函数的第一个普通函数的this</li>
</ul>
<p><strong><font color="orange">PS</font></strong>：箭头函数是没有this的，只会从自己的作用域链的上一层继承this。箭头函数的this在它被定义的时候就确定了，之后永远不会改变。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/this/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="05-小结"><a href="#05-小结" class="headerlink" title="05 小结"></a>05 小结</h2><hr>
<p>函数作用域和闭包等知识点都是一些很基础的，只不过我们经常会忽略了最基础的内容，忙着去学习前端框架等其他技术。所以我们一定要重视起来，这也是面试基础，但很多人也答不出来。</p>
<p><strong><font color="green">参考文章</font></strong></p>
<ul>
<li>阮一峰 JavaScript 的this 用法</li>
<li>菜鸟教程 JavaScript函数作用域</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/this/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>this</tag>
        <tag>闭包</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy 对象拦截器</title>
    <url>/2020/03/04/proxy/</url>
    <content><![CDATA[<h2 id="Proxy-对象拦截器"><a href="#Proxy-对象拦截器" class="headerlink" title="Proxy 对象拦截器"></a><strong>Proxy 对象拦截器</strong></h2><blockquote>
<p><strong>“</strong> ES6的对象拦截器，可以拦截哪些情况呢<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/proxy/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>自从ES6诞生以来，各种新特性也逐渐显现出来，比如ES6中的Proxy对象，是一个重要的技术。之前Vue的数据双向数据绑定是使用Object.defineProperty()来做的，而现在vue3.0使用的是代理Proxy来编写。原因是前者有一些对象或者数组的变化是监听不了的，但是Proxy可以监听整个对象。</p>
<p>Proxy可以理解为，当你试图访问一个对象的时候必须先经过一个拦截或者代理，你才可以进行对对象的操作。这种机制的好处就是可以对外界的访问进行过滤和改写。</p>
<h2 id="02-Proxy实例的方法"><a href="#02-Proxy实例的方法" class="headerlink" title="02 Proxy实例的方法"></a>02 Proxy实例的方法</h2><hr>
<h5 id="proxy实例的构造"><a href="#proxy实例的构造" class="headerlink" title="proxy实例的构造"></a><strong><font color="red">proxy实例的构造</font></strong></h5><p>ES6提供一个原生的Proxy构造函数，用于生成Proxy实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span> ( target, handler ) ;</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li>target：所要拦截（代理）的对象</li>
<li>处理函数，拦截对应的操作</li>
</ul>
<p>利用Proxy对象可以拦截的方法有一下13种，下面一一来介绍一下。</p>
<h5 id="1、get"><a href="#1、get" class="headerlink" title="1、get()"></a><strong>1、get()</strong></h5><p>get方法是意思是读取对象，那么相应的拦截就是在读取对象的时候进行拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'alanwu'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="keyword">get</span>:function(target, property)&#123;</span><br><span class="line">        <span class="keyword">if</span>(property <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">return</span> target[property]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'对象属性不存在'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.name  <span class="comment">//'alanwu'</span></span><br><span class="line">proxy.age   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>假如上述代码访问不存在的属性的时候，没有抛出错误的话就会返回undefined。</p>
<h5 id="2、set"><a href="#2、set" class="headerlink" title="2、set()"></a><strong>2、set()</strong></h5><p>set拦截操作用于拦截对对象赋值的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">101</span>,</span><br><span class="line">    b: <span class="number">46</span>,</span><br><span class="line">    c: <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">100</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span>值不能小于100`</span>)</span><br><span class="line">        &#125; </span><br><span class="line">        target[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="3、apply"><a href="#3、apply" class="headerlink" title="3、apply()"></a><strong>3、apply()</strong></h5><p>apply方法用于拦截函数的调用、call、apply操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</span><br><span class="line">	apply(target, context, args) &#123;</span><br><span class="line">	<span class="comment">// 我们可以通过 Reflect.apply()来调用目标函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments) * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>



<h5 id="4、has"><a href="#4、has" class="headerlink" title="4、has()"></a><strong>4、has()</strong></h5><p>has方法用于拦截hasProperty操作，即判断对象是否具有某个属性时，该方法有效。值得注意的是，对for…in循环是没有效果的。has方法可以判断该属性来自继承的属性，不只是自身的属性。下面是拦截访问私有属性“_prop”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">	has(target, key)&#123;</span><br><span class="line">		<span class="keyword">if</span>(key[<span class="number">0</span>]===<span class="string">'_'</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123;<span class="attr">_prop</span>:<span class="string">'foo'</span>, <span class="attr">prop</span>:<span class="string">'foo'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h5 id="5、construct"><a href="#5、construct" class="headerlink" title="5、construct"></a><strong>5、construct</strong></h5><p>该方法的本意是构造，所以会拦截 new 操作符命令。该方法接受两个参数：</p>
<ul>
<li>target：目标对象</li>
<li>args：构造函数的参数对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">	construct (target, args, newTarget)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> target(...args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, argumentsList, newTarget</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'called: '</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: argumentsList[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> p(<span class="number">1</span>).value); <span class="comment">// "called: 1"</span></span><br><span class="line">                               <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>



<h5 id="6、deleteProperty"><a href="#6、deleteProperty" class="headerlink" title="6、deleteProperty()"></a><strong>6、deleteProperty()</strong></h5><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。值得注意的是，目标对象自身的不可配置（configurable）的属性不能被deleteProperty方法删除，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">	deleteProperty(target, key)&#123;</span><br><span class="line">		invariant(key, <span class="string">'delete'</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span>(<span class="params">key, action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key[<span class="number">0</span>]===<span class="string">'_'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attemp to <span class="subst">$&#123;action&#125;</span> private "<span class="subst">$&#123;key&#125;</span>" property`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123;<span class="attr">_prop</span>:<span class="string">'foo'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy._prop  <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>



<h5 id="7、defineProperty"><a href="#7、defineProperty" class="headerlink" title="7、defineProperty"></a><strong>7、defineProperty</strong></h5><p>该方法用于拦截Object.defineProperty操作。下面操作添加新的属性会触发defineProperty函数，所以会报错。如果目标对象不可扩展（extensible）或不可写（writable）或不可配置（configurable），也不可添加新属性，否则也会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">	defineProperty(target, key, descriptor)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span></span><br></pre></td></tr></table></figure>



<h5 id="8、getOwnPropertyDescriptor"><a href="#8、getOwnPropertyDescriptor" class="headerlink" title="8、getOwnPropertyDescriptor"></a><strong>8、getOwnPropertyDescriptor</strong></h5><p>该方法用于拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    getOwnPropertyDescriptor(target, key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key[<span class="number">0</span>]===<span class="string">'_'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123;<span class="attr">_foo</span>:<span class="string">'bar'</span>, <span class="attr">baz</span>:<span class="string">'tar'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>); <span class="comment">//&#123;value:'tar', writable:true,enumerable:true,configurable:true&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="9、getPrototypeOf"><a href="#9、getPrototypeOf" class="headerlink" title="9、getPrototypeOf()"></a><strong>9、getPrototypeOf()</strong></h5><p>该方法用于拦截获取对象的原型。有如下几种情况：</p>
<ul>
<li>Object.prototype. __ proto __</li>
<li>Object.prototype.isPrototypeOf()</li>
<li>Object.getPrototypeOf()</li>
<li>Reflect.getPrototypeOf()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    getPrototypeOf(target)&#123;</span><br><span class="line">        <span class="keyword">return</span> proto</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p) === proto <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是getPrototype方法返回值必须是对象或者null，否则会报错。目标对象不可扩展（extensible），那么该方法必须返回对象的原型对象。</p>
<h5 id="10、isExtensible"><a href="#10、isExtensible" class="headerlink" title="10、isExtensible()"></a><strong>10、isExtensible()</strong></h5><p>该方法用于拦截Object.isExtensible()操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</span><br><span class="line">    isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>该方法返回值必须是布尔值，否则会转成布尔值。如果返回值与目标对象的IsExtensible(target)不一致，也会抛出错误。</p>
<h5 id="11、ownKeys"><a href="#11、ownKeys" class="headerlink" title="11、ownKeys()"></a><strong>11、ownKeys()</strong></h5><p>该方法用于拦截对象自身属性的读取操作。可以拦截以下操作：</p>
<ul>
<li>Object.getOwnPropertyNames () </li>
<li>Object.getOwnPropertySymbols () </li>
<li>Object.keys () </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    ownKeys(target)&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'a'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler);</span><br><span class="line"><span class="built_in">Object</span>.keys(proxy) <span class="comment">//['a']</span></span><br></pre></td></tr></table></figure>



<h5 id="12、preventExtensions"><a href="#12、preventExtensions" class="headerlink" title="12、preventExtensions()"></a><strong>12、preventExtensions()</strong></h5><p>该方法拦截 Object.preventExtensions () ，该方法必须返回个布尔值，否则会被自动转为布尔值。只有目标对象不可扩展时，即 Object.isExtensible(proxy)为false， proxy.preventExtensions 才能返回 true ，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p &#x3D;new Proxy(&#123;&#125;, &#123; </span><br><span class="line">	preventExtensions: function(target) &#123; </span><br><span class="line">		return true; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br><span class="line">Object.preventExtensions(p) &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure>



<h5 id="13、setPrototypeOf"><a href="#13、setPrototypeOf" class="headerlink" title="13、setPrototypeOf()"></a><strong>13、setPrototypeOf()</strong></h5><p>该方法主要用于拦截 Object.setPrototypeOf 方法。下面的代码中，只要修改 target 的原型对象就会错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123; </span><br><span class="line">	setPrototypeOf (target, proto) &#123; </span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">'Changing the prototype is forbidden'</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125; ; </span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target , handler) ; </span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, proto );  <span class="comment">//Error : Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure>



<h5 id="14、Proxy-revocable"><a href="#14、Proxy-revocable" class="headerlink" title="14、Proxy.revocable()"></a><strong>14、Proxy.revocable()</strong></h5><p>Proxy.revocable 方法返回 一个可取消 Proxy实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo <span class="comment">//123</span></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo <span class="comment">//TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<p>Proxy.revocable 方法返回一个对象，其 proxy 属性是 Proxy 实例， revoke 属性是一个函数，可以取消 Proxy 实例。上面的代码中，当执行 revoke 函数后再访问 Proxy 实例，就会抛出一个错误。</p>
<p>Proxy.revocable 个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><hr>
<p>上述的实例方法在很多地方都有很大的作用，特别是对对象进行拦截的场景的时候。ES6语法在近年来已经很多使用，特别是vue3.0会使用proxy作为数据的响应式写法。</p>
<p>一般面试还都会问你Object.defineProperty有什么缺点，然后问你有没有关注vue3.0，知道3.0中的响应式使用什么写法。还有Proxy有什么方法之类的。</p>
<p><font color="#32CD32">参考文章</font></p>
<ul>
<li>阮一峰 ES6入门标准 ——Proxy</li>
</ul>
<p><img src="/2020/03/04/proxy/2.gif" alt></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>proxy</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack面试常考点——深入浅出webpack</title>
    <url>/2020/03/04/webpack/</url>
    <content><![CDATA[<h2 id="webpack面试常考点——深入浅出webpack"><a href="#webpack面试常考点——深入浅出webpack" class="headerlink" title="webpack面试常考点——深入浅出webpack"></a>webpack面试常考点——深入浅出webpack</h2><blockquote>
<p><strong>“</strong> 梅须逊雪三分白，雪却输梅一段香<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/webpack/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>大家可以想一下，假如你在面试当中最不想遇到的是什么？其实无非就是问到你不会的知识点，很多人可能会存着侥幸的心理不想面对那些看不懂的知识。所以我就想奉劝大家一句，还是好好恶补一下吧。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/webpack/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>前端现在越来越向着工程化的方向发展，我们可以做的事情越来越多了，而且功能都很丰富。前端框架的发展就是因为效率的问题，搭建一个通用脚手架就可以为以后的开发省下不少的时间。</p>
<p>前端的构建工具有很多种，下面我就总结一下前端打包工具webpack到底是什么？有什么作用。还有顺便总结一下面试通常会问些什么问题。</p>
<h2 id="02-webpack"><a href="#02-webpack" class="headerlink" title="02 webpack"></a>02 webpack</h2><hr>
<p>webpack是一个开源的前端打包工具，提供了前端开发缺乏的模块化开发方式，将各种静态资源视为模块，并从它生成优化过的代码。可以从配置文件里面配置资源入口、匹配规则等多种功能。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/webpack/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="webpack的构建作用"><a href="#webpack的构建作用" class="headerlink" title="webpack的构建作用"></a><strong><font color="#FF7F50">webpack的构建作用</font></strong></h5><ul>
<li><strong>代码转换</strong>：将es6转换成es5代码，把.scss文件转化成.css文件</li>
<li><strong>文件优化</strong>：可以合并图片，压缩代码</li>
<li><strong>代码分割</strong>：把每个页面的公共代码提取，异步加载首屏不需要的部分</li>
<li><strong>模块合并</strong>：构建过程可以合并相同类型的文件</li>
<li><strong>自动刷新</strong>：监听代码修改，自动刷新浏览器内容</li>
<li><strong>代码校验</strong>：校验代码是否符合规范</li>
<li><strong>自动发布</strong>：代码更新后自动构建，上线发布并提交给系统</li>
</ul>
<h5 id="webpack的打包原理"><a href="#webpack的打包原理" class="headerlink" title="webpack的打包原理"></a><strong><font color="#FF7F50">webpack的打包原理</font></strong></h5><ul>
<li><strong>初始化参数</strong>：从配置文件和shell文件语句中读取与合并，得出最终的配置参数。</li>
<li><strong>开始编译</strong>：根据参数初始化Compiler对象，加载所有配置的插件</li>
<li><strong>确定入口</strong>：根据entry确定所有入口文件</li>
<li><strong>模块编译</strong>：从入口文件开始，调用loader对模块进行翻译，递归找出所有依赖文件</li>
<li><strong>完成编译</strong>：使用loader翻译完之后，得到模块之间的关系以及模块内容</li>
<li><strong>输出资源</strong>：根据入口和模块关系，组装成包含多个模块的Chunk，将每个Chunk转换成一个单独文件加入输出列表</li>
</ul>
<h5 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a><strong><font color="#FF7F50">webpack核心概念</font></strong></h5><ul>
<li><strong>Entry</strong>：入口，webpack的构建入口从这里开始</li>
<li><strong>Module</strong>：模块，webpack处理模块的规则，在webpack里一切文件都是模块，webpack会从配置的Entry开始递归找到所有依赖的模块</li>
<li><strong>Loader</strong>：模块翻译器，用于把一些新的语法文件，如ES6、.scss文件转换成ES5和.css文件等可让浏览器识别的。</li>
<li><strong>Resolve</strong>：配置webpack的寻找模块规则，用于提高效率</li>
<li><strong>Plugin</strong>：插件，webpack在构建的过程中会广播对应的事件，插件的作用就是可以监听事件，然后执行相应的操作</li>
<li><strong>Output</strong>：输出结果，webpack在经过一系列的处理最终得到的代码结果</li>
<li><strong>Chunk</strong>：代码块，一个Chunk由多个模块组成，用于代码合并与分割</li>
</ul>
<h5 id="webpack的loader和plugin"><a href="#webpack的loader和plugin" class="headerlink" title="webpack的loader和plugin"></a><strong><font color="#FF7F50">webpack的loader和plugin</font></strong></h5><p>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，用原模块的内容按照loader翻译成另外的内容。比如将A.scss转换为A.css，单纯的文件转换过程。</p>
<p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后。webpack在整个构建过程中特定时机会广播出对应的事件，plugin就可以监听这些事件并执行相应的过程，它并不直接操作文件，而是基于事件机制工作。</p>
<h2 id="03-webpack优化"><a href="#03-webpack优化" class="headerlink" title="03 webpack优化"></a>03 webpack优化</h2><hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/04/webpack/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p><strong><font color="#FF7F50">1. 缩小文件范围</font></strong></p>
<ul>
<li><p>优化loader，尽可能少的文件被loader处理翻译。</p>
<p>（1）优化正则匹配</p>
<p>（2）开启cacheDirectory缓存</p>
<p>（3）配置include、exclude</p>
</li>
<li><p>优化resolve.modules，指定路径减少查找范围</p>
</li>
<li><p>配置resolve.alias，配置别名</p>
</li>
<li><p>配置resolve.extensions，正确填写文件后缀名，减少查找</p>
</li>
<li><p>配置resolve.noParse，忽略部分没采用模块化的文件处理</p>
</li>
</ul>
<p><strong><font color="#FF7F50">2. 减少冗余代码</font></strong></p>
<p>babel-plugin-transform-runtime，可以减少冗余代码，减少编译后的文件大小</p>
<p><strong><font color="#FF7F50">3. 使用HappyPack</font></strong></p>
<p>运行在node之上的webpack是单线程模型，HappyPack可以分解任务给多个子进程并发执行，处理完之后再发送给主线程</p>
<p><strong><font color="#FF7F50">4. 使用ParalleUglifyPlugin</font></strong></p>
<p>原来js代码输出会使用Uglify逐个压缩，但是ParalleUglifyPlugin会把多个文件压缩工作分配给多个子进程完成，加快压缩时间</p>
<p><strong><font color="#FF7F50">5. 使用自动刷新</font></strong></p>
<p>当你修改本地代码之后，webpack会监听改变并自动构建完成输出可以运行代码，然后控制浏览器刷新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">devServer: &#123;</span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    <span class="comment">// 不监听的文件或文件夹，支持正则匹配</span></span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    <span class="comment">// 监听到变化后等300ms再去执行动作</span></span><br><span class="line">    aggregateTimeout: <span class="number">300</span>,</span><br><span class="line">    <span class="comment">// 默认每秒询问1000次</span></span><br><span class="line">    poll: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong><font color="#FF7F50">6. 开启模块热替换</font></strong></p>
<p>配置devServer中的热模块替换，可在不刷新浏览器情况下实时预览。原理是源码变化后使用重新编译的模块替换旧模块。</p>
<p><strong><font color="#FF7F50">7. 提取公共代码</font></strong></p>
<p>将多个页面的公共代码抽取出来，形成单独的文件，避免多次加载浪费用户流量。可使用CommonsChunkPlugin插件来解决。</p>
<p><strong><font color="#FF7F50">8. 按需加载代码</font></strong></p>
<p>工程化构建项目的时候会引入很多不需要的文件，比如引入Ant Design可以按需引入，提高首屏的现实速度。</p>
<p><strong><font color="#FF7F50">9. 优化SourceMap</font></strong></p>
<p>上线代码会进行压缩，缺点就是开发人员难以定位错误和检查bug。SourceMap可以进行定位。</p>
<p><strong><font color="#FF7F50">10. 构建结果图形化</font></strong></p>
<p>可以使用webpack-bundle-analyzer进行可视化构建结果，分析项目的构建还可以有哪些优化问题。</p>
<p><img src="/2020/03/04/webpack/3.webp" alt></p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>webpack是一个构建打包工具，现在几乎前端的框架都可以使用它进行项目的打包和优化，里面的可配置性非常高，可以做的事情非常多。现在社区的生态也很活跃，越来越多的插件被开发者开发出来，值得我们好好去学习。</p>
<p><font color="#32CD32">参考文章</font></p>
<ul>
<li>Webpack再深入在总结</li>
<li>Vue项目Webpack优化实践，构建效率提高50%</li>
<li>《深入浅出Webpack》</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现单点登录(single sign on)</title>
    <url>/2020/03/03/singleSignOn/</url>
    <content><![CDATA[<h2 id="如何实现单点登录-single-sign-on"><a href="#如何实现单点登录-single-sign-on" class="headerlink" title="如何实现单点登录(single sign on)"></a>如何实现单点登录(single sign on)</h2><blockquote>
<p>“ 人生天地间，忽如远行客 “</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/singleSignOn/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>我们访问淘宝的时候，点击查看天猫商品的时候发现天猫的账户也同样是登陆的状态，这就是单点登录系统。使用单点登录是因为我们可以更好地抽离子系统，做到模块的拆分，降低系统的耦合程度。</p>
<p>如果我们不是单点登陆，那状态就不能共享了。比如淘宝的购物车是不能查看天猫的商品的，这就不合理了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/singleSignOn/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-单点登录"><a href="#02-单点登录" class="headerlink" title="02 单点登录"></a>02 单点登录</h2><hr>
<p>那么单点登录是如何实现的呢？我们可以举个简单的例子，我们去某一个地方（广州、深圳），那就必须购买那个城市的普通车票。假如我们去车站买了一张万能的车票，然后你可以选择去广州、深圳等各种地方。</p>
<p>之前的系统都是耦合程度比较高的，一次登录只能访问一个系统，也就是你必须有那个系统的通行证（普通车票）。但是现在你有万能车票，这个车票是车站发给你的，此时车站就是中心处理点（认证中心），广州/深圳的站台验证你的车票（Token）后就可以放行。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/singleSignOn/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>这张图我们可以理解为客户去车站买票，认证中心颁发的Token就是万能车票。我们利用这个Token就可以随意访问子系统的信息，前提是你的Token有效。</p>
<p>当你买了万能车票之后你就可以访问各种子系统，那么过程就可以理解为下面的图。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/singleSignOn/3.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p><font color="#FF7F50">用户首次登录过程：</font></p>
<ul>
<li>用户第一次访问，未登录则重定向认证中心</li>
<li>登录成功，颁发Token给用户</li>
<li>重定向系统A，带上Token访问系统A</li>
<li>系统A拿到Token与认证中心比较，正确则创建session局部会话</li>
</ul>
<p><font color="#FF7F50">用户非首次登录过程：</font></p>
<ul>
<li>用户带上Token访问系统B</li>
<li>系统B拿到Token与认证中心比较，正确则创建session局部会话</li>
</ul>
<p>我们请求系统A/B的时候，会带上Token，一般来说我们可以把Token存储到客户端的浏览器中，以<strong><font color="#FF7F50">cookie的形式保存</font></strong>。那么这里就有一个问题，cookie是不可以跨域的，可能系统A个系统B不是同一个域名怎么办呢？</p>
<p>针对这个问题，我们可以把cookie写到浏览器的时候设置Cookie的domain。domain是可以设置<strong><font color="#FF7F50">二级域名跨域</font></strong>的，比如abc.server.com与wer.server.com的。这样就可以成功跨域，认证中心也可以正确取出Token。</p>
<p>或者我们也可以把Token保存在<strong><font color="#FF7F50">SessionStorage</font></strong>中，不依赖cookie就可以避开这个问题。</p>
<h2 id="03-Redis缓存"><a href="#03-Redis缓存" class="headerlink" title="03 Redis缓存"></a>03 Redis缓存</h2><hr>
<p>其实Redis也是一个数据库，是一个开源的，基于内存的数据结构存储，可以用于数据缓存、消息中间件。既然是这样，那其实我们也可以把用户的登录信息全部缓存到Redis中，以后每一次访问都要去Redis看一下有没有登录信息即可。</p>
<p>使用Redis的优点就是可以实现<strong><font color="#FF7F50">分布式缓存</font></strong>，如果有多台机器的话，每一台机器都会共享一份缓存，并且缓存还具有<strong><font color="#FF7F50">一致性</font></strong>。一般来说，Redis是专业用来缓存数据的，可以承受10G+的缓存数据，也可将缓存数据放到硬盘中，Redis重启后也可以恢复。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/singleSignOn/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>我们可以看到，SSO本身也是一个系统，只是专门用来管理用户的登录信息而已，那么它的信息是可以与数据库进行对接，其中Redis就可以做缓存信息的功能，不用每次请求都定向到数据库。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>到现在我们应该可以理解SSO的原理是怎么样的，一般像淘宝，网易等公司的系统都会这样设置，能够避免访问系统的时候重复登陆，也优化了架构的方案，使得架构更加清晰而不臃肿。</p>
<p><font color="#32CD32">参考文章</font></p>
<ul>
<li>什么是单点登录</li>
<li>cookie的domain属性</li>
<li>从零单排学Redis</li>
<li>单点登录（SSO）的设计与实现</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/singleSignOn/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>session</tag>
        <tag>Token</tag>
        <tag>SSO</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 2.0有什么新特性</title>
    <url>/2020/03/03/http2/</url>
    <content><![CDATA[<h2 id="HTTP-2-0有什么新特性"><a href="#HTTP-2-0有什么新特性" class="headerlink" title="HTTP 2.0有什么新特性"></a>HTTP 2.0有什么新特性</h2><blockquote>
<p>“只在此山中，云深不知处”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/http2/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>今天看了一下腾讯微信的鹅厂卧谈会，主要是介绍校招/社招生如何利用自身的优势，或者如何准备面试的一些问题。我们知道社交的公司一般都会注重一些计算机网络的知识，毕竟涉及到实时传输、通讯等技术。</p>
<p>其中有一句话讲的很准确，校招生是不需要样样精通技术的，你可以选择一个你比较熟悉的领域或者你认真研究过的方向，一旦写上你精通某种技术，我都会问的很深。所以为了你的大好前途，千万不要给自己埋坑。接下来我浅谈一下HTTP的相关内容。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/http2/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-HTTP-2-0特性"><a href="#02-HTTP-2-0特性" class="headerlink" title="02 HTTP 2.0特性"></a>02 HTTP 2.0特性</h2><p>我们知道http是一种超文本传输协议，是客户端与服务端之间的请求和应答的标准，通常会使用TCP协议。HTTP 2.0就是在基础上再一次进行升级，为了解决HTTP 1.0+协议存在的问题，并且提高网络传输性能、优化网络传输过程。那么，到底相比于HTTP 1.0 有什么新的变化呢？</p>
<h5 id="01-二进制分帧"><a href="#01-二进制分帧" class="headerlink" title="01 二进制分帧"></a><strong>01 二进制分帧</strong></h5><p>HTTP 2.0最大的特点：不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。</p>
<p>既然又要保证HTTP的各种动词，方法，首部都不受影响，那就需要在<strong><font color="#FF7F50">应用层和传输层</font></strong>之间增加一个二进制分帧层。</p>
<p>在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/http2/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>当我们建立连接的时候，就可以承载任意数量的双向数据流，每一个数据流都以消息的形式发送，消息有一个或多个帧组成，可乱序发送。每个帧首部都会有一个标识位，接收到之后就可以重装。</p>
<p>这样就解决了http 1.0 中一应一答的低效率模式，能够有效地提高传输效率，连接吞吐量更大且内存占用更少。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/http2/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="02-多路复用"><a href="#02-多路复用" class="headerlink" title="02 多路复用"></a><strong>02 多路复用</strong></h5><p>HTTP 1.0的模式是，建立连接请求数据完毕之后就立即关闭连接；后来采用了keep-alive保活模式使得可以复用连接不断开，可以利用这次连接继续请求数据。但是始终会有一个缺点，就是你必须等待服务器返回上一次的请求数据你才可以进行下一次的请求。</p>
<p>万一我们遇到有一个请求很久都不返回数据，那后面的请求只能继续等待。如何解决这个问题呢？HTTP 2.0就提出了多路复用的技术，就是你可以连续发送多个请求，可以不用收到回复就继续发送请求。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/http2/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>多路复用的优点：</p>
<ul>
<li><strong>并行交错发送请求，请求之间互不影响</strong></li>
<li><strong>TCP连接一旦建立可以并行发送请求</strong></li>
<li><strong>消除不必要延迟，减少页面加载时间</strong></li>
<li><strong>可以最大程度利用HTTP 1.x</strong></li>
</ul>
<h5 id="03-首部压缩"><a href="#03-首部压缩" class="headerlink" title="03 首部压缩"></a><strong>03 首部压缩</strong></h5><p>HTTP 1.x首部是没有压缩的，Gzip只会对请求体进行压缩，现在HTTP 2.0 提供了首部压缩方案。现在SPDY和HTTP 2.0都支持首部压缩，前者使用的是DEFLATE算法，而后者使用专门设计的HPACK算法。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/http2/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>首部压缩可以使得头部帧可以最大程度复用，减少头部的大小，有利于减少内存和流量。比如我们第一次发送请求，里面包含头部的各种信息；但是后来我们又发送另外的请求，发现大部分的字段是可以复用的，我们只要发送一个当前请求特有的头部帧即可。由于首部表在HTTP 2.0 的连接存续期内始终是有效的，客户端和服务端共同更新。</p>
<h5 id="04-流量控制"><a href="#04-流量控制" class="headerlink" title="04 流量控制"></a><strong>04 流量控制</strong></h5><p>HTTP 2.0 “流” 的流量控制最终的目标是在不改变协议的情况之下允许采用多种流量控制算法。</p>
<p>流量控制特点：</p>
<ul>
<li>流量基于HTTP连接的每一跳进行，非端到端控制</li>
<li>流量基于窗口更新帧进行，接收方可广播准备接收字节数甚至对整个连接要接收的字节数</li>
<li>流量控制有方向性，接收方可以根据自身情况进行控制窗口大小</li>
<li>流量控制可以由接收方禁用，包括个别流和整个连接</li>
<li>只有DATA帧服从流量控制，其他类型帧不会消耗控制窗口的空间</li>
</ul>
<h5 id="05-请求优先级"><a href="#05-请求优先级" class="headerlink" title="05 请求优先级"></a><strong>05 请求优先级</strong></h5><p>客户端可以通过在打开流的HEADERS帧中包含优先次序信息来为一个新流指定优先级。在其它任意时间，可以使用PRIORITY帧来改变流的优先级。每个流都可以带有一个31bit的优先值：<font color="#FF7F50">0表示最高优先级；2的31次方-1表示最低优先级</font>。</p>
<p>客户端明确指定优先级，服务端可以根据这个优先级作为交互数据的依据，比如客户端优先设置为.css&gt;.js&gt;.jpg。服务端按此顺序返回结果更加有利于高效利用底层连接，提高用户体验。然而，在使用请求优先级时应<font color="#FF7F50">注意服务端是否支持请求优先级</font>，是否会引起队首阻塞问题，比如高优先级的慢响应请求会阻塞其他资源的交互。</p>
<p>服务器可以根据流的优先级控制资源分配（CPU、内存、宽带），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不用排队了，既节省了时间，又最大限度的利用了每个连接。</p>
<h5 id="06-服务器推送"><a href="#06-服务器推送" class="headerlink" title="06 服务器推送"></a><strong>06 服务器推送</strong></h5><p>一般HTTP请求都是由客户端发起，服务器收到请求进行返回。但是HTTP 2.0 可以使<strong><font color="#FF7F50">服务器主动返回资源</font></strong>给客户端用户。比如前端请求 /index.html 资源，但服务器把 /index.css ， index.png 都返回了。这样就可以提高了性能。</p>
<p>服务器推送工作过程：</p>
<ul>
<li>PUSH_PROMISE帧是服务端有意向客户端推送资源</li>
<li>PUSH_PROMISE帧只包含预推送资源的首部。如果客户端对此帧没有意见，服务端就会发送DATA帧响应。假如客户端缓存了可以拒绝推送。</li>
<li>服务器遵守同源策略，不会随意推送第三方资源。</li>
</ul>
<p>那么服务器怎么知道要给客户端推送什么资源呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">      index  index.html index.htm;</span><br><span class="line">      http2_push /style.css;</span><br><span class="line">      http2_push /example.png;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这是Nginx的实现方法，意思是当用户请求 / 路径时返回style.css和example.png文件。服务器推送可以减轻数据传送冗余步骤，加快页面响应速度，提升了用户体验。</p>
<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><p>总的来说，HTTP 2.0 给我们带了很多新的特性，简单总结一下：</p>
<ul>
<li>二进制分帧</li>
<li>多路复用</li>
<li>首部压缩</li>
<li>流量控制</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ul>
<p>如今网络已经成为了人们不可分离的一部分，如何把现有的网络资源来尽可能利用是提升网络性能的一个关键部分，把网络优化好了，不仅可以节约大量的服务器资源和用户流量。</p>
<p><font color="#32CD32">参考文章</font></p>
<ul>
<li>一篇文章让你入门HTTP 2.0</li>
<li>HTTP 2.0 的时代来了</li>
<li>阮一峰 HTTP/2服务b器推送</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/http2/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>网络协议</tag>
        <tag>HTTP/2.0</tag>
        <tag>特性</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Vue的虚拟DOM技术</title>
    <url>/2020/03/03/virtualDom/</url>
    <content><![CDATA[<h2 id="浅谈Vue虚拟DOM技术"><a href="#浅谈Vue虚拟DOM技术" class="headerlink" title="浅谈Vue虚拟DOM技术"></a>浅谈Vue虚拟DOM技术</h2><blockquote>
<p><strong>“</strong> 身无彩凤双飞翼，心有灵犀一点通<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/virtualDom/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>自从vue框架出现以来，越来越多的人们都在讨论虚拟DOM的技术，说虚拟DOM是比较高效的、不会操作DOM等等。但是我觉得我们应该从更深的层面去看到这个问题，尝试去阅读一下vue中的虚拟DOM源码，弄清楚到底它是怎么操作的。</p>
<p>接下我就说一下什么是虚拟DOM、为什么引入虚拟DOM以及Vue中的虚拟DOM。其实我们可能会产生一种错觉，认为Vue中才会有虚拟DOM的技术，其实React中也有，Angular中也有一种脏检查的技术，都是同样的原理。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/virtualDom/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-虚拟DOM"><a href="#02-虚拟DOM" class="headerlink" title="02 虚拟DOM"></a>02 虚拟DOM</h2><p>我们之前已经知道，操作DOM是一种昂贵的操作，到底“贵”在哪呢？这也涉及到浏览器引擎的知识，现在我们回忆一下，JavaScript是解析引擎的，页面渲染是渲染引擎的。因此不可避免地要进行两个线程之间的通信，操作越频繁，两个线程通信消耗的性能就越多。</p>
<h5 id="01-虚拟DOM由来"><a href="#01-虚拟DOM由来" class="headerlink" title="01 虚拟DOM由来"></a><strong>01 虚拟DOM由来</strong></h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/virtualDom/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>假如我们的DOM操作不涉及到通信的话，我们大可以把DOM全部去除然后渲染一份完整的DOM树。总的来说，虚拟DOM就是为了提高页面渲染性能，是随着时代发展而诞生的产物。</p>
<p><strong><font color="#FF7F50">虚拟DOM的解决方式是</font></strong>：通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。假如是首次节点的渲染就直接渲染，但是第二次的话就需要进行虚拟节点树的比较，只渲染不同的部分。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/virtualDom/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="02-何有引入虚拟DOM"><a href="#02-何有引入虚拟DOM" class="headerlink" title="02 何有引入虚拟DOM"></a><strong>02 何有引入虚拟DOM</strong></h5><p>我们知道虚拟DOM是为了提高性能，在React中是虚拟DOM比对，在Angular中是脏检查技术。但是在vue/1.0的时候还没有引入虚拟DOM技术，当时vue的检查流程跟前两者的都不一样，直接检测具体到节点的状态变化，采用更细粒度来绑定更新视图。</p>
<p>但是细粒度监听状态会产生大量的watcher实例，导致内存开销和依赖追踪的开销比较大。而是用低粒度会导致状态无法精确监听，所以vue 2.0 采用中等粒度方案监听，<strong><font color="#FF7F50">只能监听到组件的变化，而组件的内部就使用虚拟DOM进行状态比对</font></strong>，也就是DIFF算法。</p>
<h2 id="03-Vue的虚拟DOM"><a href="#03-Vue的虚拟DOM" class="headerlink" title="03 Vue的虚拟DOM"></a>03 Vue的虚拟DOM</h2><p>平时我们在Vue中写html代码的时候，可以使用变量，循环等指令来编写。可以这样写的原因是Vue中有模板解析的函数，可以对html代码进行解析编译，从而转变成渲染函数，渲染函数执行后就变成了虚拟DOM节点树。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/virtualDom/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>当虚拟节点准备映射到视图的时候，为了避免额外的性能开销，会先和上一次的虚拟DOM节点树进行比较，然后<strong><font color="#FF7F50">只渲染不同的部分</font></strong>到视图中，无需改动其他的节点状态。</p>
<p>vNode是一个普通的JavaScript对象，保存了DOM节点需要的一些数据，比如文本节点，属性等，以DOM对象的形式表现出来。其中主要的技术就是节点比对算法patch。</p>
<p><img src="/2020/03/03/virtualDom/5.png" alt></p>
<p>上述过程总结：</p>
<ul>
<li><strong>获取监听变化后生成的虚拟节点树</strong></li>
<li><strong>与上一次虚拟DOM节点树进行比较</strong></li>
<li><strong>找到差异的部分，渲染到真实的DOM节点上面</strong></li>
<li><strong>更新试图</strong></li>
</ul>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>虚拟DOM技术使得我们的页面渲染的效率更高，减轻了节点的操作从而提高性能。虚拟节点树其实是一个普通JavaScript对象，新旧节点的对象比较，得出差异直接渲染页面。</p>
<p>vue的状态侦测只能到某一个组件上面，这是基于性能的考虑而得出的方案。组件内部通过diff算法来比对，从而渲染试图。</p>
<p>vue中通过模板来描述状态与试图之间的映射关系，把模板编译成渲染函数然后得到虚拟DOM节点树，最后使用虚拟节点树渲染页面。</p>
<p>参考文章：</p>
<ul>
<li>深入浅出Vue.js  虚拟DOM简介</li>
</ul>
<p><img src="/2020/03/03/virtualDom/2.gif" alt></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>虚拟DOM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Node.js特点</title>
    <url>/2020/03/03/nodeCharator/</url>
    <content><![CDATA[<h2 id="详解Node-js特点"><a href="#详解Node-js特点" class="headerlink" title="详解Node.js特点"></a>详解Node.js特点</h2><blockquote>
<p><strong>“</strong> 今人不见古时月，今月曾经照古人<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCharator/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>由于JavaScript是单线程运行的原因，程序难免会发生请求阻塞的情况，试想如果请求一直没有得到回复，那就会一直处于卡死状态。这是很不好的体验，所以人们就想出了一种异步的方案，等待请求资源返回后执行回调函数。</p>
<p>但是Node的功能远远不止这样，Node打破了JavaScript代码只能在浏览器运行的局面，使得服务器也能运行JavaScript代码。进一步说明了JavaScript的功能不会局限于脚本，而是一门真正的后端语言。</p>
<p><img src="/2020/03/03/nodeCharator/1.webp" alt></p>
<h2 id="02-Node-js"><a href="#02-Node-js" class="headerlink" title="02 Node.js"></a>02 Node.js</h2><p>Node.js是一个环境，一个可以运行在服务端、跨平台的JavaScript环境。Node.js采用的是Google开发的V8运行代码，使用<font color="#FF7F50">事件驱动</font>、<font color="#FF7F50">非阻塞</font>以及<font color="#FF7F50">异步IO</font>模型，可以大幅度优化应用程序的传输量和规模。</p>
<p>我们可以看一下浏览器和Node在架构方面有什么不一样，两者都是可以提供一种运行环境。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCharator/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>总的来说，其实Node和谷歌浏览器的架构方面是很相似的，Node也是基于谷歌的V8引擎，使得在性能上有很大的提升。</p>
<h2 id="03-Node的特点"><a href="#03-Node的特点" class="headerlink" title="03 Node的特点"></a>03 Node的特点</h2><p>所谓的特点，就是Node.js是如何解决服务器高性能瓶颈的问题。总结一下Node的特点主要有以下4个：</p>
<ul>
<li>异步I/O</li>
<li>事件与回调函数</li>
<li>单线程</li>
<li>跨平台</li>
</ul>
<h5 id="01-异步I-O"><a href="#01-异步I-O" class="headerlink" title="01 异步I/O"></a><strong>01 异步I/O</strong></h5><p>当我们尝试去访问数据库的时候就会向服务器发送请求，时间长短取决于网络和数据库的性能如何。假如我们没有异步的机制，那我们就必须等待结果返回，什么也做不了。这就是单线程的缺点，会阻塞后续代码的执行，降低了程序的效率。</p>
<p>现在异步的机制是当我么执行请求的时候，立即执行后面的代码而不需要等待，请求结果放在回调函数当中，提高了效率。当I/O操作执行完毕之后会<strong>以事件的形式通知</strong>执行I/O操作的线程，“你要的结果处理好了，快来拿吧！”。</p>
<p>由于会有很多这样的异步请求，那就必须要有先后的顺序，这就是Node中的<strong>事件循环机制</strong>，JavaScript的不同。事件循环机制依次检查是否还有没有处理的回调函数，依次执行。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCharator/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>





<h5 id="02-事件与回调函数"><a href="#02-事件与回调函数" class="headerlink" title="02 事件与回调函数"></a><strong>02 事件与回调函数</strong></h5><p>Node通过事件驱动的方式处理请求时，无需为每一个请求都创建一个线程，而是采用一个线程，以循环处理的方式进行。客户端每进行一个I/O操作，都会添加到事件队列当中，线程会留下一个处理结果的回调函数。线程循环处理队列上面的任务，知道全部处理完成。</p>
<p><strong><font color="#FF7F50">事件驱动模型</font></strong>：在事件驱动中，所有异步任务仍然在同一个线程中。当I/O或其他昂贵操作时，注册一个回调到事件循环中，当I/O操作完成时继续执行。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCharator/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>





<h5 id="03-单线程"><a href="#03-单线程" class="headerlink" title="03 单线程"></a><strong>03 单线程</strong></h5><p>Node中的单线程操作，不用在意一些状态同步问题，也不会有死锁的存在，也没有线程上下文交换带来的性能开销。但是单线程也存在一些问题：</p>
<ul>
<li>无法利用多核CPU</li>
<li>错误产生会引起整个程序退出</li>
<li>繁重的计算会阻碍异步I/O</li>
</ul>
<p>Node采用了HTML5标准定制的<font color="#FF7F50">WebWorker</font>  来解决单线程中大量计算的问题。可以通过将计算分发到各个子进程来计算，然后通过进程之间的事件消息来传递结果，保持了应用模型的简单与低依赖。</p>
<p>其实我们常说的Node单线程是<strong><font color="#FF7F50">JavaScript的执行环境</font></strong>是单线程的，但JavaScript的宿主环境是因为libuv中有<strong><font color="#FF7F50">线程池</font></strong>的概念存在，libuv通过类似线程池的实现来模拟不同操作系统的异步调用，开发者是不可见的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCharator/2.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="04-跨平台"><a href="#04-跨平台" class="headerlink" title="04 跨平台"></a><strong>04 跨平台</strong></h5><p>起初，Node只可以在Linux平台上进行，后台投入了一个团队对Windows进行兼容。通过对Node架构层面的改动，建立了一层平台层架构，即libuv。通过良好的架构，Node的第三方C++模块可以借助libuv实现跨平台。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>基于以上的特点，我们知道Node可以<strong><font color="#FF7F50">应用于I/O密集型</font></strong>的场景，能够有效地组织起更多的硬件资源，从而提供更好的服务。而I/O密集型的处理能力主要得益于Node利用<strong><font color="#FF7F50">事件循环</font></strong>的处理能力，而不是启动一个线程为每一个请求服务。</p>
<p>关于CPU密集型的操作，Node主要是通过以下两个方法来解决：</p>
<ul>
<li>通过编写C/C++扩展模块来高效利用CPU</li>
<li>通过把计算分发成子进程进行计算的方式，然后利用进程间消息传递结果</li>
</ul>
<p>参考文章</p>
<ul>
<li>深入浅出Node.js</li>
<li>Node.js事件驱动和非阻塞机制详解</li>
</ul>
<p><img src="/2020/03/03/nodeCharator/1.gif" alt></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>特性</tag>
        <tag>后端</tag>
        <tag>异步</tag>
        <tag>非阻塞IO</tag>
        <tag>单线程</tag>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Node.js——内存管理</title>
    <url>/2020/03/03/nodeCollect/</url>
    <content><![CDATA[<h2 id="深入浅出Node-js——内存管理"><a href="#深入浅出Node-js——内存管理" class="headerlink" title="深入浅出Node.js——内存管理"></a>深入浅出Node.js——内存管理</h2><blockquote>
<p><strong>“</strong> 一点浩然气，千里快哉风<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>随着Node的发展，JavaScript的运行已经不再局限于运行在浏览器中了，Node在服务端的应用使得越来越多的问题也显现出来。对于刚接触JavaScript的开发者来说，基本上很少会想到内存分配或者内存泄露的问题，为了跟上潮流，就讲解一下Node是如何合理高效地使用内存，防止内存泄漏。</p>
<h2 id="02-V8垃圾回收与内存限制"><a href="#02-V8垃圾回收与内存限制" class="headerlink" title="02 V8垃圾回收与内存限制"></a>02 V8垃圾回收与内存限制</h2><p>JavaScript编程不用关心内存的分配和释放的问题，因为它有垃圾回收机制来管理。但是我们对于内存管理更深一步的了解可谓是很少，到底内存是怎么分配的、垃圾回收是怎么运行的？</p>
<h5 id="01-Node与V8"><a href="#01-Node与V8" class="headerlink" title="01 Node与V8"></a><strong>01 Node与V8</strong></h5><p>我们先来了解一下这两者是什么关系。首先V8是谷歌开发出来的浏览器引擎，性能可谓是十分优异，使得JavaScript编写服务器程序成为可能。V8的由来是虚拟机专家Lars Bak开发出来的，开发者之前的工作一直都是专注于高性能的虚拟机开发。</p>
<p>Node是一个构建在Chrome的JavaScript运行时平台，由此一来，Node的高性能就如同抱住了V8的大腿，可以随着V8的升级而享受更好的性能。</p>
<h5 id="02-V8的内存限制"><a href="#02-V8的内存限制" class="headerlink" title="02 V8的内存限制"></a><strong>02 V8的内存限制</strong></h5><p>Node通过JavaScript使用内存的话会有限制，而且Node无法直接操作大内存对象。64位系统下约为1.4GB，而32位系统下约为0.7GB。原因是Node基于V8构建，它的内存分配和管理都是由V8来控制，虽然在浏览器下这种分配机制没有问题，但是在Node中却是有问题的。</p>
<h5 id="03-V8的对象分配"><a href="#03-V8的对象分配" class="headerlink" title="03 V8的对象分配"></a><strong>03 V8的对象分配</strong></h5><p>在V8中，所有的JavaScript对象都是通过堆来分配的，对象占用的内存空间大小是不确定的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/0.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>当我们在代码里写上一些变量的时候，我们就会向堆中的内存空间进行申请。我们上面说过V8是有内存分配限制的，这是因为V8的垃圾回收机制影响。我们试想一下假如有1.5GB的垃圾需要等待回收，而V8的垃圾回收机制运行一次需要每50毫秒以上，在这段时间内，程序会无法运行。</p>
<p>假如说我非要打开这个限制也不是不行，我们可以在Node的启动时候更改一下参数即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --max-old-space-size=1700   xxx.js    //单位是MB</span><br><span class="line">node --max-new-space-size=1024  xxx.js    //单位是KB</span><br></pre></td></tr></table></figure>

<p>上面代码的意思就是新生代和老生代空间的更改，稍后解析什么是新生代和老生代空间。</p>
<h5 id="04-V8垃圾回收机制"><a href="#04-V8垃圾回收机制" class="headerlink" title="04 V8垃圾回收机制"></a><strong>04 V8垃圾回收机制</strong></h5><p>在V8中，我们知道内存空间可以分为新生代和老生代。新生代空间主要是保存一些存活时间较短的对象，而老生代空间主要存储一些存活时间较长的对象。</p>
<p>之前说过64位系统只能使用约1.4GB，32位只能使用0.7GB的空间。这空间是包含新生代和老生代空间，且老生代的空间比新生代要多。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<table>
<thead>
<tr>
<th></th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody><tr>
<td>新生代</td>
<td>16MB</td>
<td>32MB</td>
</tr>
<tr>
<td>老生代</td>
<td>700MB</td>
<td>1400MB</td>
</tr>
</tbody></table>
<p>V8主要采用两种不同的算法，分别作用于新生代和老生代，因为两者的关系不一样。主要有类算法，第一是Scavenge算法，第二是Mark-Sweep &amp; Mark-Compact。新老生代的特点如下：</p>
<p><strong>新生代：存活对象较少</strong></p>
<p><strong>老生代：存活对象较多</strong></p>
<p><font color="#FF7F50">①Scavenge算法</font></p>
<ul>
<li>把新生代空间一分为二，为From空间和To空间</li>
<li>内存先分配到From空间，垃圾回收会检查From空间存活情况</li>
<li>把From空间的存活对象移到To空间，释放From空间</li>
<li>把From和To空间对换</li>
</ul>
<p>这就完成了垃圾回收的一次清理过程。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p><font color="#FF7F50">②Mark-Sweep算法</font></p>
<ul>
<li>遍历堆中的所有对象，标记存活的对象</li>
<li>清除没有被标记的对象</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>由于老生代空间中，存活的对象较多，使用 Scavenge 算法的话遍历的时间会相对来说比较长，而且还会浪费一半的空间来存放对象，效率比较低。总的来说，Scavenge 算法<font color="#FF7F50">复制存活</font>的对象，而 Mark-Sweep 算法<font color="#FF7F50">清除死亡</font>的对象。</p>
<p><font color="#FF7F50">③Mark-Compact算法</font></p>
<p>我们看到上面这种算法回收一次过后<strong><font color="#FF7F50">产生了零碎的内存空间</font></strong>，假如这时候进来一个比较大的内存对象就无法完成分配，提前触发新一轮的垃圾回收机制。所以基于这个问题，在原来算法的基础上，采用<strong><font color="#FF7F50">压缩</font></strong>的办法，在标记活对象的过程中，对象会往一边移动。然后标记完成之后直接清除边界的内存。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p><font color="#FF7F50">④Incremental Marking算法</font></p>
<p>与前面三种不一样的是，这种算法<strong><font color="#FF7F50">采用了“步进”的方式</font></strong>进行，因为垃圾回收机制运行一次的时间也是有的，对于垃圾回收机制运行时间过长，那么页面的应用逻辑都要停下来等待，这种影响也是比较大的。</p>
<p>对于新生代来说不用担心这个问题，因为新生代存活对象比较少，内存占用也比较小。但是对于老生代来说，<strong><font color="#FF7F50">对象比较多也比较大</font></strong>，停顿造成的影响大，所以必须要让应用逻辑受垃圾回收的影响小一点。</p>
<p>因此采用“步进”的方式，垃圾回收机制和逻辑代码<strong><font color="#FF7F50">分段执行</font></strong>，缓解停顿时间过长而导致应用逻辑执行不了的问题。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/5.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-小结"><a href="#03-小结" class="headerlink" title="03 小结"></a>03 小结</h2><p>Node将JavaScript的主要应用扩展到了服务器端，所以我们考虑的细节也要和浏览器的不同，更多的是对内存资源的分配问题，稍有不慎可能会写出一些内存泄漏的问题，使得垃圾回收机制不能清理释放内存，严重可能会导致服务器崩溃。</p>
<p>所以平时我们写代码也要谨慎一点，不要写全局变量或者频繁使用闭包，这些如果没有正确释放内存的话也会导致内存泄漏。</p>
<p>参考文章：</p>
<ul>
<li>深入浅出Node.js</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/nodeCollect/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>内存分配</tag>
        <tag>后端</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>关于毕业就职的几点思考</title>
    <url>/2020/03/03/graduateThink/</url>
    <content><![CDATA[<h2 id="关于毕业就职的几点思考"><a href="#关于毕业就职的几点思考" class="headerlink" title="关于毕业就职的几点思考"></a><strong>关于毕业就职的几点思考</strong></h2><blockquote>
<p>古今多少事，都付笑谈中</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/graduateThink/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>想着大家跟我一样，在这个假期都一直待在家里哪里都没有去吧。不知道有多长时间没有喝过一杯奶茶，想着好像已经忘记奶茶是什么味道了。如果不是因为疫情的影响，大家都可能依然做着自己喜欢做的事，跟自己的好朋友一起相聚笑谈人生，也可能会在春节期间走亲访友…</p>
<p>不过，今年让我们意识到，即使一个月不喝奶茶，一个月不出去玩也不会有什么大问题的。朋友圈看的最多的是别人家的厨艺，当然有好也有不好的，一开始也不明白为什么都在发电饭煲做蛋糕的事情，后来才知道大家闲的发慌…</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/graduateThink/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>现在经过一个多月的时间，相信大家都想着回去上班或者开学，却被告知要远程上班和在线教学。之前看到小学/初中生的吐槽，“人在家中坐，网课天上来”。但是我们都知道特殊时期大家都是很无奈的办法，这时我们应该深有感触，有些学习需要在学校才有高效率，有些工作在公司才会高产出。</p>
<p>想想之前总觉得假期太短，现在却想着什么时候才可以回学校/公司。虽然说现在还不能按时回校，但是作为一个大四的学生，不知不觉就会面临很多问题让你觉得要思考了…  “毕业论文”、“工作”、“考研失利怎么办”、“就业还是继续考研”等等。</p>
<h2 id="02-就业率"><a href="#02-就业率" class="headerlink" title="02 就业率"></a>02 就业率</h2><p>今天看到新闻说今年的高校毕业生预计 <strong><font color="#FF7F50">将达到874万人</font></strong>，同比增加了40万人。我们都知道毕业生每一年都会增加，每一年都说今年的就业是最严峻的一年。但是我们从各大高校的数据中看到，似乎学生的就业率却不会受到每年增加的毕业生人数影响，都会保持在90%以上。</p>
<p>但是我们也许忽略了一个问题，真实的情况是否真的是这样呢？还是另有隐情呢？知乎上面有这样一篇文章《抱歉，贵校99%的就业率100%造假》。文章讲到了很多关于就业率的思考，通过一些采访我们也可以知道，部分学校可能会迫于压力提交假的毕业生就业率。</p>
<p>我们在校的时候都会受到老师的教导说“我们应该先就业再择业”，但是我们并不能否认这句话说的有道理。现在的毕业生的换工作频率非常高，造成这个的原因我想可能是由于匆忙就业后发现自己对工作是不满意的。</p>
<p>从自身的情况来说，我们应该清楚地认识到， <strong><font color="#FF7F50">高校毕业生的就业率我们应该保持一个中立理性的态度看待</font></strong>。对于毕业率100%的高校，我们更应该有理由去怀疑这个数字的真实性。一个大学，无论是985/211，还是普通本科的院校，肯定会有一小部分的学生没有就业的。</p>
<p>我们更加注意的一点就是，第一份工作一定要谨慎对待，特别是现在就业形势越来越严峻的情况之下，<strong><font color="#FF7F50">好好珍惜你是校招生的身份</font></strong>，不然走社会招聘的时候就不是这么容易了，除非你有一门很厉害的本领。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/graduateThink/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-如何避免毕业踩坑"><a href="#03-如何避免毕业踩坑" class="headerlink" title="03 如何避免毕业踩坑"></a>03 如何避免毕业踩坑</h2><p>别的专业我不太清楚，但是对于计算机专业的同学来说，就业还是比较容易的。因为每一年的人才缺口是很大的，企业难以招人，准确来说是难以招到优秀的人才，能够掌握计算机基础知识的同学。据我所知，大学很大一部分的时间都是自己在自学的状态。还有很重要的一点就是，可能与企业的人才需求不符，学校教授的知识很大一部分都过时了。</p>
<p>计算机这一块更新换代很快，基本上每半年都会有一些新的技术出现，可能你大一学的东西到了大四就基本不管用了。所以我们一定要在最开始就明确自己的目标，明确自己以后到底要从事哪一种工作，提前努力，笨鸟先飞。</p>
<p>根据自己的情况来说，最晚开始准备的时间不要晚于大三第一学期，最好在大二就开始好好努力了。我们可以理解那些刚上大一的同学期待大学校园的生活，可以放开心情好好去体验一下，我对大一新生的建议就是：</p>
<ul>
<li><strong>参加社团（可以，但别沉迷）</strong></li>
<li><strong>参加学生会（不建议）</strong></li>
<li><strong>参加实验室团队（强烈建议）</strong></li>
</ul>
<p>所以大家是可以尽早确定目标的，然后大三可以尝试去投递简历，你们还有很多的试错机会，不过也不用很担心，就当作是积累经验，提前熟悉招聘的流程，让你成为一个老司机。</p>
<h2 id="04-临近毕业怎么办"><a href="#04-临近毕业怎么办" class="headerlink" title="04 临近毕业怎么办"></a>04 临近毕业怎么办</h2><p>又或许你是另一种情况，不知不觉就来到了毕业这个阶段，那我们也不用慌，毕竟现在慌也没有用了。首先好好分析自己的强项还有自己薄弱的部分，对症下药，稳扎稳打。一般来说你至少有两次的机会，一次是大三的秋招阶段，另一次就是现在大四的春招阶段了。</p>
<p>我们不得不面对残酷的事实，等过了大四的春招阶段，你找到工作的几率是很低的，对于互联网这个方向来说是这样的。要想在最后的机会脱颖而出，需要你具备几个条件：</p>
<ul>
<li><strong>扎实的基础知识</strong></li>
<li><strong>有实习经历</strong></li>
<li><strong>有获奖经历（省级/国家级）</strong></li>
</ul>
<p>我想在大学这个温室里面，最后我们有可能会剩下第一个条件，有时候甚至也没有，这就更困难了。当然家里有矿那就另当别论了。</p>
<p>当你满足第一个条件的话，你就要时刻留意一下内推的信息，一边准备你的面试，一般来说简历没有问题，那么能不能拿到offer就看你的面试结果了。把自己的时间全身心投入到面试中去，毕竟大学也就这一次可以认真负责地努力一把了，也是关乎你毕业以后是否能够找到一份好工作的事情。</p>
<h2 id="05-毕业论文"><a href="#05-毕业论文" class="headerlink" title="05 毕业论文"></a>05 毕业论文</h2><p>希望大家能够通过最后的两次机会找到了自己满意的工作，但是你们也不要着急，毕竟还有一些棘手的事情等着你，如果处理不好，你也有可能失去你的满意工作。那就是能不能毕业的问题。</p>
<p>一般你找到了工作很大程度会去实习单位工作，而这个时候你的毕业论文或者毕业设计是没有做好的，或者压根就把时间放在了准备面试上面没有开始准备写。所以就建议确定了题目之后马上开始设计，把这个事情做好，安心实习，等待毕业。</p>
<p>其实这些事情，当你经历过后你才会知道原来大学毕业也是有一个过渡期的，从学生变成一个社会人的时间你也要提早适应，毕竟人不可能一直处在温室之中，也是要向前走的。我就是这样，早些时候才悟出这些道理。</p>
<h2 id="06-小结"><a href="#06-小结" class="headerlink" title="06 小结"></a>06 小结</h2><p>最后再说一下，辅导员或者老师的话不能全信，有时候你还是要有自己的思想，不要被眼前的情况迷惑了自己，网络时代每个人都有权利知道社会到底发生了什么事情，而你又应该如何去面对这些事情。能去实习就尽早出去，积攒社会经验，到毕业的时候就可以把简历写得好看一点，最后你的工资也会高一点。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/graduateThink/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>建议</tag>
        <tag>心得</tag>
        <tag>毕业</tag>
        <tag>独立思想</tag>
      </tags>
  </entry>
  <entry>
    <title>项目开发注意的那些事</title>
    <url>/2020/03/03/projectTip/</url>
    <content><![CDATA[<h2 id="项目开发注意的那些事"><a href="#项目开发注意的那些事" class="headerlink" title="项目开发注意的那些事"></a><strong>项目开发注意的那些事</strong></h2><blockquote>
<p><strong>“</strong> 性能监控，是网站性能的一个关键点<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/projectTip/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>平时我们开发一个项目，无非也就是几个步骤，项目设计、代码编写、代码检查、项目部署。我们可能会想着，也许项目上线也就这么简单吧。其实殊不知在大型的项目当中，这些就是过家家的游戏而已，项目上线之前做的工作可不比你实际编写核心代码的少。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/projectTip/640.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>那么我们自以为写的不错的代码架构，为什么会被面试官调侃呢？对于那些没有经验的同学而言，在简历里面写着熟悉高并发，负载均衡等各种高大上的技术，面试官是不会相信的，而是想着找机会来碾压你一下而已。</p>
<p>其实有很多事情，有很多的要点我们是无法通过一个项目来悟出道理的，必须经过很多的项目实践。在这里我也是没有经过任何实践的项目，也就在前人的基础上总结一下而已，这就是所谓的站在巨人的肩膀上。</p>
<h2 id="02-项目流程"><a href="#02-项目流程" class="headerlink" title="02 项目流程"></a>02 项目流程</h2><p>在我看来，一个项目的产生是经过多方的人员配合才会搬到线上的生产环境的。那么大致的流程都有哪些呢？</p>
<ul>
<li>市场调研</li>
<li>产品初步设想</li>
<li>产品经理提出需求</li>
<li>程序编码</li>
<li>项目测试</li>
<li>生产上线</li>
</ul>
<p>其实这上面讲的几点也是局限于一个比较大的范围，比如程序编码之前会有UI设计部门的产品设计图等等的工作。假如项目比较顺利的话，都会按这个流程走，而不顺利的话，比如中途甲方说需求改动（常有的事，这也是产品和研发打架的原因），然后程序的架构可能就要重写，研发周期可能会拉长很多，更重要的是浪费了很多时间（当然钱到位就没事）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/projectTip/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-注意事项"><a href="#03-注意事项" class="headerlink" title="03 注意事项"></a>03 注意事项</h2><p>那么这些我们平时写小项目可能不会遇到的事情是什么呢？首先第一个就是日志的编写，第二个就是环境的监控。</p>
<h5 id="01-日志编写"><a href="#01-日志编写" class="headerlink" title=" 01 日志编写"></a><strong><font color="#32CD32" size="5"> 01 日志编写</font></strong></h5><p>日志对于一个项目重要性不言而喻，或者开发的时候我们不会注意到，那么当项目生产上线之后遇到问题我们应该怎么办呢？或许有同学会说我们可以看控制台，不好意思，上线之后是没有控制台这东西的。</p>
<p>所以我们为了避免一些棘手的问题，应该是未雨绸缪，做好万全的准备。假如项目在运行过程当中出BUG了，轻则无法访问，重则丢失用户数据，这些都是非常严重的问题。比如前几天看到程序员删库跑路的事件，现在公司的数据就是所有的财产，丢失用户数据可能会导致公司倒闭。</p>
<p>所以说了这么多，我们一定要注意日志开发的重要性，出了故障可以准确快速定位到底是哪一部分出了问题，然后快速解决。</p>
<p><strong><font color="#32CD32" size="5"> 02 环境监控</font></strong><br>如果说日志的编写是程序不可或缺的一部分，那么我们后期项目的监控更是关乎程序是否健康运行。假如一个新生的婴儿出生后没有父母的护理，那么很可能会出现一些问题，比如生病了或者不健康甚至威胁生命的情况，如果不想出现意外，那么父母必须好好呵护。</p>
<p>程序也是同一个道理，一旦线上的环境出现一些异常，比如程序运行卡顿，内存迅速增加，肯定是出问题了。婴儿我们可以监听呼吸速率或者心跳速率，那么程序我们应该监控哪些指标呢？</p>
<ol>
<li>日志监控</li>
<li>响应时间</li>
<li>进程监控</li>
<li>内存监控</li>
<li>CPU占用监控</li>
<li>磁盘监控</li>
<li>CPU load监控</li>
<li>I/O负载</li>
<li>网络监控</li>
<li>应用状态监控</li>
<li>DNS监控</li>
</ol>
<p>这些也是程序的重要指标，假如发生异常也可以通过报警的方式通知主要负责人，这些也算是后勤保障工作，一个系统的正常运行是不可能离开这些监控的。这些如同孩子的监护人，保证孩子的健康。</p>
<p><img src="/2020/03/03/projectTip/3.webp" alt></p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>通过了解项目当中的事情，我们都知道其实项目的发布不是我们想象中的那么简单。即使你的所有步骤都准备好，包括日志和监控，那也会经过项目的测试过后才可以。一般项目有开发环境，测试环境，预发布环境，最后才是生产环境。</p>
<p>所以有很多知识点我们是看书无法体会到的，必须经过一定的积累。很多大型网站的复杂性可能也是超乎我们的想象，大家可以多去看大佬的实践，争取成为一名老司机。</p>
<p><img src="/2020/03/03/projectTip/GIF2020-3-214-47-34.gif" alt=" "></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>监控</tag>
        <tag>流程</tag>
        <tag>性能指标</tag>
      </tags>
  </entry>
  <entry>
    <title>微信扫码登录原理分析</title>
    <url>/2020/03/03/scanCodeToLogin/</url>
    <content><![CDATA[<h2 id="微信扫码登录原理分析"><a href="#微信扫码登录原理分析" class="headerlink" title="微信扫码登录原理分析"></a><strong>微信扫码登录原理分析</strong></h2><blockquote>
<p>一文读懂微信扫码登录原理</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/scanCodeToLogin/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>微信扫码登录的场景我们很常见，但是大家是否知道里面的原理是怎么实现的呢？这个二维码里面是否包含什么信息呢？或者怎么知道是哪一个手机扫描了二维码呢？</p>
<p>之前也看过一些介绍没有总结验证过，前些日子看到了面试有问微信扫码登录的原理，所以今天我就以登录网页版微信验证一下，通过控制台的请求查看具体过程。</p>
<h2 id="02-总体流程"><a href="#02-总体流程" class="headerlink" title="02 总体流程"></a>02 总体流程</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/scanCodeToLogin/liu.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="03-原理实现"><a href="#03-原理实现" class="headerlink" title="03 原理实现"></a>03 原理实现</h2><h5 id="1、二维码与网页服务器"><a href="#1、二维码与网页服务器" class="headerlink" title="1、二维码与网页服务器"></a><strong><font color="#32CD32">1、二维码与网页服务器</font></strong></h5><p>当我们打开微信的网页版的时候，查看控制台发现发送了一个请求登录的请求，然后网页服务器就随机产生了一个uuid返回给浏览器，而且这个uuid是和二维码绑定在一起的。服务器会把uuid作为key存进redis缓存服务器里面，类似 uuid：xxxx 的形式。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/scanCodeToLogin/request.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/scanCodeToLogin/re_code.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>然后接下来我们看到浏览器利用这一个uuid的值，每隔25s左右就发送一个请求。这个过程也是一个轮询的操作，目的就是为了判断用户是否已经扫码了，如果你已经扫码后确认登录轮询的停止。如果没有会一直持续几分钟，然后就二维码就过期了，页面刷新重新生成二维码。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/scanCodeToLogin/25s.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="2、二维码与手机服务器"><a href="#2、二维码与手机服务器" class="headerlink" title="2、二维码与手机服务器"></a><strong><font color="#32CD32">2、二维码与手机服务器</font></strong></h5><p>手机进行扫描二维码，然后手机携带uuid和用户信息向手机的服务器发送请求，手机服务器收到之后携带uuid去redis服务器查询用户，并把uuid与用户信息绑定在一起。查询用户成功之后返回一个Token给网页服务器，通过解析这个Token可以拿出用户的信息，然后浏览器就成功登录微信了。</p>
<p>值得注意的是，这里的手机服务器和浏览器服务器不是同一台服务器，存储的信息也可能不一样。</p>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><p>我们只要可以看懂流程就好了，因为扫码登录无非就是通过信息的层层传递，然后增加了安全性检查等确保用户在此过程中是安全的。其实不止是微信扫码是这样的流程，支付宝淘宝等的流程也是大同小异的。</p>
<p><img src="/2020/03/03/scanCodeToLogin/GIF2020-3-214-47-34.gif" alt=" "></p>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信</tag>
        <tag>扫码登录</tag>
        <tag>交互过程</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学家的工具箱</title>
    <url>/2020/03/03/secretBox/</url>
    <content><![CDATA[<blockquote>
<p><strong>“</strong> 密码学，网络时代不可缺少的一部分<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/secretBox/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>我们平时的手机、银行卡、各种社交账号都会给它设置一个密码，这样就减少别人盗用你账号的几率。而在现在的网络时代，更离不开密码的存在。假如没有密码的保护，别人捡到你的银行卡就可以取出所有的钱，捡到你的手机就可以直接拿来用，这些都是很可怕的事情。接下来我就总结一下，密码的领域，专家都有什么工具呢？</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/secretBox/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h2 id="02-加密与解密"><a href="#02-加密与解密" class="headerlink" title="02 加密与解密"></a>02 加密与解密</h2><hr>
<p>我们首先来看一个例子，小明同学给小红同学发送一封电子邮件，在没有加密的情况之下很容易就收到中间人的截取纂改，邮件内容有可能会被破坏。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/secretBox/4.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>如果没有意外，那么加入密文没有被破解，那么信息还是安全的。但是假如中间人通过某种方式得到了密文，并且成功破解了然后进行纂改：“小红，明天准时上课”。那这样的话信息就不是小明的原本意思了。</p>
<p>如果中间人截获了密文，有哪些方式可能会破解呢？</p>
<ul>
<li>暴力破解（穷举法）</li>
<li>频率分析法</li>
</ul>
<h5 id="01-暴力破解"><a href="#01-暴力破解" class="headerlink" title="01 暴力破解"></a><strong>01 暴力破解</strong></h5><p>这种方法常用于比较简单的场景，比如你是知道这个密码空间（所有密码的可能性）是有限的，那么就可以通过这种方法进行破解。比如你的银行卡密码一般都是6位数，通过随机排列组合可以有720种方法，但是很可惜你输入3次不对就会冻结你的卡。</p>
<p>如果没有限制的话，是可以得到你的密码的。我们也可以通过人的惯性思维来猜测密码，大部分人都是以生日来当作密码，那么我们可以从所有符合生日的密码来破解，大大减少难度。</p>
<h5 id="02频率分析"><a href="#02频率分析" class="headerlink" title="02频率分析"></a><strong>02频率分析</strong></h5><p>我们先来了解一下凯撒密码，该密码诞生于公元前100年左右的古罗马，而他的发明人就是军事统领凯撒。他的思想就是把26个字母表通过平移 n 位来进行加密，所以一旦我们知道平移了多少位就可以正确破译密文。这里的n 就是密钥，也可以使用暴力破解进行破译。</p>
<p>但是他也有一种频率分析的破译方法，找出密文中每一个字符的出现数量，然后猜测单词。</p>
<p>使用哪种破译方法，可以根据密文来决定。</p>
<h2 id="03-密码技术"><a href="#03-密码技术" class="headerlink" title="03 密码技术"></a>03 密码技术</h2><hr>
<p>要想信息不被别人窃取，那么常用的加密技术有哪些呢？</p>
<ul>
<li>对称加密</li>
<li>公钥密码（非对称加密）</li>
<li>单向散列函数</li>
<li>数字签名</li>
</ul>
<h5 id="01-对称加密"><a href="#01-对称加密" class="headerlink" title="01 对称加密"></a><strong>01 对称加密</strong></h5><p>说到对称加密，其实就是加密和解密公用一个密钥。这种方法的前提是双发都知道密钥是什么才可以正确解密。一旦密钥被窃取，加密也就没有意义。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/secretBox/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="02-非对称加密"><a href="#02-非对称加密" class="headerlink" title="02 非对称加密"></a>02 <strong>非对称加密</strong></h5><p>非对称加密就是加密和解密不是使用同一种密码，这种加密的话一般破解难度不是一般的大。首先我们要知道公钥和私钥是一对的。如果我们了解HTTPS的话，就知道为什么是安全的。我们继续以小明和小红的例子讲解一下：</p>
<ul>
<li>小明给小红发送 ming_key</li>
<li>小红给小明发送 ming_key 来加密 随机值</li>
<li>小明收到后用私钥解密出来，得到随机值</li>
<li>后续使用 随机值来进行加密</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/secretBox/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h5 id="03-单向散列函数"><a href="#03-单向散列函数" class="headerlink" title="03 单向散列函数"></a><strong>03 单向散列函数</strong></h5><p>这种技术类似于http响应头的ETag，是标记了文件的一个值。一旦文件发生轻微的改变，这个值也是完全不一样的。利用这一种技术我们可以判断出来文件是否被他人纂改了。</p>
<h5 id="04-数字签名"><a href="#04-数字签名" class="headerlink" title="04 数字签名"></a><strong>04 数字签名</strong></h5><p>这种签名的技术其实在我们生活中经常看到，比如请假条需要老师的签名，银行办理业务也需要本人的签名。这种签名就是为了防止以后你不认这件事情。</p>
<p>那么网络中也是一样的道理，经过一种数字签名之后就是你的授权，可以通过这种技术防止你事后否认。签名技术是一种防止否认的密码技术。</p>
<p>小结：</p>
<ul>
<li>确保信息的机密性：对称加密/非对称加密</li>
<li>确保信息不被纂改：单向散列函数</li>
<li>确保事后不可否认：数字签名</li>
</ul>
<h2 id="04-小结"><a href="#04-小结" class="headerlink" title="04 小结"></a>04 小结</h2><hr>
<p>通过密码技术我们可以更加安全地保护我们的信息，然后使得网络的世界也多了很多安全。我们从不敢在网上购物到现在热衷于网购，其实就是密码加密技术保护我们的财产。</p>
<p>网络当中存在着很多未知的因素，我们在一些网站中也要使用比较复杂的密码，不要使用一些简单数字结合的密码，因为会很容易被别人破解，输入一个特殊字符可能会使破译难度增加几个等级。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/03/secretBox/GIF2020-3-214-47-34.gif" alt="欢迎关注我的博客" title>
                </div>
                <div class="image-caption">欢迎关注我的博客</div>
            </figure>]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>前端</tag>
        <tag>密码</tag>
        <tag>加密技术</tag>
      </tags>
  </entry>
  <entry>
    <title>小白也能自己搭建博客</title>
    <url>/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="小白也能自己搭建网站"><a href="#小白也能自己搭建网站" class="headerlink" title="小白也能自己搭建网站"></a><strong>小白也能自己搭建网站</strong></h2><blockquote>
<p>从零开始，手把手教你搭建属于自己的博客</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/640.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>


<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><p>平时我们写博客都可能会发布在掘金、知乎、简书等平台上面，但是一不小心就可能把你的文章给和谐了，而且还不给你任何理由。所以为了我们能够自己发送文章，不用经过别人的审核，那就更好了。</p>
<p>前几天看到一个开源的博客模板hexo，就想拿过来用一下，没想到效果还不错。所以特此总结一下小白如何搭建自己的博客，再也不用看别人的眼色了。从今天开始呢，我也尝试着使用markdown格式来写博客，记录学习心得等。</p>
<p>其实使用 Hexo 搭建属于自己博客是很简单的事情，这个博客要使用一个托管的仓库，一般作为程序员都应该知道 github 这个网站，所以没有任何理由我们就选择它作为仓库托管。</p>
<h2 id="02-准备工作"><a href="#02-准备工作" class="headerlink" title="02 准备工作"></a>02 准备工作</h2><p>在搭建博客之前我们应该安装一些环境。</p>
<ul>
<li>Node环境</li>
<li>Git环境</li>
<li>github账号</li>
<li>阿里云域名（非必要）</li>
</ul>
<h2 id="03-安装步骤"><a href="#03-安装步骤" class="headerlink" title="03 安装步骤"></a>03 安装步骤</h2><ul>
<li>本地新建一个文件夹，用来存放项目代码</li>
<li>安装Hexo</li>
<li>与github进行关联</li>
<li>推送代码</li>
<li>域名关联（非必要）</li>
</ul>
<hr>
<p>好了，现在开始手把手教你搭建项目。</p>
<h3 id="1、Github-部分"><a href="#1、Github-部分" class="headerlink" title="1、Github 部分"></a>1、Github 部分</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302175709041.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>首先我们创建一个项目，点击new进行新建。因为我已经创建了，所以说项目已经存在。这里值得注意的是，项目名的创建一定要按照这种格式，不然会报错（别问我为什么，因为我试过）</p>
<blockquote>
<p>xxx.github.io （其中xxx是你的github账户名）</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302175912855.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="2、Git-添加Github-账号"><a href="#2、Git-添加Github-账号" class="headerlink" title="2、Git 添加Github 账号"></a>2、Git 添加Github 账号</h3><p>如果你已经安装了git环境的话在桌面右击会出现 Git Bash Here的信息。然后进去就可以添加账号了，代码操作如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"你的GitHub用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302185950459.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>【注意】：这一步很重要，这里要进行ssh密钥的生成以及账号的关联，上面是为了可以利用 Git 进行代码推送到github。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure>

<p>输入之后一路回车，最后它会显示出来放在哪个路径，然后你就可以沿着路径在本地的文件夹里面看到刚刚生成的 id_rsa.pub 密钥。一般都是在C盘里面放着，进去就可以看到密钥了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302181447255.png" alt="小白也能自己搭建博客/image-20200302181447255" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302181447255</div>
            </figure>

<p>下一步返回你的 GIthub账户，进入设置那里添加一个SSH key，title随意（可取blog_key），然后把本地id_rsa.pub里的内容复制到Key里面来，点击添加即可。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302181915596.png" alt="小白也能自己搭建博客/image-20200302181915596" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302181915596</div>
            </figure>



<h3 id="3、安装-Hexo"><a href="#3、安装-Hexo" class="headerlink" title="3、安装 Hexo"></a>3、安装 Hexo</h3><p>本地新建一个文件夹用来存放代码，可以放在任何位置。然后在这个文件夹下面运行cmd命令打开命令行。输入以下代码开始安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p>上面已经创建完成了，下面你可以使用Hexo添加文章测试一下是否已经创建成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new test_my_site</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>如果没有意外的话你就可以成功创建属于你自己的博客了，在本地打开你的博客代码，我们可以在 _config.yml配置一下你的信息。配置如下，一定不能有错（注意冒号之后有一个空格，否则也会报错）。repo的地址就写你自己的地址，格式也要正确（<font color="#dd0000">账户名/项目名</font>）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302182944242.png" alt="小白也能自己搭建博客/image-20200302182944242" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302182944242</div>
            </figure>

<p>设置完成之后保存，我们就把项目推送到 Github仓库，这样别人就可以进行访问了。步骤也依次执行以下代码即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">hexo clean  //清除缓存</span><br><span class="line">hexo g      //生成文件</span><br><span class="line">hexo d      //部署</span><br></pre></td></tr></table></figure>

<p>到此为止，你已经成功新建你的博客，然后别人也可以进行访问了。但是我在整个过程当中也踩了不少的坑，使得最后才完美地运行自己的博客。我先讲一下如何更换博客主题，最后我再讲一下如何避免踩坑。</p>
<h3 id="4、更换主题"><a href="#4、更换主题" class="headerlink" title="4、更换主题"></a>4、更换主题</h3><p>我们可以去Hexo的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题官方网站</a>下载你喜欢的主题文件，然后导入你的博客里面。直接把整一个文件夹都放在themes里面就好，然后在配置文件 _config.yml 里面的 theme 字段里面换成你的主题即可。然后重新进行部署。值得注意的是可能你的浏览器有缓存的原因，界面不会立马显示出来，你可以清除一下缓存或者换一个浏览器试一下，应该是没问题的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  //清除缓存</span><br><span class="line">hexo g      //生成文件</span><br><span class="line">hexo d      //部署</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302184830903.png" alt="小白也能自己搭建博客/image-20200302184830903" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302184830903</div>
            </figure>



<h3 id="5、新建文章"><a href="#5、新建文章" class="headerlink" title="5、新建文章"></a>5、新建文章</h3><p>博客新建好了之后我们就可以进行文章的新建和发布，新建文章可以运行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">"文章名字"</span></span><br></pre></td></tr></table></figure>

<p>然后你就可以在你的目录 source 目录下面的 _posts 文件夹下面看到你新建的文章，然后你就可以使用markdown格式进行你的文章编写了。你可以在 tags 写上文章的便签，categories 写上文章的分类。编写完成之后你就可以进行文章的发布，发布同样也是运行上面那三条命令。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302185645409.png" alt="小白也能自己搭建博客/image-20200302185645409" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302185645409</div>
            </figure>



<h3 id="６、绑定你的域名"><a href="#６、绑定你的域名" class="headerlink" title="６、绑定你的域名"></a>６、绑定你的域名</h3><p>如果你已经有申请去了域名，那么你就可以进入你的域名，点击解析。然后进去添加记录。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302200219423.png" alt="小白也能自己搭建博客/image-20200302200219423" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302200219423</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302200500273.png" alt="小白也能自己搭建博客/image-20200302200500273" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302200500273</div>
            </figure>



<p>完成之后回到你的博客，在source目录之下新建CNAME文件，内容为你刚解析的域名 （blog.你的域名/如 blog.alanwu.site）保存成所有文件不是txt文本文件。</p>
<p>最后执行命令重新部署。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  //清除缓存</span><br><span class="line">hexo g      //生成文件</span><br><span class="line">hexo d      //部署</span><br></pre></td></tr></table></figure>

<h3 id="７、踩坑记录"><a href="#７、踩坑记录" class="headerlink" title="７、踩坑记录"></a>７、踩坑记录</h3><p>通过这次的搭建博客，遇到了很多坑，但好在互联网时代比较好解决哈哈~~</p>
<p><font color="#FF7F50" size="４">1. 搭建完成后发现 标签和分类跳转为 404</font></p>
<p>我们可以在github的 issues 里面找到答案，主要是因为配置错误或者缺少文件。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302195314634.png" alt="小白也能自己搭建博客/image-20200302195314634" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302195314634</div>
            </figure>



<p><font color="#FF7F50" size="４">2. 出现左侧栏目的 icon 缺失的情况</font></p>
<p>一开始可能你不知道是什么问题，看了文档之后才发现原来是你的 icon没有写正确，它是基于font－awesome里面的图标库，你只要把图标写正确就好。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200302195736043.png" alt="小白也能自己搭建博客/image-20200302195736043" title>
                </div>
                <div class="image-caption">小白也能自己搭建博客/image-20200302195736043</div>
            </figure>



<h3 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h3><p>到现在你应该知道了怎么去新建属于你自己的博客了，大家可以看一下效果，这是我部署完的博客（<a href="http://blog.alanwu.site/" target="_blank" rel="noopener">blog.alanwu.site</a>），现在还没有什么内容。自己搭建一个博客折腾了两天的时间，但是还好，希望大家通过这篇文章你们自己也可以新建属于你自己的博客空间。</p>
<p><img src="/2020/03/02/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/GIF2020-3-214-47-34.gif" alt="小白也能自己搭建博客/image-20200302195736043"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>域名</tag>
        <tag>博客</tag>
        <tag>教程</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>2019秋招总结</title>
    <url>/2020/02/01/2019Sumarize/</url>
    <content><![CDATA[<h2 id="2019秋招总结"><a href="#2019秋招总结" class="headerlink" title="2019秋招总结"></a>2019秋招总结</h2><blockquote>
<p><strong>“</strong>激情过后，总要回归平静的生活<strong>”</strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/2019Sumarize/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>一般今天的秋招从7月就已经开始了，由于我在广州这边实习，加上公司比较忙，业务也是一些零散的东西，花时间也比较多，基本上没有时间找工作。这段时间一直持续到9月，很不巧的是9月到10月这段时间需要参加学校安排的生产实习的课程，也是在广州这边。</p>
<p>培训期间请假不能太频繁，那段时间接受到了很多的线下面试的公司，都给搁了，今年就是很多公司都喜欢线下面试，喜欢看你手写代码但你又写不出的尴尬，哈哈哈<del>~</del></p>
<p>10月放完国庆就回到学校继续大四（咸鱼）拼搏的生活了，这时候已经意识到很多公司，特别是互联网大厂基本已经内推结束了，我那时候说不慌是假的，难道只能等春招？肯定不是的，况且春招的岗位也是比较少，竞争也激烈不少，只能冲一下秋招。</p>
<p>所以我就每天都留意牛客网上面的内推直捞或者补录的信息，基本上拿到offer之前都天天看，生怕错过什么信息。看到最多的就是字节跳动的招聘，虽然说是很缺人，投了简历却没有消息，怀疑人生…难道简历写得不好还是卡我学校哈哈哈，都不得而知。那段时间都是看到内推岗位就投了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/2019Sumarize/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-面试"><a href="#02-面试" class="headerlink" title="02 面试"></a>02 面试</h2><hr>
<p>个人的刚起步的时候基础都不怎么好，所以面试的公司都大部分挂掉了。。。</p>
<p>深信服：在9月的时候收到了深信服的广工场面试，上面就是手撕代码，blabla几个题，结果一下子把我送回了家。所以必须要熟悉手写的面试题目，比如promise异步，原型链继承等。</p>
<p>阿里：大概11月份的时候，突然接到阿里的面试，开始直接就问我项目，问完之后就开始发链接过来手撕代码了，30多分钟面试，现在也没消息</p>
<p>字节跳动：也是面完阿里的隔天，字节约面试了，先是20分钟左右的前端基础知识，后面30多分钟也开始了手撕代码之旅，50分钟的面试让我头皮发麻，效率还挺高，隔天感谢信就送到。</p>
<p>腾讯：错过之前的内推，遇到上要笔试的环节，我是腾讯第三轮的笔试，一上来就5道编程题，我懵了，直接结束笔试盖上电脑</p>
<p>美团：投了，基本上一直在初筛</p>
<p>SHEIN：初筛过后，暂不匹配</p>
<p>CVTE：这个面试好像是11月末的时候，晚上聊了半个小时，全部都说了，感觉不错，昨天收到了广州线下的面试邀请，车票已经买好了，转手的收到京东offer，然后退票，血亏9块钱</p>
<p>奇安信：错过了笔试，问了一下说只能等春招。</p>
<p>老虎集团：错过了笔试</p>
<p>随手科技：11月中左右随手说我简历过了晚上笔试，发过来一份笔试，半小时后发回去，然后第二天就收到了一面邀请，过程很顺利，然后隔天就二面，也很顺利，过了几天就HR，也很顺利，说让我尽快来实习，最后也拿到了offer</p>
<p>拼多多：内推后一直初筛，后面直接挂了，暂不匹配。据说拼多多加班很严重，虽然给的很香。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/2019Sumarize/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-感想"><a href="#03-感想" class="headerlink" title="03 感想"></a>03 感想</h2><hr>
<p>想着秋招之路真的很艰辛啊，看到别人都offer拿到手抖，我却是一直白给，曾经几度怀疑人生，人间不值得。之前已经准备好想考公了，发现竞争比互联网还大，学习了两个星期，果断放弃。反正越到后面就越要越有信心，坚持就是胜利！等大佬们的offer都不要之后，我们就有最好的机会了，不要放弃呀各位牛友们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/2019Sumarize/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="04-建议"><a href="#04-建议" class="headerlink" title="04 建议"></a>04 建议</h2><hr>
<p>结合笔者在此次秋招中吸取的经验，以及浏览各大牛友的面试经验，在此总结一下如何应对残酷的秋招或者春招。一般来说秋招是最大的一次招聘会，公司都会在7月（最早）开始，到12月底（最晚）来进行招聘人才。互联网公司一般都是比较早的，银行政府类企业就比较晚。</p>
<p>那么在校生或者已经外出实习的小伙伴怎么复习呢？</p>
<h5 id="尽早实习"><a href="#尽早实习" class="headerlink" title="尽早实习"></a><strong>尽早实习</strong></h5><p>给师弟师妹的建议，大二大三就要出去找一份好的实习，比如说腾讯那种，到了春招秋招你那offer的概率起码比同龄人高50%以上。实习经历是互联网大厂最注重的一个经历，这既是一个共识也是一个择优录取的过程。</p>
<h5 id="注重基础"><a href="#注重基础" class="headerlink" title="注重基础"></a><strong>注重基础</strong></h5><p>在校生一般公司不会要求太多项目或者架构方面的知识，只要好好复习一下基础知识，不用搞花里胡哨的不实用的，写一两个比较好的项目，用到的知识点比较多，也有深度就更好了，不要写出简单页面就满足。（前端）基础的话，我前面发过一篇技术书籍推荐的文章，大家可以好好吃透里面的内容，毕竟我也是这样过来的。</p>
<h5 id="关注新技术"><a href="#关注新技术" class="headerlink" title="关注新技术"></a><strong>关注新技术</strong></h5><p>由于前端的变化近几年比较大，我们需要多关注前端的知识变迁，比如框架技术，重要是关注他的原理，比如vue的数据绑定如何实现，proxy有什么用等。一定要关注ES6和webpack，面试必考。除此之外多关注网络方面的知识，前端很喜欢考这个，把图解HTTP原理看懂就好。</p>
<h5 id="关注架构"><a href="#关注架构" class="headerlink" title="关注架构"></a><strong>关注架构</strong></h5><p>虽然我们暂时用不到，但是面试到了总监或者leader面的时候，会喜欢问架构的知识，不会细问基础实现。所以也要关注前端工程化的知识，node那些，近来也考得不少。如果你想去头条那些注重算法的公司，刷leetcode，熟悉常用的排序算法实现，要会手撕。</p>
<p>面试过程一定要有技巧，尽量引着面试官走，问倒了你不要慌，你可以直接不知道，但你了解过哪个哪个，然后有相似之处即可，不懂装懂反而会减分。多看一下牛客网上面的面试经验，你会有大大的收获的，但是要理解，背题库不可取，学会融会贯通，知识都是有相关联之处，学会建立自己的知识体系。</p>
<p>最后祝大家都拿到满意的offer！！！</p>
<p><img src="/2020/02/01/2019Sumarize/2.gif" alt></p>
]]></content>
      <tags>
        <tag>秋招</tag>
        <tag>思考</tag>
        <tag>目标</tag>
        <tag>总结</tag>
        <tag>面试</tag>
        <tag>建议</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 扬帆起航 进击前端</title>
    <url>/2020/02/01/futureGoal/</url>
    <content><![CDATA[<h2 id="2020-扬帆起航-进击前端"><a href="#2020-扬帆起航-进击前端" class="headerlink" title="2020 扬帆起航 进击前端"></a>2020 扬帆起航 进击前端</h2><blockquote>
<p> 所谓远方，其实也是一步步走出来的</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/futureGoal/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>从大三开始，这应该是我第二个年头开始学习前端了。说实话其实比想象中困难。从给网页穿上“朴素”的衣服到给网站穿上“华丽”的衣服，中间我经历了许多，再加上自学的效率难免会落下脚步。所以在新的一年里我会编写一些学习心得来帮助大家如何从一个前端小白逐步变成前端的大神。</p>
<p>一个月前开始写微信公众号，也是因为疫情原因，也要好好学习。正如凡事都有第一次一样，我本着紧张又满怀情感敲下每一个字，希望所感所想能够激励自己不忘初心，砥砺前行！</p>
<h2 id="02-目标"><a href="#02-目标" class="headerlink" title="02 目标"></a>02 目标</h2><hr>
<p>我把今年的目标归为以上三点。</p>
<ul>
<li>学习</li>
<li>总结</li>
<li>产出</li>
</ul>
<p>由于前端的发展非常迅速，我们应该时刻保持对前端的学习的热情，这也是我们为什么比35岁以上的人机会更多。人无再少年，好好珍惜活力满满，永不偷懒的日子吧！多看前端的专业书籍，基础的“三件套”以文档为主要学习途径，如菜鸟教程。后续单独写一篇关于如何选书的文章。</p>
<p>学习的过程不仅仅包含看书的过程，其实我觉得练习更是重要的一环。这也是老师和学生的区别，把别人教明白才是真正的学懂弄通。学习的基础上+刻意练习+量化产出，需要按步骤来。学习是一件慢事情，必须经过一定的积累才可以达到质变的过程。</p>
<p>还有一个很重要的学习方法就是”教学” , 在教中学习。这是初中一位生物老师所讲，非常管用的一个方法，这也是练习学习内容的一个非常重要的形式，达到查漏补缺的效果。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/futureGoal/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>第二部分就是总结部分了。我发现很多刚开始学习前端的小伙伴都会有一个习惯，就是不会总结，盲目学习。这就导致了效率低下的问题，学了后面忘了前面，但这并一定说我们总结了就一定会永远记得。想要对知识掌握到位还必须要加以刻意练习，就是我们说的代码练习。</p>
<p>那么如何总结呢？</p>
<p>其实我们很多小伙伴都可能会找一个笔记本，从头到尾列出知识点，然后对每个知识点都敲一遍。这种方法有效吗？当然有效，但是会浪费很多时间，我们知道程序员的时间就是生命，所以我们不建议这种学习方法。我入门前端以来可谓踩过不少的坑，而且还很愿意踩那种。</p>
<h5 id="切忌沉迷教学视频"><a href="#切忌沉迷教学视频" class="headerlink" title="切忌沉迷教学视频"></a><strong>切忌沉迷教学视频</strong></h5><p>因为开始并不喜欢看文档，不喜欢看厚厚的技术书籍，所以一天到晚都只会看看教学视频。不知道是不是老师时间多还是怕我们跟不上，前端的历史都给我扯半天，这种就是质量差的教学视频，不关注重点。但并不是质量好的视频你就会如鱼得水，关键你得会学。一般学习一项新的技能点，我一般都会从基础出发，把知识点粗略过一遍，知道有这个东西就好，不必深究。</p>
<p>跟着视频学习对我的帮助很大，特别是早期的时候，因为没有人带我走，所以都是摸着石头过河。可能有些同学踩到了深处便会原路返回，其实那只是一个小坑，并不是整个河流都这样。所以有成就，有产出，有效果才是前端人坚持下去的一个很重要的原因。这也是我们为什么对前端感兴趣的原因，重要是短期内有效果出来。</p>
<p>找一个质量好的视频，比如慕课网，对我的学习起到了不少的帮助。一点一点跟着敲，你就会有成就感，坚持就是时间和兴趣的问题了。把里面的关键技术拿小本本记好，重要的是他的思想逻辑，是怎么一步步到这里的。</p>
<h5 id="学会用脑图"><a href="#学会用脑图" class="headerlink" title="学会用脑图"></a><strong>学会用脑图</strong></h5><p>学习是一个连续的过程，写在你的纸质笔记本可不是推荐的做法。因为你过几个月可能就忘了有这么一回事。我个人是使用百度脑图，里面可以编辑你的知识点，特别适合书籍的系统学习，你可以找一个文件夹专门放置你的学习内容，以后就只能在这里学，这样就会有一个知识库在这里。</p>
<p>里面的脑图不仅可以到处pdf，还可以导出图片，我们可以拿来做知识的查漏补缺。学习是有一个通性在里面，你学过的知识都会有联系的，大牛的知识就是把所有的知识都联系在一起，而不是简单的堆砌，这就是知识体系。所以为什么要建立一个知识体系对以后的学习发展有重大的作用。</p>
<p>除了脑图之外，还可以使用有道云笔记，也是一个很不错的笔记本，支持markdown编辑。善于运用软件，运用线上的知识，紧跟大牛脚步。相信你是不会差的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/futureGoal/2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<p>最后一部分就是产出。所谓产出就是对知识的运用，知识你学了不用跟没学一样，关键是有用武之地。产出部门比学习部分重要，但是学习是基础，两者相辅相成。可能很多小伙伴都没有产出的习惯，学了就是自己的，也没有写博客逛社区的习惯，分享知识的过程中你会有更好的收获，相信我。</p>
<p>那我们该如何产出呢？</p>
<h5 id="写技术博客"><a href="#写技术博客" class="headerlink" title="写技术博客"></a><strong>写技术博客</strong></h5><p>不用自己去搭建一个博客（要是可以就更好了），选择一个平台，CSDN或者掘金都是不错的平台，然后就可以开始你的表演了。可以写一些最近的学习心得，面试技巧以及黑科技工具的使用等等。写博客的好处有很多，不仅可以锻炼的表达逻辑，还可以巩固你的知识体系。两全其美，何乐而不为？</p>
<p>另外就是可以多逛一下技术社区，了解前端的动态，多关注最近出了什么新技术、新框架、新八卦等等。试着去帮别人解答一些问题，别人也很愿意去听，但是不要抬杠。乐于分享的心态比技术本身更重要。</p>
<h5 id="写项目"><a href="#写项目" class="headerlink" title="写项目"></a><strong>写项目</strong></h5><p>找一个idea，把之前所学的知识点用一下，或者用新的知识来重构一下旧的项目，都是一种产出的方法。如果你担心知识不够牢固可以上一下github找一些优质开源项目，看别人是怎么写的。项目中要把用到技术的那一块注释出来，不然过一个月都不知道是你写的。</p>
<h5 id="交流心得"><a href="#交流心得" class="headerlink" title="交流心得"></a><strong>交流心得</strong></h5><p>要是可以的话，可以找同学一起交流最近的学习成果。技术学习的路上是枯燥的，找到相同的学习伙伴很重要，能够给你一种学下去的动力，两个相互切磋相互进步也是一种产出的方法。</p>
<p>面试。如果你觉得技术还可以，基础还不错的话就尝试去面试一下，面试官一般比你的层次高很多，知识储备也比你多，所以面试是一个非常重要的过程，还可以查漏补缺，完善自己的知识体系。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/futureGoal/3.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="03-展望"><a href="#03-展望" class="headerlink" title="03 展望"></a>03 展望</h2><hr>
<p>2020是一个新的起点，对于快要毕业的我也将面临很多挑战和未知，也是一个进步、成长的一年。很荣幸今年拿到了一线互联网大厂的offer，在这一年里我将继续保持学习，期待自己能够取得更大的进步！</p>
<p>大家共勉！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/02/01/futureGoal/2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>目标</tag>
        <tag>心得</tag>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>系统总结浏览器缓存</title>
    <url>/2020/01/31/navigatorCache/</url>
    <content><![CDATA[<h2 id="系统总结浏览器缓存"><a href="#系统总结浏览器缓存" class="headerlink" title="系统总结浏览器缓存"></a>系统总结浏览器缓存</h2><blockquote>
<p>“激情过后，总要回归平静的生活”</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/01/31/navigatorCache/1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h2><hr>
<p>前端的工作与各大浏览器的关系紧密相连，尤其是对于性能这一块的联系及其重要。在用户体验上来看，一个请求的时间超过3秒，那么就会失去这个用户，所以利用缓存来提升性能以及用户体验都是很重要的。</p>
<p>前端对于任一个网络请求来说，可以将请求分为三个阶段。网络请求，后端处理，浏览器响应。缓存可以优化我们的第一步和第三步，一个网络请求做到性能最优，就必须提升三者各自的性能，避免短板效应。</p>
<p>接下来我会从缓存位置，缓存策略来结合具体场景分析浏览器缓存机制。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/01/31/navigatorCache/1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="02-缓存位置"><a href="#02-缓存位置" class="headerlink" title="02 缓存位置"></a>02 缓存位置</h2><hr>
<blockquote>
<p>通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。 ——谷歌官方</p>
</blockquote>
<p>浏览器缓存并非是一个“总体”概念，其实它也是有先后顺序的。总的来说分为以下4个方面。</p>
<ol>
<li>Memory Cache</li>
<li>Service Worker Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/01/31/navigatorCache/1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>从这张图中我们可以清楚地看到浏览器缓存的具体位置，其中的网络请求都会有不同位置的缓存。考虑到HTTP缓存是最主要、最有代表性的缓存策略，也是每一位前端工程师都应该深刻理解并掌握的知识。</p>
<h5 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a><strong>Memory Cache</strong></h5><p>Memory Cacha是指内存中的缓存。它是浏览器优先去命中的一种缓存，也是响应速度最快的一种缓存。但是它的缺点是缓存时间短，关闭tab页面缓存将不复存在，它与浏览器渲染进程紧密联系。</p>
<p>那么哪一些文件会被放到这一缓存里面呢？其实这没有官方的说明，由于浏览器的内存非常有限，浏览器并不会把所有文件都缓存在此处。一般来说会缓存一些体积不大的js或者css文件。</p>
<h5 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a><strong>Service Worker Cache</strong></h5><p>Service Worker 是一种独立于主线程之外的javascript线程。它脱离于浏览器窗体，因此无法直接访问DOM元素。所以这一个独立的线程能够在不干扰主线程的情况下来提升性能。Service Worker 的缓存与浏览器内建的其他缓存机制不一样，它可以让我们自由缓存哪一些文件、如何匹配缓存等，且缓存具有持续性。</p>
<p>实现该缓存一般分为3个步骤：首先注册Service Worker ，然后监听install事件就可以缓存我们想要的文件。用户下次访问可以通过拦截请求的方式来获取缓存数据。若没有则会重新获取数据，然后再进行缓存。</p>
<p>Service Worker 可以用来实现离线缓存、消息推送以及网络代理等功能。那我们如何使用这种缓存呢？</p>
<p>注册：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.serviceWorker.register(<span class="string">'/test.js'</span>).then(</span><br><span class="line">   <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'注册成功'</span>)</span><br><span class="line">   &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">"注册失败"</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>监听事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Service Worker会监听 install事件，我们在其对应的回调里可以实现初始化的逻辑  </span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// 考虑到缓存也需要更新，open内传入的参数为缓存的版本号</span></span><br><span class="line">    caches.open(<span class="string">'test-v1'</span>).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="comment">// 此处传入指定的需缓存的文件名</span></span><br><span class="line">        <span class="string">'/test.html'</span>,</span><br><span class="line">        <span class="string">'/test.css'</span>,</span><br><span class="line">        <span class="string">'/test.js'</span></span><br><span class="line">      ])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从Service Worker中取到缓存的目的</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    <span class="comment">// 尝试匹配该请求对应的缓存值</span></span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果匹配到了，调用Server Worker缓存</span></span><br><span class="line">      <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没匹配到，向服务端发起这个资源请求</span></span><br><span class="line">      <span class="keyword">return</span> fetch(event.request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求成功的话，将请求缓存起来。</span></span><br><span class="line">        caches.open(<span class="string">'test-v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, response);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response.clone();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>PS：大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。</p>
<h5 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a><strong>Disk Cache</strong></h5><p>Disk Cache也就是硬盘缓存。这种缓存的缓存位置在电脑硬盘上，什么文件都可以缓存，就是读取速度慢。所有缓存中，它的覆盖面是最广的，会根据HTTP Header中的字段判断哪一些资源需要缓存，哪些可以不请求直接使用，哪一些已过期需要重新请求。</p>
<p>浏览器通常会把哪些文件放进缓存呢?</p>
<ul>
<li>大体积文件</li>
<li>系统内存使用率高</li>
</ul>
<h5 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a><strong>Push Cache</strong></h5><p>Push Cache又名推送缓存，是HTTP/2中的内容，只有以上三种缓存未正确命中，它才会使用。仅存在于会话阶段（session），结束就会释放，缓存时间短。</p>
<p>由于国内用的比较少，网上查找后总结几个结论：</p>
<ul>
<li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li>
<li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache</li>
<li>Push Cache 是缓存的最后一道防线。浏览器均未命中以上的情况下才会去询问 Push Cache。</li>
<li>Push Cache中的缓存只能被使用一次。</li>
</ul>
<p><img src="/2020/01/31/navigatorCache/2.webp" alt></p>
<h2 id="03-缓存策略"><a href="#03-缓存策略" class="headerlink" title="03 缓存策略"></a>03 缓存策略</h2><hr>
<p>浏览器缓存策略通常分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>。</p>
<p>一次HTTP请求示意图如下所示。浏览器第一次发起请求，事先询问浏览器是否有缓存。没有则向服务器进行请求，然后结果进行缓存。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/01/31/navigatorCache/1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a><strong>强缓存</strong></h5><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。</p>
<p>expires 是一个时间戳，二次请求我们试图向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。</p>
<p>它最大的问题在于对“本地时间”有很大的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。所以我们有第二种方法Cache-Control。</p>
<p>Cache-Control 是一个时间长度，我们通过 <code>max-age</code> 来控制资源的有效期，它意味着该资源在时间长度以内都是有效的，完美地规避了时间戳带来的潜在问题。它的优先级更高，当两者同时出现的时候我们以Cache-Control为准。</p>
<p>Cache-Control有如下字段比较常见。</p>
<h6 id="s-maxage-和-max-age"><a href="#s-maxage-和-max-age" class="headerlink" title="s-maxage 和 max-age"></a><strong>s-maxage 和 max-age</strong></h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cache-control: max-age=<span class="number">3600</span>, s-maxage=<span class="number">31536000</span></span><br></pre></td></tr></table></figure>

<p>s-maxage的优先级比max-age高。s-maxage是代理服务器的缓存时间。客户端中我们以max-age为准。</p>
<h6 id="public-与-private"><a href="#public-与-private" class="headerlink" title="public 与 private"></a><strong>public 与 private</strong></h6><p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值。</p>
<h6 id="no-store-与-no-cache"><a href="#no-store-与-no-cache" class="headerlink" title="no-store 与 no-cache"></a><strong>no-store 与 no-cache</strong></h6><p>no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（协商缓存）。</p>
<p>no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。</p>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h5><p>协商缓存依赖于服务端与浏览器之间的通信。</p>
<p>协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。</p>
<p>如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，对应状态码是304。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/01/31/navigatorCache/2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>协商缓存有两个字段：Last-Modified 和 Etag</p>
<p>Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Last-Modified: Fri, 25 Oct 2018 06:35:57 GMT</span><br></pre></td></tr></table></figure>

<p>随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Last-Modified: Fri, <span class="number">25</span> Oct <span class="number">2018</span> <span class="number">06</span>:<span class="number">35</span>:<span class="number">57</span> GMT</span><br></pre></td></tr></table></figure>

<p>服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。</p>
<p><strong>缺点与弊端：</strong></p>
<ul>
<li>手动改动服务器内容，即使没有修改内容，但服务器也认为是新的内容。进而引发一次完整的响应——不该重新请求的时候，也会重新请求。</li>
<li>修改文件速度过快（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。</li>
</ul>
<p>为了解决问题，Etag出现了。Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。</p>
<p>Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETag: W&#x2F;&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>

<p>那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match: W&#x2F;&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>

<p>Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。Etag的优先级比Last-Modified高。</p>
<p><img src="/2020/01/31/navigatorCache/3.webp" alt></p>
<p><img src="/2020/01/31/navigatorCache/2.gif" alt></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>网络</tag>
        <tag>缓存</tag>
        <tag>性能</tag>
      </tags>
  </entry>
</search>
